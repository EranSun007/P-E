import{e as $,d as p,z as E}from"./index-ByFAet0J.js";import"./chunk-DHGN2BiO.js";import"./chunk-pjYta8vt.js";import"./chunk-CZDJnSNg.js";class _ extends Error{constructor(e,t,n=null){super(e),this.name="CalendarServiceError",this.code=t,this.originalError=n}}class l extends _{constructor(e,t=null){super(e,"VALIDATION_ERROR"),this.field=t}}class h extends _{constructor(e,t=null,n=null){super(e,"NOT_FOUND"),this.entityType=t,this.entityId=n}}class v extends _{constructor(e,t=null){super(e,"DUPLICATE_ERROR"),this.duplicateData=t}}class w extends _{constructor(e,t=null,n=null){super(e,"OPERATION_ERROR",n),this.operation=t}}class k{static async _retryOperation(e,t={}){const{maxRetries:n=3,baseDelay:o=1e3,maxDelay:i=1e4,backoffMultiplier:r=2,operationName:c="operation",shouldRetry:m=null,onRetry:g=null}=t;let u,f=o;for(let a=1;a<=n;a++)try{const s=await e();return a>1&&console.log(`${c} succeeded on attempt ${a}/${n}`),s}catch(s){if(u=s,!(m?m(s,a):this._isRetryableError(s)))throw console.log(`${c} failed with non-retryable error: ${s.message}`),s;if(a>=n){console.error(`${c} failed after ${n} attempts: ${s.message}`);break}console.warn(`${c} failed on attempt ${a}/${n}: ${s.message}. Retrying in ${f}ms...`),g&&g(s,a,f),await new Promise(b=>setTimeout(b,f));const O=Math.random()*.1*f;f=Math.min(f*r+O,i)}throw new w(`Operation failed after ${n} attempts: ${u.message}`,c,u)}static _isRetryableError(e){if(e instanceof l||e instanceof h||e instanceof v)return!1;const t=e.message?.toLowerCase()||"";return t.includes("permission")||t.includes("unauthorized")||t.includes("forbidden")||t.includes("access denied")||t.includes("quota")||t.includes("limit exceeded")||t.includes("rate limit")||t.includes("malformed")||t.includes("invalid format")||t.includes("bad request")?!1:(t.includes("network")||t.includes("timeout")||t.includes("connection")||t.includes("fetch")||t.includes("server error")||t.includes("service unavailable")||t.includes("internal error"),!0)}static _generateUserFeedback(e,t,n=null,o={}){const i={operation:e,success:t,timestamp:new Date().toISOString(),context:o};if(t)switch(e){case"createOneOnOneMeeting":i.message=`Successfully scheduled 1:1 meeting${o.teamMemberName?` with ${o.teamMemberName}`:""}`,i.type="success";break;case"updateOneOnOneMeeting":i.message="Meeting successfully rescheduled",i.type="success";break;case"deleteOneOnOneMeeting":i.message="Meeting successfully cancelled",i.type="success";break;default:i.message="Calendar operation completed successfully",i.type="success"}else i.error={message:n.message,code:n.code||"UNKNOWN_ERROR",type:n.constructor.name},n instanceof l?(i.message=`Invalid input: ${n.message}`,i.type="validation_error",i.field=n.field):n instanceof h?(i.message=`Not found: ${n.message}`,i.type="not_found_error"):n instanceof v?(i.message=`Duplicate meeting: ${n.message}`,i.type="duplicate_error"):(i.message=`Failed to ${e.replace(/([A-Z])/g," $1").toLowerCase()}: ${n.message}`,i.type="error");return i}static generateOneOnOneTitle(e){if(!e||typeof e!="string"||e.trim().length===0)throw new l("Team member name is required and must be a non-empty string","teamMemberName");return`${e.trim()} 1:1`}static _validateDateTime(e,t="dateTime",n=!1,o=5){if(!e)throw new l(`${t} is required`,t);if(typeof e!="string")throw new l(`${t} must be a string`,t);const i=new Date(e);if(isNaN(i.getTime()))throw new l(`Invalid ${t} format. Expected ISO string, received: "${e}"`,t);const r=new Date,c=new Date(r);if(c.setFullYear(c.getFullYear()+2),i>c)throw new l(`${t} cannot be more than 2 years in the future. Provided date: ${i.toISOString()}, maximum allowed: ${c.toISOString()}`,t);if(!n){const m=Math.max(o,1)*60*1e3,g=new Date(r.getTime()-m);if(i<g){const u=r.getTime()-i.getTime(),f=Math.round(u/(60*1e3));throw new l(`${t} cannot be in the past. Provided date: ${i.toISOString()}, current time: ${r.toISOString()} (${f} minutes ago)`,t)}}return i}static async _validateTeamMember(e,t="teamMemberId"){if(!e)throw new l(`${t} is required`,t);if(typeof e!="string")throw new l(`${t} must be a string`,t);let n=null;try{n=await $.get(e)}catch(o){throw new w(`Failed to fetch team member: ${o.message}`,"validateTeamMember",o)}if(!n)throw new h("Team member not found","TeamMember",e);if(!n.id||!n.name)throw new l("Team member missing required properties (id, name)",t);return n}static async _validateCalendarEvent(e,t=!0,n="eventId"){if(!e)throw new l(`${n} is required`,n);if(typeof e!="string")throw new l(`${n} must be a string`,n);const o=await p.get(e);if(!o)throw new h("Calendar event not found","CalendarEvent",e);if(t&&o.event_type!=="one_on_one")throw new l("Event is not a 1:1 meeting","eventType");return o}static async _checkForDuplicateEvents(e,t,n=null){if(!e||!t)return null;if(!(t instanceof Date)||isNaN(t.getTime()))return console.warn("Invalid date provided to _checkForDuplicateEvents:",t),null;try{const o=await this.getOneOnOneMeetingsForTeamMember(e);if(!Array.isArray(o))return console.warn("getOneOnOneMeetingsForTeamMember returned non-array:",o),null;const i=t.toDateString();return o.find(c=>{if(!c||typeof c!="object"||n&&c.id===n||!c.start_date)return!1;try{const m=new Date(c.start_date);return isNaN(m.getTime())?!1:m.toDateString()===i}catch(m){return console.warn("Error parsing event date:",c.start_date,m),!1}})||null}catch(o){return console.warn("Error checking for duplicate events:",o),null}}static async _validateOneOnOne(e,t="oneOnOneId"){if(!e)throw new l(`${t} is required`,t);if(typeof e!="string")throw new l(`${t} must be a string`,t);let n=null;try{n=await E.list()}catch(i){throw new w(`Failed to fetch OneOnOne records: ${i.message}`,"validateOneOnOne",i)}if(!Array.isArray(n))throw new DataError("OneOnOne.list() returned invalid data - expected array","OneOnOne");const o=n.find(i=>!i||typeof i!="object"?!1:i.id===e);if(!o)throw new h("OneOnOne record not found","OneOnOne",e);return o}static _validateDuration(e,t="durationMinutes"){if(e==null)return 30;if(typeof e!="number")throw new l(`${t} must be a number`,t);if(e<=0)throw new l(`${t} must be greater than 0`,t);if(e>480)throw new l(`${t} cannot exceed 8 hours (480 minutes)`,t);return e}static async validateDataConsistency(e={}){const{fixInconsistencies:t=!1,includeOrphanedEvents:n=!0,includeMissingLinks:o=!0,includeInvalidData:i=!0}=e;try{console.log("Starting comprehensive data consistency validation...");const r={timestamp:new Date().toISOString(),totalEventsChecked:0,totalOneOnOnesChecked:0,inconsistencies:{orphanedEvents:[],missingLinks:[],invalidData:[],duplicateEvents:[],brokenReferences:[]},fixes:{applied:[],failed:[]},summary:{isConsistent:!0,totalIssues:0,fixesApplied:0,fixesFailed:0}},[c,m,g]=await Promise.all([this.getOneOnOneMeetings(),E.list(),$.list()]);if(r.totalEventsChecked=c.length,r.totalOneOnOnesChecked=m.length,n){const a=new Set(m.filter(s=>s.next_meeting_calendar_event_id).map(s=>s.next_meeting_calendar_event_id));for(const s of c)!a.has(s.id)&&(!s.linked_entity_id||!m.find(O=>O.id===s.linked_entity_id))&&r.inconsistencies.orphanedEvents.push({eventId:s.id,title:s.title,teamMemberId:s.team_member_id,startDate:s.start_date,issue:"Calendar event not linked to any OneOnOne record"})}if(o)for(const a of m)a.next_meeting_date&&!a.next_meeting_calendar_event_id&&r.inconsistencies.missingLinks.push({oneOnOneId:a.id,teamMemberId:a.team_member_id,nextMeetingDate:a.next_meeting_date,issue:"OneOnOne has next_meeting_date but no calendar event"}),a.next_meeting_calendar_event_id&&(c.find(d=>d.id===a.next_meeting_calendar_event_id)||r.inconsistencies.brokenReferences.push({oneOnOneId:a.id,teamMemberId:a.team_member_id,referencedEventId:a.next_meeting_calendar_event_id,issue:"OneOnOne references non-existent calendar event"}));if(i)for(const a of c){const s=[],d=g.find(D=>D.id===a.team_member_id);if(!d)s.push("Team member not found");else{const D=this.generateOneOnOneTitle(d.name);a.title!==D&&s.push(`Title mismatch: expected "${D}", got "${a.title}"`)}a.event_type!=="one_on_one"&&s.push(`Incorrect event type: expected "one_on_one", got "${a.event_type}"`),a.linked_entity_type!=="one_on_one"&&s.push(`Incorrect linked entity type: expected "one_on_one", got "${a.linked_entity_type}"`);const O=new Date(a.start_date),b=new Date(a.end_date);isNaN(O.getTime())||isNaN(b.getTime())?s.push("Invalid date format"):b<=O&&s.push("End date must be after start date"),s.length>0&&r.inconsistencies.invalidData.push({eventId:a.id,title:a.title,teamMemberId:a.team_member_id,issues:s})}const u={};for(const a of c){const s=new Date(a.start_date).toDateString(),d=`${a.team_member_id}-${s}`;u[d]||(u[d]=[]),u[d].push(a)}for(const[a,s]of Object.entries(u))s.length>1&&r.inconsistencies.duplicateEvents.push({key:a,teamMemberId:s[0].team_member_id,date:new Date(s[0].start_date).toDateString(),events:s.map(d=>({id:d.id,title:d.title})),count:s.length});const f=[...r.inconsistencies.orphanedEvents,...r.inconsistencies.missingLinks,...r.inconsistencies.invalidData,...r.inconsistencies.duplicateEvents,...r.inconsistencies.brokenReferences];if(r.summary.totalIssues=f.length,r.summary.isConsistent=f.length===0,t&&f.length>0){console.log(`Attempting to fix ${f.length} inconsistencies...`);for(const a of r.inconsistencies.orphanedEvents)try{await this.deleteOneOnOneMeeting(a.eventId),r.fixes.applied.push({type:"orphaned_event_deleted",eventId:a.eventId,title:a.title})}catch(s){r.fixes.failed.push({type:"orphaned_event_deletion_failed",eventId:a.eventId,error:s.message})}for(const a of r.inconsistencies.brokenReferences)try{await E.update(a.oneOnOneId,{next_meeting_calendar_event_id:null}),r.fixes.applied.push({type:"broken_reference_cleared",oneOnOneId:a.oneOnOneId,referencedEventId:a.referencedEventId})}catch(s){r.fixes.failed.push({type:"broken_reference_fix_failed",oneOnOneId:a.oneOnOneId,error:s.message})}r.summary.fixesApplied=r.fixes.applied.length,r.summary.fixesFailed=r.fixes.failed.length}return console.log("Data consistency validation completed:",{totalIssues:r.summary.totalIssues,isConsistent:r.summary.isConsistent,fixesApplied:r.summary.fixesApplied}),r}catch(r){throw console.error("Error during data consistency validation:",r),new w(`Data consistency validation failed: ${r.message}`,"validateDataConsistency",r)}}static async createOneOnOneMeeting(e,t,n,o=30){const i="createOneOnOneMeeting";try{if(!e)throw new l("Team member ID is required","teamMemberId");if(!t||typeof t!="string"||t.trim().length===0)throw new l("Team member name is required and must be a non-empty string","teamMemberName");if(!n)throw new l("Date/time is required","dateTime");if(o&&(typeof o!="number"||o<=0))throw new l("Duration must be a positive number","durationMinutes");if(!await $.get(e))throw new h("Team member not found","TeamMember",e);const c=this._validateDateTime(n,"dateTime",!1,5),m=await this.getOneOnOneMeetingsForTeamMember(e),u=(Array.isArray(m)?m:[]).find(d=>{if(!d||typeof d!="object"||!d.start_date)return!1;try{const O=new Date(d.start_date);return isNaN(O.getTime())?!1:O.toDateString()===c.toDateString()}catch(O){return console.warn("Error parsing event date:",d.start_date,O),!1}});if(u)throw new v(`A 1:1 meeting already exists for ${t} on ${c.toDateString()}`,{existingEventId:u.id,date:c.toDateString()});const f=new Date(c.getTime()+o*60*1e3),a=this.generateOneOnOneTitle(t),s=await this._retryOperation(async()=>await p.create({title:a,description:`1:1 meeting with ${t}`,start_date:c.toISOString(),end_date:f.toISOString(),all_day:!1,location:null,event_type:"one_on_one",team_member_id:e,linked_entity_type:"one_on_one",linked_entity_id:null}),{maxRetries:3,baseDelay:1e3,operationName:`create calendar event for ${t}`,shouldRetry:(d,O)=>d instanceof l&&d.field==="dateTime"&&O>1?!1:this._isRetryableError(d)});return console.log(`Successfully created calendar event: ${a} (${s.id})`),s}catch(r){if(r instanceof _)throw r;const c=new w(`Failed to create 1:1 meeting calendar event: ${r.message}`,i,r);throw console.error("Error creating 1:1 meeting calendar event:",c),c}}static async updateOneOnOneMeeting(e,t,n=30){const o="updateOneOnOneMeeting";try{if(!e)throw new l("Event ID is required","eventId");if(!t)throw new l("Date/time is required","dateTime");if(n&&(typeof n!="number"||n<=0))throw new l("Duration must be a positive number","durationMinutes");const i=await p.get(e);if(!i)throw new h("Calendar event not found","CalendarEvent",e);if(i.event_type!=="one_on_one")throw new l("Event is not a 1:1 meeting","eventType");const r=this._validateDateTime(t,"dateTime",!1,5);if(i.team_member_id){const u=(await this.getOneOnOneMeetingsForTeamMember(i.team_member_id)).find(f=>f.id===e?!1:new Date(f.start_date).toDateString()===r.toDateString());if(u)throw new v(`Another 1:1 meeting already exists on ${r.toDateString()}`,{conflictingEventId:u.id,date:r.toDateString()})}const c=new Date(r.getTime()+n*60*1e3),m=await this._retryOperation(async()=>await p.update(e,{start_date:r.toISOString(),end_date:c.toISOString()}),{maxRetries:3,baseDelay:1e3,operationName:`update calendar event ${e}`,shouldRetry:(g,u)=>g instanceof l&&g.field==="dateTime"&&u>1?!1:this._isRetryableError(g)});return console.log(`Successfully updated calendar event: ${i.title} (${e})`),m}catch(i){if(i instanceof _)throw i;const r=new w(`Failed to update 1:1 meeting calendar event: ${i.message}`,o,i);throw console.error("Error updating 1:1 meeting calendar event:",r),r}}static async deleteOneOnOneMeeting(e){const t="deleteOneOnOneMeeting";try{if(!e)throw new l("Event ID is required","eventId");const n=await p.get(e);if(!n)throw new h("Calendar event not found","CalendarEvent",e);if(n.event_type!=="one_on_one")throw new l("Event is not a 1:1 meeting","eventType");return await this._retryOperation(async()=>{await p.delete(e)},3,`delete calendar event ${e}`),console.log(`Successfully deleted calendar event: ${n.title} (${e})`),!0}catch(n){if(n instanceof _)throw n;const o=new w(`Failed to delete 1:1 meeting calendar event: ${n.message}`,t,n);throw console.error("Error deleting 1:1 meeting calendar event:",o),o}}static async getOneOnOneMeetings(){try{const e=await p.list();return Array.isArray(e)?e.filter(n=>!n||typeof n!="object"?!1:n.event_type==="one_on_one"):(console.warn("CalendarEvent.list() returned non-array:",e),[])}catch(e){throw console.error("Error fetching 1:1 meeting calendar events:",e),e}}static async getOneOnOneMeetingsForTeamMember(e){try{return!e||typeof e!="string"?(console.warn("Invalid teamMemberId provided to getOneOnOneMeetingsForTeamMember:",e),[]):(await this.getOneOnOneMeetings()).filter(o=>!o||typeof o!="object"?!1:o.team_member_id===e)}catch(t){throw console.error(`Error fetching 1:1 meeting calendar events for team member ${e}:`,t),t}}static async linkMeetingToCalendarEvent(e,t){try{if(!e||!t)throw new Error("OneOnOne ID and Calendar Event ID are required");const n=await E.update(e,{next_meeting_calendar_event_id:t});return await p.update(t,{linked_entity_id:e}),n}catch(n){throw console.error("Error linking OneOnOne to CalendarEvent:",n),n}}static async createAndLinkOneOnOneMeeting(e,t,n,o=30){try{const i=await this._validateOneOnOne(e),r=await this._validateTeamMember(t),c=this._validateDateTime(n),m=this._validateDuration(o);if(i.team_member_id!==t)throw new l("Team member ID mismatch between OneOnOne record and provided team member ID","teamMemberId");const g=await this._checkForDuplicateEvents(t,c);if(g)throw new v(`A 1:1 meeting already exists for ${r.name} on ${c.toDateString()}`,{existingEventId:g.id,date:c.toDateString()});const u=await this.createOneOnOneMeeting(t,r.name,n,m),f=await this.linkMeetingToCalendarEvent(e,u.id);return console.log(`Successfully created and linked 1:1 meeting: ${r.name} (${u.id})`),{calendarEvent:u,oneOnOne:f}}catch(i){throw console.error("Error creating and linking 1:1 meeting:",i),i}}}export{k as CalendarService,_ as CalendarServiceError,v as DuplicateError,h as NotFoundError,w as OperationError,l as ValidationError};
