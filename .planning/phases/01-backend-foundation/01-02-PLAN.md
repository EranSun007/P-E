---
phase: 01-backend-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - server/services/JiraService.js
autonomous: true
user_setup: []

must_haves:
  truths:
    - "syncIssues upserts issues with ON CONFLICT and returns created/updated counts"
    - "All queries filter by user_id (multi-tenancy enforced)"
    - "Team member mappings can be created, listed, and deleted"
    - "Service exports singleton instance following GitHubService pattern"
  artifacts:
    - path: "server/services/JiraService.js"
      provides: "Jira data access layer"
      exports: ["default (JiraService instance)"]
      min_lines: 150
  key_links:
    - from: "server/services/JiraService.js"
      to: "server/db/connection.js"
      via: "import { query }"
      pattern: "import.*query.*from.*connection"
---

<objective>
Implement JiraService following the established GitHubService pattern.

Purpose: Provide data access layer for Jira issues and team mappings with proper multi-tenancy.
Output: JiraService.js with syncIssues, CRUD operations, and team mapping methods.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/01-backend-foundation/01-01-SUMMARY.md

Reference patterns:
@server/services/GitHubService.js (service pattern to follow)
@server/db/connection.js (query helper)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create JiraService.js with core sync and query methods</name>
  <files>server/services/JiraService.js</files>
  <action>
Create server/services/JiraService.js following GitHubService pattern exactly.

**File structure:**
```javascript
import { query } from '../db/connection.js';

class JiraService {
  // ============================================
  // Issue Sync Operations
  // ============================================

  /**
   * Sync batch of Jira issues (upsert)
   * @param {string} userId - User ID for multi-tenancy
   * @param {Array} issuesData - Array of issue objects from extension
   * @returns {Object} - { created, updated, total }
   */
  async syncIssues(userId, issuesData) {
    let created = 0;
    let updated = 0;

    for (const issue of issuesData) {
      const sql = `
        INSERT INTO jira_issues (
          user_id, issue_key, summary, status, assignee_name, assignee_id,
          story_points, priority, issue_type, sprint_name, epic_key, jira_url,
          synced_at
        )
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, CURRENT_TIMESTAMP)
        ON CONFLICT (user_id, issue_key)
        DO UPDATE SET
          summary = EXCLUDED.summary,
          status = EXCLUDED.status,
          assignee_name = EXCLUDED.assignee_name,
          assignee_id = EXCLUDED.assignee_id,
          story_points = EXCLUDED.story_points,
          priority = EXCLUDED.priority,
          issue_type = EXCLUDED.issue_type,
          sprint_name = EXCLUDED.sprint_name,
          epic_key = EXCLUDED.epic_key,
          jira_url = EXCLUDED.jira_url,
          synced_at = CURRENT_TIMESTAMP,
          updated_date = CURRENT_TIMESTAMP
        RETURNING (xmax = 0) AS was_insert
      `;

      const result = await query(sql, [
        userId,
        issue.issue_key,
        issue.summary,
        issue.status,
        issue.assignee_name,
        issue.assignee_id,
        issue.story_points,
        issue.priority,
        issue.issue_type,
        issue.sprint_name,
        issue.epic_key,
        issue.jira_url
      ]);

      if (result.rows[0]?.was_insert) {
        created++;
      } else {
        updated++;
      }
    }

    return { created, updated, total: issuesData.length };
  }

  // ============================================
  // Issue CRUD Operations
  // ============================================

  /**
   * List all Jira issues for a user
   * @param {string} userId - User ID for multi-tenancy
   * @param {Object} filters - Optional filters (status, assignee_id, sprint_name)
   * @returns {Array} - Array of issue objects
   */
  async listIssues(userId, filters = {}) {
    let sql = `
      SELECT * FROM jira_issues
      WHERE user_id = $1
    `;
    const params = [userId];
    let paramIndex = 2;

    if (filters.status) {
      sql += ` AND status = $${paramIndex}`;
      params.push(filters.status);
      paramIndex++;
    }

    if (filters.assignee_id) {
      sql += ` AND assignee_id = $${paramIndex}`;
      params.push(filters.assignee_id);
      paramIndex++;
    }

    if (filters.sprint_name) {
      sql += ` AND sprint_name = $${paramIndex}`;
      params.push(filters.sprint_name);
      paramIndex++;
    }

    sql += ' ORDER BY synced_at DESC';

    const result = await query(sql, params);
    return result.rows;
  }

  /**
   * Get a single Jira issue by ID
   * @param {string} userId - User ID for multi-tenancy
   * @param {string} issueId - Issue UUID
   * @returns {Object|null} - Issue object or null
   */
  async getIssue(userId, issueId) {
    const sql = `
      SELECT * FROM jira_issues
      WHERE id = $1 AND user_id = $2
    `;
    const result = await query(sql, [issueId, userId]);
    return result.rows[0] || null;
  }

  /**
   * Get a Jira issue by key
   * @param {string} userId - User ID for multi-tenancy
   * @param {string} issueKey - Jira issue key (e.g., PROJ-123)
   * @returns {Object|null} - Issue object or null
   */
  async getIssueByKey(userId, issueKey) {
    const sql = `
      SELECT * FROM jira_issues
      WHERE user_id = $1 AND issue_key = $2
    `;
    const result = await query(sql, [userId, issueKey]);
    return result.rows[0] || null;
  }

  /**
   * Delete a Jira issue
   * @param {string} userId - User ID for multi-tenancy
   * @param {string} issueId - Issue UUID
   * @returns {boolean} - True if deleted
   */
  async deleteIssue(userId, issueId) {
    const sql = 'DELETE FROM jira_issues WHERE id = $1 AND user_id = $2';
    const result = await query(sql, [issueId, userId]);
    return result.rowCount > 0;
  }

  /**
   * Delete all Jira issues for a user (for re-sync)
   * @param {string} userId - User ID for multi-tenancy
   * @returns {number} - Count of deleted issues
   */
  async deleteAllIssues(userId) {
    const sql = 'DELETE FROM jira_issues WHERE user_id = $1';
    const result = await query(sql, [userId]);
    return result.rowCount;
  }

  // ============================================
  // Team Member Mapping Operations
  // ============================================

  /**
   * List all Jira-to-team-member mappings
   * @param {string} userId - User ID for multi-tenancy
   * @returns {Array} - Array of mapping objects with team member details
   */
  async listMappings(userId) {
    const sql = `
      SELECT
        m.*,
        tm.name as team_member_name,
        tm.email as team_member_email
      FROM jira_team_mappings m
      LEFT JOIN team_members tm ON m.team_member_id = tm.id
      WHERE m.user_id = $1
      ORDER BY m.jira_assignee_name
    `;
    const result = await query(sql, [userId]);
    return result.rows;
  }

  /**
   * Create or update a Jira-to-team-member mapping
   * @param {string} userId - User ID for multi-tenancy
   * @param {string} jiraAssigneeId - Jira assignee ID
   * @param {string} jiraAssigneeName - Jira assignee display name
   * @param {string} teamMemberId - Team member UUID
   * @returns {Object} - Created/updated mapping
   */
  async createMapping(userId, jiraAssigneeId, jiraAssigneeName, teamMemberId) {
    const sql = `
      INSERT INTO jira_team_mappings (user_id, jira_assignee_id, jira_assignee_name, team_member_id)
      VALUES ($1, $2, $3, $4)
      ON CONFLICT (user_id, jira_assignee_id)
      DO UPDATE SET
        jira_assignee_name = EXCLUDED.jira_assignee_name,
        team_member_id = EXCLUDED.team_member_id,
        updated_date = CURRENT_TIMESTAMP
      RETURNING *
    `;
    const result = await query(sql, [userId, jiraAssigneeId, jiraAssigneeName, teamMemberId]);
    return result.rows[0];
  }

  /**
   * Delete a Jira-to-team-member mapping
   * @param {string} userId - User ID for multi-tenancy
   * @param {string} mappingId - Mapping UUID
   * @returns {boolean} - True if deleted
   */
  async deleteMapping(userId, mappingId) {
    const sql = 'DELETE FROM jira_team_mappings WHERE id = $1 AND user_id = $2';
    const result = await query(sql, [mappingId, userId]);
    return result.rowCount > 0;
  }

  // ============================================
  // Aggregation and Analytics
  // ============================================

  /**
   * Get team workload summary (issues grouped by assignee)
   * @param {string} userId - User ID for multi-tenancy
   * @returns {Array} - Array of assignee workload objects
   */
  async getTeamWorkload(userId) {
    const sql = `
      SELECT
        ji.assignee_id,
        ji.assignee_name,
        jtm.team_member_id,
        tm.name as team_member_name,
        COUNT(*) as issue_count,
        COALESCE(SUM(ji.story_points), 0) as total_points,
        COUNT(*) FILTER (WHERE ji.status NOT IN ('Done', 'Closed', 'Resolved')) as open_issues,
        COALESCE(SUM(ji.story_points) FILTER (WHERE ji.status NOT IN ('Done', 'Closed', 'Resolved')), 0) as open_points
      FROM jira_issues ji
      LEFT JOIN jira_team_mappings jtm ON ji.assignee_id = jtm.jira_assignee_id AND ji.user_id = jtm.user_id
      LEFT JOIN team_members tm ON jtm.team_member_id = tm.id
      WHERE ji.user_id = $1
      GROUP BY ji.assignee_id, ji.assignee_name, jtm.team_member_id, tm.name
      ORDER BY open_points DESC
    `;
    const result = await query(sql, [userId]);
    return result.rows;
  }

  /**
   * Get sync status (last sync time, issue count)
   * @param {string} userId - User ID for multi-tenancy
   * @returns {Object} - { lastSync, issueCount }
   */
  async getSyncStatus(userId) {
    const sql = `
      SELECT
        MAX(synced_at) as last_sync,
        COUNT(*) as issue_count
      FROM jira_issues
      WHERE user_id = $1
    `;
    const result = await query(sql, [userId]);
    return {
      lastSync: result.rows[0]?.last_sync || null,
      issueCount: parseInt(result.rows[0]?.issue_count || '0')
    };
  }

  /**
   * Get unmapped Jira assignees (assignees without team member links)
   * @param {string} userId - User ID for multi-tenancy
   * @returns {Array} - Array of { assignee_id, assignee_name, issue_count }
   */
  async getUnmappedAssignees(userId) {
    const sql = `
      SELECT
        ji.assignee_id,
        ji.assignee_name,
        COUNT(*) as issue_count
      FROM jira_issues ji
      LEFT JOIN jira_team_mappings jtm ON ji.assignee_id = jtm.jira_assignee_id AND ji.user_id = jtm.user_id
      WHERE ji.user_id = $1
        AND ji.assignee_id IS NOT NULL
        AND jtm.id IS NULL
      GROUP BY ji.assignee_id, ji.assignee_name
      ORDER BY issue_count DESC
    `;
    const result = await query(sql, [userId]);
    return result.rows;
  }
}

export default new JiraService();
```

**Key patterns to follow:**
- Import query from '../db/connection.js'
- Every method takes userId as first parameter (multi-tenancy)
- All SQL queries include user_id filter
- Use parameterized queries (NEVER string interpolation)
- Export singleton instance: `export default new JiraService();`
- Use ON CONFLICT for upsert with (xmax = 0) trick for insert detection
  </action>
  <verify>
```bash
# Check file exists and has expected exports
node -e "import('./server/services/JiraService.js').then(m => console.log('JiraService loaded:', typeof m.default.syncIssues))"
```
  </verify>
  <done>JiraService.js exists with syncIssues, listIssues, getIssue, deleteIssue, listMappings, createMapping, deleteMapping, getTeamWorkload methods</done>
</task>

<task type="auto">
  <name>Task 2: Verify service methods work correctly</name>
  <files>None (verification only)</files>
  <action>
Test JiraService methods work by importing and calling them with test data.

Create a quick test script or use Node REPL:
```javascript
// Test import works
import JiraService from './server/services/JiraService.js';

// Verify methods exist
console.log('Methods:', Object.getOwnPropertyNames(Object.getPrototypeOf(JiraService)));

// Test syncIssues with minimal data (will use dev-user-001)
const testIssues = [
  {
    issue_key: 'TEST-001',
    summary: 'Test issue',
    status: 'To Do',
    assignee_name: 'Test User',
    assignee_id: 'test-user-1',
    story_points: 3,
    priority: 'Medium',
    issue_type: 'Story',
    sprint_name: 'Sprint 1',
    epic_key: null,
    jira_url: 'https://jira.example.com/browse/TEST-001'
  }
];

const result = await JiraService.syncIssues('dev-user-001', testIssues);
console.log('Sync result:', result);
// Expected: { created: 1, updated: 0, total: 1 }

// Test listIssues
const issues = await JiraService.listIssues('dev-user-001');
console.log('Issues count:', issues.length);

// Cleanup test data
await JiraService.deleteAllIssues('dev-user-001');
```

Run with: `node --experimental-vm-modules` if needed for ES modules.

If database not running, at minimum verify:
1. File syntax is correct (no parse errors)
2. Import statement works
3. Methods exist on the service instance
  </action>
  <verify>Service can be imported without errors and all expected methods exist</verify>
  <done>JiraService can be imported, methods are callable, and basic operations work against database</done>
</task>

</tasks>

<verification>
1. File exists: `ls server/services/JiraService.js`
2. Import works: `node -e "import('./server/services/JiraService.js').then(() => console.log('OK'))"`
3. Methods exist: Check syncIssues, listIssues, getIssue, deleteIssue, listMappings, createMapping, deleteMapping, getTeamWorkload
4. Code review: All queries have user_id filter, all use parameterized queries
</verification>

<success_criteria>
- [ ] server/services/JiraService.js exists with class JiraService
- [ ] syncIssues(userId, issuesData) upserts issues and returns { created, updated, total }
- [ ] listIssues(userId, filters) returns issues with optional filtering
- [ ] getIssue(userId, issueId) returns single issue or null
- [ ] deleteIssue(userId, issueId) removes issue
- [ ] listMappings(userId) returns mappings with team member info
- [ ] createMapping(userId, jiraAssigneeId, jiraAssigneeName, teamMemberId) upserts mapping
- [ ] deleteMapping(userId, mappingId) removes mapping
- [ ] getTeamWorkload(userId) returns aggregated workload by assignee
- [ ] All queries filter by user_id (multi-tenancy enforced)
- [ ] Service exports singleton instance

**Requirements covered:** API-04 (JiraService implementation)
</success_criteria>

<output>
After completion, create `.planning/phases/01-backend-foundation/01-02-SUMMARY.md`
</output>
