---
phase: 23-database-backend-services
plan: 02
type: execute
wave: 2
depends_on: ["23-01"]
files_modified:
  - server/services/SyncItemService.js
  - server/services/SubtaskService.js
  - server/services/SyncSettingsService.js
autonomous: true

must_haves:
  truths:
    - "SyncItemService can list sync items with team/category filtering"
    - "SyncItemService can create sync items with initial status_history"
    - "SyncItemService can update sync items with change tracking in status_history JSONB"
    - "SyncItemService can archive and restore items with history logging"
    - "SubtaskService can CRUD subtasks with auto-incrementing display_order"
    - "SubtaskService can reorder subtasks atomically"
    - "SyncSettingsService can read user preferences or return defaults"
    - "SyncSettingsService can upsert user preferences"
    - "All services enforce multi-tenancy via user_id filtering"
  artifacts:
    - path: "server/services/SyncItemService.js"
      provides: "CRUD operations for sync items with status history tracking"
      exports: ["list", "create", "update", "delete", "archive", "restore", "getArchived", "getArchivedCount"]
    - path: "server/services/SubtaskService.js"
      provides: "CRUD and reorder operations for subtasks"
      exports: ["list", "create", "update", "delete", "reorder"]
    - path: "server/services/SyncSettingsService.js"
      provides: "User preferences for sync feature"
      exports: ["get", "update"]
  key_links:
    - from: "server/services/SyncItemService.js"
      to: "server/db/connection.js"
      via: "query function import"
      pattern: "import.*query.*from.*connection"
    - from: "server/services/SyncItemService.js"
      to: "projects table"
      via: "SQL queries with is_sync_item=true"
      pattern: "is_sync_item = true"
    - from: "server/services/SubtaskService.js"
      to: "tasks table"
      via: "SQL queries with is_subtask=true"
      pattern: "is_subtask = true"
    - from: "server/services/SyncSettingsService.js"
      to: "sync_settings table"
      via: "SQL queries"
      pattern: "FROM sync_settings"
---

<objective>
Implement three backend services for sync item management, subtask handling, and user settings.

Purpose: These services provide the business logic layer between the REST API (Phase 24) and the database schema (Plan 23-01). They enforce multi-tenancy, handle status history tracking, and manage subtask ordering.

Output: Three service classes following established patterns (TaskService, UserSettingsService)
</objective>

<execution_context>
@/Users/i306072/.claude/get-shit-done/workflows/execute-plan.md
@/Users/i306072/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/v1.6-ROADMAP.md
@.planning/v1.6-REQUIREMENTS.md
@.planning/phases/23-database-backend-services/23-RESEARCH.md
@.planning/phases/23-database-backend-services/23-01-SUMMARY.md

# Existing patterns to follow:
@server/services/TaskService.js
@server/services/ProjectService.js
@server/services/UserSettingsService.js
@server/db/connection.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SyncItemService.js</name>
  <files>server/services/SyncItemService.js</files>
  <action>
Create `server/services/SyncItemService.js` following the TaskService pattern with these methods:

**Import and class structure:**
```javascript
import { query, getClient } from '../db/connection.js';

class SyncItemService {
  // Methods here
}

export default new SyncItemService();
```

**Methods to implement:**

1. **list(userId, filters = {})** - SVC-01
   - Query projects WHERE is_sync_item=true AND user_id=$1 AND archived=$2 (default false)
   - Support filters: category, team_department
   - LEFT JOIN team_members to get assigned_to_name
   - ORDER BY display_order ASC, created_date DESC
   - Return array of sync items

2. **get(userId, syncItemId)** - Helper method
   - Query single project WHERE id=$1 AND user_id=$2 AND is_sync_item=true
   - Throw error if not found

3. **create(userId, syncItemData)** - SVC-02
   - INSERT into projects with is_sync_item=true
   - Initialize status_history with creation entry:
     ```json
     [{"timestamp": "...", "action": "created", "changedBy": userId}]
     ```
   - Required: name (mapped to projects.name)
   - Optional: description, category, sync_status, team_department, assigned_to_id, sprint_id, week_start_date
   - RETURNING *

4. **update(userId, syncItemId, updates)** - SVC-03
   - Get current item first (verify ownership)
   - Track status changes in status_history:
     ```json
     {"timestamp": "...", "field": "sync_status", "oldValue": "...", "newValue": "...", "changedBy": userId}
     ```
   - Build dynamic UPDATE query (TaskService pattern)
   - Allowed fields: name, description, category, sync_status, team_department, assigned_to_id, sprint_id, week_start_date, display_order
   - RETURNING *

5. **delete(userId, syncItemId)** - SVC-04
   - DELETE FROM projects WHERE id=$1 AND user_id=$2 AND is_sync_item=true
   - CASCADE will auto-delete subtasks
   - Return true on success

6. **archive(userId, syncItemId, reason = null)** - Part of SVC-03
   - Get current item, append to status_history:
     ```json
     {"timestamp": "...", "action": "archived", "reason": reason, "changedBy": userId}
     ```
   - UPDATE archived=true
   - RETURNING *

7. **restore(userId, syncItemId)** - SVC-07
   - Get current item, append to status_history:
     ```json
     {"timestamp": "...", "action": "restored", "changedBy": userId}
     ```
   - UPDATE archived=false
   - RETURNING *

8. **getArchived(userId, filters = {})** - SVC-05
   - Query projects WHERE is_sync_item=true AND archived=true AND user_id=$1
   - Support date filtering (from_date, to_date on updated_date)
   - ORDER BY updated_date DESC

9. **getArchivedCount(userId)** - SVC-06
   - SELECT COUNT(*) FROM projects WHERE user_id=$1 AND is_sync_item=true AND archived=true
   - Return integer

**Critical patterns to follow:**
- ALWAYS filter by user_id for multi-tenancy security
- Use parameterized queries ($1, $2) to prevent SQL injection
- Parse JSONB status_history before appending (handle string or object)
- Validate required fields before INSERT
- Use try/catch with meaningful error messages
  </action>
  <verify>File exists at server/services/SyncItemService.js with all 9 methods implemented</verify>
  <done>SyncItemService exports singleton with list, get, create, update, delete, archive, restore, getArchived, getArchivedCount methods</done>
</task>

<task type="auto">
  <name>Task 2: Create SubtaskService.js</name>
  <files>server/services/SubtaskService.js</files>
  <action>
Create `server/services/SubtaskService.js` with these methods:

**Import and class structure:**
```javascript
import { query, getClient } from '../db/connection.js';

class SubtaskService {
  // Methods here
}

export default new SubtaskService();
```

**Methods to implement:**

1. **list(userId, syncItemId)** - SVC-08
   - First verify sync item exists and user owns it
   - Query tasks WHERE project_id=$1 AND is_subtask=true AND user_id=$2
   - ORDER BY display_order ASC
   - Return array of subtasks

2. **create(userId, syncItemId, subtaskData)** - SVC-09
   - Verify sync item exists and user owns it
   - Get MAX(display_order) for this project_id, increment by 1
   - INSERT into tasks with:
     - user_id, project_id, is_subtask=true
     - title (required), completed (default false)
     - display_order (auto-calculated)
     - type='subtask', status=(completed ? 'done' : 'todo'), priority='medium'
   - RETURNING *

3. **update(userId, syncItemId, subtaskId, updates)** - SVC-10
   - Verify ownership: task WHERE id=$1 AND user_id=$2 AND project_id=$3 AND is_subtask=true
   - Allowed updates: title, completed
   - If completed changes, also update status (true='done', false='todo')
   - RETURNING *

4. **delete(userId, syncItemId, subtaskId)** - SVC-11
   - DELETE FROM tasks WHERE id=$1 AND user_id=$2 AND project_id=$3 AND is_subtask=true
   - Return true on success

5. **reorder(userId, syncItemId, orderedSubtaskIds)** - SVC-12
   - Use transaction (getClient, BEGIN, COMMIT/ROLLBACK)
   - Verify all IDs belong to user and sync item
   - Update display_order for each subtask (0, 1, 2, ...)
   - Return updated subtask list

**Pattern from research:**
```javascript
async reorder(userId, syncItemId, orderedSubtaskIds) {
  const client = await getClient();
  try {
    await client.query('BEGIN');

    // Verify ownership
    const existing = await client.query(
      'SELECT id FROM tasks WHERE user_id = $1 AND project_id = $2 AND is_subtask = true',
      [userId, syncItemId]
    );
    const existingIds = existing.rows.map(r => r.id);
    const invalid = orderedSubtaskIds.filter(id => !existingIds.includes(id));
    if (invalid.length > 0) {
      throw new Error('Invalid subtask IDs or access denied');
    }

    // Update display_order
    for (let i = 0; i < orderedSubtaskIds.length; i++) {
      await client.query(
        'UPDATE tasks SET display_order = $1 WHERE id = $2 AND user_id = $3',
        [i, orderedSubtaskIds[i], userId]
      );
    }

    await client.query('COMMIT');
    return this.list(userId, syncItemId);
  } catch (error) {
    await client.query('ROLLBACK');
    throw error;
  } finally {
    client.release();
  }
}
```

**Critical:**
- Always verify sync item ownership before subtask operations
- Multi-tenancy: user_id filter on all queries
- Transaction for reorder to ensure atomicity
  </action>
  <verify>File exists at server/services/SubtaskService.js with all 5 methods implemented</verify>
  <done>SubtaskService exports singleton with list, create, update, delete, reorder methods</done>
</task>

<task type="auto">
  <name>Task 3: Create SyncSettingsService.js</name>
  <files>server/services/SyncSettingsService.js</files>
  <action>
Create `server/services/SyncSettingsService.js` with these methods:

**Import and class structure:**
```javascript
import { query } from '../db/connection.js';

class SyncSettingsService {
  // Methods here
}

export default new SyncSettingsService();
```

**Methods to implement:**

1. **get(userId)** - SVC-13
   - Query sync_settings WHERE user_id=$1
   - If no row exists, return defaults:
     ```javascript
     {
       sprint_weeks: 2,
       default_view: 'sprint',
       default_team: null,
       settings_data: {}
     }
     ```
   - If row exists, return full row

2. **update(userId, settingsData)** - SVC-14
   - Use UPSERT pattern (INSERT ON CONFLICT DO UPDATE)
   - Extract known fields: sprint_weeks, default_view, default_team
   - Store remaining fields in settings_data JSONB
   - RETURNING *

**Pattern from UserSettingsService:**
```javascript
async update(userId, settingsData) {
  const {
    sprint_weeks = 2,
    default_view = 'sprint',
    default_team = null,
    ...rest
  } = settingsData;

  const sql = `
    INSERT INTO sync_settings (user_id, sprint_weeks, default_view, default_team, settings_data)
    VALUES ($1, $2, $3, $4, $5)
    ON CONFLICT (user_id)
    DO UPDATE SET
      sprint_weeks = $2,
      default_view = $3,
      default_team = $4,
      settings_data = $5,
      updated_date = CURRENT_TIMESTAMP
    RETURNING *
  `;

  const result = await query(sql, [
    userId,
    sprint_weeks,
    default_view,
    default_team,
    JSON.stringify(rest)
  ]);

  return result.rows[0];
}
```

**Simple service - only 2 methods needed.**
  </action>
  <verify>File exists at server/services/SyncSettingsService.js with get and update methods</verify>
  <done>SyncSettingsService exports singleton with get and update methods, using upsert pattern</done>
</task>

</tasks>

<verification>
1. All service files exist:
   - `ls server/services/SyncItemService.js`
   - `ls server/services/SubtaskService.js`
   - `ls server/services/SyncSettingsService.js`

2. Services export correctly:
   ```bash
   node -e "import('./server/services/SyncItemService.js').then(m => console.log(Object.keys(m.default)))"
   node -e "import('./server/services/SubtaskService.js').then(m => console.log(Object.keys(m.default)))"
   node -e "import('./server/services/SyncSettingsService.js').then(m => console.log(Object.keys(m.default)))"
   ```

3. Multi-tenancy enforced: grep for "user_id = \$" in all three files should show filtering

4. Manual test (if dev server running):
   - Import services and test basic operations against local database
</verification>

<success_criteria>
- [ ] SyncItemService.js exists with: list, get, create, update, delete, archive, restore, getArchived, getArchivedCount
- [ ] SubtaskService.js exists with: list, create, update, delete, reorder
- [ ] SyncSettingsService.js exists with: get, update
- [ ] All services import query from '../db/connection.js'
- [ ] All services export singleton instance (export default new ServiceName())
- [ ] All SQL queries include user_id filter for multi-tenancy
- [ ] All SQL queries use parameterized values ($1, $2, etc.)
- [ ] SyncItemService tracks changes in status_history JSONB
- [ ] SubtaskService reorder uses transaction (BEGIN/COMMIT/ROLLBACK)
- [ ] SyncSettingsService returns defaults when no settings exist
</success_criteria>

<output>
After completion, create `.planning/phases/23-database-backend-services/23-02-SUMMARY.md`
</output>
