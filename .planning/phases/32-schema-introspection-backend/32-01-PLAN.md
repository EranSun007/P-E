---
phase: 32-schema-introspection-backend
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - server/services/SchemaService.js
autonomous: true

must_haves:
  truths:
    - "SchemaService.getTables() returns all user tables excluding system tables"
    - "SchemaService.getColumns() returns column metadata with types and defaults"
    - "SchemaService.getForeignKeys() returns source/target relationship info"
    - "SchemaService.getIndexes() returns index definitions per table"
    - "SchemaService.getConstraints() returns PK/UNIQUE/CHECK constraints"
    - "SchemaService.getCompleteSchema() returns nested structure with all metadata"
  artifacts:
    - path: "server/services/SchemaService.js"
      provides: "PostgreSQL schema introspection service"
      exports: ["getTables", "getColumns", "getForeignKeys", "getIndexes", "getConstraints", "getCompleteSchema"]
  key_links:
    - from: "server/services/SchemaService.js"
      to: "server/db/connection.js"
      via: "query import for SQL execution"
      pattern: "import.*query.*from.*connection"
---

<objective>
Create SchemaService with methods to introspect PostgreSQL schema metadata.

Purpose: Provide backend data layer for Entity Model Viewer to visualize database structure.
Output: SchemaService.js with methods for tables, columns, foreign keys, indexes, and constraints.
</objective>

<execution_context>
@/Users/i306072/.claude/get-shit-done/workflows/execute-plan.md
@/Users/i306072/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/32-schema-introspection-backend/32-RESEARCH.md
@server/db/connection.js
@server/services/MenuConfigService.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SchemaService with information_schema queries</name>
  <files>server/services/SchemaService.js</files>
  <action>
Create SchemaService.js following existing service patterns (MenuConfigService, TaskService).

Import query from server/db/connection.js.

Implement these methods:

1. **getTables(excludeSystem = true)**
   - Query information_schema.tables for BASE TABLE types
   - Filter out pg_catalog, information_schema, and pg_% schemas when excludeSystem=true
   - Return array of { table_schema, table_name, table_type }

2. **getColumns(schemaName = null)**
   - Query information_schema.columns
   - Include: table_schema, table_name, column_name, ordinal_position, data_type, udt_name, is_nullable, column_default, character_maximum_length, numeric_precision, numeric_scale
   - Filter system schemas unless schemaName specified
   - Return array sorted by schema, table, ordinal_position

3. **getForeignKeys()**
   - Query information_schema.referential_constraints
   - JOIN with key_column_usage and constraint_column_usage
   - Return: constraint_name, source_schema, source_table, source_column, target_schema, target_table, target_column, update_rule, delete_rule
   - Filter system schemas

4. **getIndexes()**
   - Query pg_indexes view
   - Return: schemaname, tablename, indexname, indexdef
   - Filter system schemas

5. **getConstraints()**
   - Query information_schema.table_constraints
   - LEFT JOIN with key_column_usage for column names
   - Return: constraint_name, table_schema, table_name, constraint_type, column_name, is_deferrable, initially_deferred
   - Filter system schemas

Export as singleton: `export default new SchemaService();`
  </action>
  <verify>
File exists and exports default singleton instance.
Manual verification: `node -e "import s from './server/services/SchemaService.js'; console.log(typeof s.getTables)"`
  </verify>
  <done>
SchemaService.js exists with getTables, getColumns, getForeignKeys, getIndexes, getConstraints methods that execute SQL against information_schema views.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add getCompleteSchema with parallel fetching and grouping</name>
  <files>server/services/SchemaService.js</files>
  <action>
Add getCompleteSchema() method to SchemaService:

1. **Fetch all data in parallel using Promise.all:**
   ```javascript
   const [tables, columns, foreignKeys, indexes, constraints] = await Promise.all([
     this.getTables(),
     this.getColumns(),
     this.getForeignKeys(),
     this.getIndexes(),
     this.getConstraints()
   ]);
   ```

2. **Add groupByTable helper method:**
   - Parameters: (items, tableKey = 'table_name', schemaKey = 'table_schema')
   - Groups items by `${schemaKey}.${tableKey}` composite key
   - Returns object with keys like "public.tasks"

3. **Transform to nested structure:**
   - Group columns, indexes, constraints, foreignKeys by their respective table identifiers
   - Note: indexes use 'tablename'/'schemaname', foreignKeys use 'source_table'/'source_schema'
   - Build final structure:
   ```javascript
   {
     tables: [
       {
         schema: "public",
         name: "tasks",
         type: "BASE TABLE",
         columns: [...],
         indexes: [...],
         constraints: [...],
         foreignKeys: [...]
       }
     ]
   }
   ```

4. **Transform column/index response for friendlier keys:**
   - Convert snake_case keys from SQL to camelCase in response
   - For columns: columnName, ordinalPosition, dataType, udtName, isNullable, columnDefault, etc.
   - For indexes: schema, table, name, definition (from schemaname, tablename, indexname, indexdef)
   - For foreignKeys: sourceSchema, sourceTable, sourceColumn, targetSchema, targetTable, targetColumn, updateRule, deleteRule
   - For constraints: name, schema, table, type, columns (array), isDeferrable, initiallyDeferred
  </action>
  <verify>
Start server: `npm run dev:server`
Test in node REPL:
```javascript
const SchemaService = await import('./server/services/SchemaService.js');
const schema = await SchemaService.default.getCompleteSchema();
console.log(JSON.stringify(schema.tables.slice(0, 2), null, 2));
```
Verify: Response is nested object with tables array, each table has columns/indexes/constraints/foreignKeys arrays.
  </verify>
  <done>
getCompleteSchema() returns nested structure with all tables and their metadata. Response uses camelCase keys. System tables are excluded. All metadata fetched in parallel for performance.
  </done>
</task>

</tasks>

<verification>
1. SchemaService.js exists at server/services/SchemaService.js
2. Service exports singleton with all 6 methods
3. getTables() excludes pg_catalog, information_schema, pg_% by default
4. getCompleteSchema() returns nested structure with all tables
5. Each table in response has: schema, name, type, columns, indexes, constraints, foreignKeys
6. Response keys are camelCase (not snake_case from SQL)
</verification>

<success_criteria>
- SchemaService can introspect all tables in the database
- System tables (migrations, pg_*) are filtered out by default
- Foreign key relationships include source and target table info
- All metadata fetched in single getCompleteSchema() call using parallel queries
- Response structure matches RESEARCH.md nested pattern
</success_criteria>

<output>
After completion, create `.planning/phases/32-schema-introspection-backend/32-01-SUMMARY.md`
</output>
