---
phase: 26-item-modal-subtasks
plan: 02
type: execute
wave: 2
depends_on: ["26-01"]
files_modified:
  - package.json
  - src/components/sync/SubtaskSection.jsx
  - src/components/sync/SubtaskList.jsx
  - src/components/sync/SubtaskItem.jsx
  - src/components/sync/SyncItemModal.jsx
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Modal includes collapsible subtask management section"
    - "Subtask list shows checkboxes for completion toggle"
    - "Subtask list supports drag-and-drop reordering with visible grip handles"
    - "Inline input at bottom of subtask list allows adding new subtasks via Enter key"
  artifacts:
    - path: "src/components/sync/SubtaskSection.jsx"
      provides: "Accordion wrapper for subtask management"
      exports: ["SubtaskSection"]
      min_lines: 30
    - path: "src/components/sync/SubtaskList.jsx"
      provides: "Sortable subtask list with dnd-kit"
      exports: ["SubtaskList"]
      min_lines: 60
    - path: "src/components/sync/SubtaskItem.jsx"
      provides: "Individual draggable subtask row"
      exports: ["SubtaskItem"]
      min_lines: 40
    - path: "package.json"
      provides: "@dnd-kit packages installed"
      contains: "@dnd-kit/sortable"
  key_links:
    - from: "src/components/sync/SyncItemModal.jsx"
      to: "SubtaskSection"
      via: "import and render in edit mode"
      pattern: "SubtaskSection"
    - from: "src/components/sync/SubtaskList.jsx"
      to: "@dnd-kit/sortable"
      via: "DndContext and SortableContext"
      pattern: "DndContext"
    - from: "src/components/sync/SubtaskItem.jsx"
      to: "@dnd-kit/sortable"
      via: "useSortable hook"
      pattern: "useSortable"
---

<objective>
Add subtask management UI to SyncItemModal with drag-and-drop reordering capability.

Purpose: Enable users to manage subtasks within sync items - view list, toggle completion, add new subtasks, and reorder via drag-and-drop. Fulfills requirements UI-12 through UI-15.

Output: SubtaskSection, SubtaskList, and SubtaskItem components integrated into SyncItemModal with @dnd-kit for drag-and-drop.
</objective>

<execution_context>
@/Users/i306072/.claude/get-shit-done/workflows/execute-plan.md
@/Users/i306072/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/26-item-modal-subtasks/26-CONTEXT.md
@.planning/phases/26-item-modal-subtasks/26-RESEARCH.md

# Prior plan summary needed for modal integration
@.planning/phases/26-item-modal-subtasks/26-01-SUMMARY.md

@src/api/apiClient.js
@src/components/ui/accordion.jsx
@src/components/ui/checkbox.jsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install @dnd-kit packages</name>
  <files>package.json</files>
  <action>
Install @dnd-kit packages for drag-and-drop functionality:

```bash
npm install @dnd-kit/core @dnd-kit/sortable @dnd-kit/utilities
```

These packages provide:
- @dnd-kit/core: Foundation for drag-and-drop (DndContext, sensors)
- @dnd-kit/sortable: Sortable list preset (SortableContext, useSortable, arrayMove)
- @dnd-kit/utilities: CSS transform utilities for smooth drag animations
  </action>
  <verify>
Verify packages installed:
grep -E "@dnd-kit" package.json
  </verify>
  <done>
@dnd-kit/core, @dnd-kit/sortable, and @dnd-kit/utilities are in package.json dependencies.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create subtask components</name>
  <files>
    src/components/sync/SubtaskItem.jsx
    src/components/sync/SubtaskList.jsx
    src/components/sync/SubtaskSection.jsx
  </files>
  <action>
Create three subtask components following the patterns from RESEARCH.md:

**SubtaskItem.jsx - Individual draggable subtask row:**
```jsx
// src/components/sync/SubtaskItem.jsx
import { useSortable } from '@dnd-kit/sortable';
import { CSS } from '@dnd-kit/utilities';
import { Checkbox } from '@/components/ui/checkbox';
import { Button } from '@/components/ui/button';
import { GripVertical, Trash2 } from 'lucide-react';

export function SubtaskItem({ subtask, onToggle, onDelete }) {
  const {
    attributes,
    listeners,
    setNodeRef,
    transform,
    transition,
    isDragging
  } = useSortable({ id: subtask.id });

  const style = {
    transform: CSS.Transform.toString(transform),
    transition,
    opacity: isDragging ? 0.5 : 1,
  };

  return (
    <div
      ref={setNodeRef}
      style={style}
      className="flex items-center gap-2 p-2 bg-white border rounded hover:bg-gray-50"
    >
      <button
        {...attributes}
        {...listeners}
        className="cursor-grab touch-none text-gray-400 hover:text-gray-600"
        type="button"
      >
        <GripVertical className="h-4 w-4" />
      </button>
      <Checkbox
        checked={subtask.completed}
        onCheckedChange={() => onToggle(subtask.id)}
        id={`subtask-${subtask.id}`}
      />
      <label
        htmlFor={`subtask-${subtask.id}`}
        className="flex-1 text-sm cursor-pointer"
      >
        {subtask.title}
      </label>
      <Button
        variant="ghost"
        size="icon"
        className="h-6 w-6 text-gray-400 hover:text-red-500"
        onClick={() => onDelete(subtask.id)}
        type="button"
      >
        <Trash2 className="h-3 w-3" />
      </Button>
    </div>
  );
}
```

**SubtaskList.jsx - Sortable list with dnd-kit:**
```jsx
// src/components/sync/SubtaskList.jsx
import { useState } from 'react';
import {
  DndContext,
  closestCenter,
  KeyboardSensor,
  PointerSensor,
  useSensor,
  useSensors,
} from '@dnd-kit/core';
import {
  SortableContext,
  sortableKeyboardCoordinates,
  verticalListSortingStrategy,
  arrayMove,
} from '@dnd-kit/sortable';
import { SubtaskItem } from './SubtaskItem';
import { Input } from '@/components/ui/input';
import { Plus } from 'lucide-react';

export function SubtaskList({ subtasks, onToggle, onDelete, onReorder, onAdd }) {
  const [newSubtaskTitle, setNewSubtaskTitle] = useState('');

  const sensors = useSensors(
    useSensor(PointerSensor),
    useSensor(KeyboardSensor, {
      coordinateGetter: sortableKeyboardCoordinates,
    })
  );

  const handleDragEnd = (event) => {
    const { active, over } = event;
    if (active.id !== over?.id) {
      const oldIndex = subtasks.findIndex(s => s.id === active.id);
      const newIndex = subtasks.findIndex(s => s.id === over.id);
      const newOrder = arrayMove(subtasks, oldIndex, newIndex);
      onReorder(newOrder.map(s => s.id));
    }
  };

  const handleKeyDown = (e) => {
    if (e.key === 'Enter' && newSubtaskTitle.trim()) {
      e.preventDefault();
      onAdd(newSubtaskTitle.trim());
      setNewSubtaskTitle('');
    }
  };

  return (
    <div className="space-y-2">
      {subtasks.length > 0 ? (
        <DndContext
          sensors={sensors}
          collisionDetection={closestCenter}
          onDragEnd={handleDragEnd}
        >
          <SortableContext
            items={subtasks.map(s => s.id)}
            strategy={verticalListSortingStrategy}
          >
            <div className="space-y-1">
              {subtasks.map(subtask => (
                <SubtaskItem
                  key={subtask.id}
                  subtask={subtask}
                  onToggle={onToggle}
                  onDelete={onDelete}
                />
              ))}
            </div>
          </SortableContext>
        </DndContext>
      ) : (
        <p className="text-sm text-gray-500 py-2">No subtasks yet</p>
      )}

      {/* Add subtask input - always visible */}
      <div className="flex items-center gap-2 pt-2 border-t">
        <Plus className="h-4 w-4 text-gray-400 flex-shrink-0" />
        <Input
          value={newSubtaskTitle}
          onChange={(e) => setNewSubtaskTitle(e.target.value)}
          onKeyDown={handleKeyDown}
          placeholder="Add subtask and press Enter..."
          className="border-0 shadow-none focus-visible:ring-0 h-8"
        />
      </div>
    </div>
  );
}
```

**SubtaskSection.jsx - Accordion wrapper:**
```jsx
// src/components/sync/SubtaskSection.jsx
import { useState, useEffect, useCallback } from 'react';
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from '@/components/ui/accordion';
import { SubtaskList } from './SubtaskList';
import { SyncItem } from '@/api/entities';
import { ListChecks } from 'lucide-react';

export function SubtaskSection({ itemId, isNewItem }) {
  const [subtasks, setSubtasks] = useState([]);
  const [loading, setLoading] = useState(false);

  // Load subtasks when itemId changes
  useEffect(() => {
    if (itemId && !isNewItem) {
      loadSubtasks();
    } else {
      setSubtasks([]);
    }
  }, [itemId, isNewItem]);

  const loadSubtasks = async () => {
    try {
      setLoading(true);
      const data = await SyncItem.listSubtasks(itemId);
      setSubtasks(data || []);
    } catch (error) {
      console.error('Failed to load subtasks:', error);
      setSubtasks([]);
    } finally {
      setLoading(false);
    }
  };

  const handleToggle = useCallback(async (subtaskId) => {
    const subtask = subtasks.find(s => s.id === subtaskId);
    if (!subtask) return;

    // Optimistic update
    setSubtasks(prev =>
      prev.map(s => s.id === subtaskId ? { ...s, completed: !s.completed } : s)
    );

    try {
      await SyncItem.updateSubtask(itemId, subtaskId, {
        completed: !subtask.completed
      });
    } catch (error) {
      console.error('Failed to toggle subtask:', error);
      // Revert on error
      setSubtasks(prev =>
        prev.map(s => s.id === subtaskId ? { ...s, completed: subtask.completed } : s)
      );
    }
  }, [itemId, subtasks]);

  const handleDelete = useCallback(async (subtaskId) => {
    // Optimistic update
    const deletedSubtask = subtasks.find(s => s.id === subtaskId);
    setSubtasks(prev => prev.filter(s => s.id !== subtaskId));

    try {
      await SyncItem.deleteSubtask(itemId, subtaskId);
    } catch (error) {
      console.error('Failed to delete subtask:', error);
      // Revert on error
      if (deletedSubtask) {
        setSubtasks(prev => [...prev, deletedSubtask].sort((a, b) => a.sort_order - b.sort_order));
      }
    }
  }, [itemId, subtasks]);

  const handleReorder = useCallback(async (orderedIds) => {
    // Optimistic update - reorder local state
    const reorderedSubtasks = orderedIds.map((id, index) => {
      const subtask = subtasks.find(s => s.id === id);
      return { ...subtask, sort_order: index };
    });
    setSubtasks(reorderedSubtasks);

    try {
      await SyncItem.reorderSubtasks(itemId, orderedIds);
    } catch (error) {
      console.error('Failed to reorder subtasks:', error);
      // Reload on error to get correct order
      await loadSubtasks();
    }
  }, [itemId, subtasks]);

  const handleAdd = useCallback(async (title) => {
    try {
      const newSubtask = await SyncItem.createSubtask(itemId, { title });
      setSubtasks(prev => [...prev, newSubtask]);
    } catch (error) {
      console.error('Failed to add subtask:', error);
    }
  }, [itemId]);

  // Count completed subtasks
  const completedCount = subtasks.filter(s => s.completed).length;
  const totalCount = subtasks.length;

  // Don't show section for new items
  if (isNewItem) {
    return (
      <div className="text-sm text-gray-500 italic py-4 border-t">
        Save the item first to add subtasks
      </div>
    );
  }

  return (
    <Accordion type="single" collapsible defaultValue="subtasks" className="border-t">
      <AccordionItem value="subtasks" className="border-b-0">
        <AccordionTrigger className="py-3 hover:no-underline">
          <div className="flex items-center gap-2">
            <ListChecks className="h-4 w-4" />
            <span>Subtasks</span>
            {totalCount > 0 && (
              <span className="text-xs text-gray-500">
                ({completedCount}/{totalCount})
              </span>
            )}
          </div>
        </AccordionTrigger>
        <AccordionContent>
          {loading ? (
            <p className="text-sm text-gray-500 py-2">Loading...</p>
          ) : (
            <SubtaskList
              subtasks={subtasks}
              onToggle={handleToggle}
              onDelete={handleDelete}
              onReorder={handleReorder}
              onAdd={handleAdd}
            />
          )}
        </AccordionContent>
      </AccordionItem>
    </Accordion>
  );
}
```
  </action>
  <verify>
All files exist with correct exports:
grep -l "export" src/components/sync/SubtaskItem.jsx src/components/sync/SubtaskList.jsx src/components/sync/SubtaskSection.jsx
  </verify>
  <done>
SubtaskItem, SubtaskList, and SubtaskSection components created with drag-and-drop reordering, completion toggle, add input, and delete functionality.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate SubtaskSection into SyncItemModal</name>
  <files>src/components/sync/SyncItemModal.jsx</files>
  <action>
Update SyncItemModal.jsx to include SubtaskSection:

**Add Import:**
```jsx
import { SubtaskSection } from './SubtaskSection';
```

**Add SubtaskSection to modal body:**
After the form fields section (inside DialogContent, after the form but before DialogFooter), add:

```jsx
{/* Subtask Section - shown in both view and edit modes for existing items */}
<SubtaskSection
  itemId={item?.id}
  isNewItem={!item}
/>
```

The SubtaskSection:
- Shows "Save the item first to add subtasks" message for new items
- Shows collapsible accordion with subtask list for existing items
- Handles its own state and API calls (independent of form)
- Uses optimistic updates for toggle/delete/reorder

**Note:** SubtaskSection is displayed in both view and edit modes since subtask management is independent of the item form fields. Users can manage subtasks without entering edit mode for the main item fields.
  </action>
  <verify>
Build succeeds and SubtaskSection is imported:
npm run build:client 2>&1 | tail -20 && grep "SubtaskSection" src/components/sync/SyncItemModal.jsx
  </verify>
  <done>
SyncItemModal includes SubtaskSection with full subtask management: collapsible accordion, completion checkboxes, drag-and-drop reorder, add input, and delete.
  </done>
</task>

</tasks>

<verification>
1. Build succeeds: `npm run build:client` completes without errors
2. Packages installed: `grep "@dnd-kit" package.json` shows core, sortable, utilities
3. Subtask accordion: Open modal for existing item, see Subtasks accordion section
4. Completion toggle: Check/uncheck subtask checkbox, state updates
5. Add subtask: Type in input field, press Enter, new subtask appears
6. Drag reorder: Drag grip handle, drop in new position, order updates
7. Delete subtask: Click trash icon, subtask removed from list
</verification>

<success_criteria>
- UI-12: Modal includes subtask management section (accordion wrapper)
- UI-13: Subtask list shows checkboxes for completion toggle
- UI-14: Subtask list supports drag-and-drop reordering
- UI-15: Subtask input allows adding new subtasks
- @dnd-kit packages installed and functional
- Build passes without errors
</success_criteria>

<output>
After completion, create `.planning/phases/26-item-modal-subtasks/26-02-SUMMARY.md`
</output>
