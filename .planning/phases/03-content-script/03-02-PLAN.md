---
phase: 03-content-script
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - extension/content/content.js
  - extension/content/extractors/board.js
  - extension/content/extractors/backlog.js
  - extension/content/extractors/detail.js
autonomous: true

must_haves:
  truths:
    - "Sprint board view extracts issues with key, summary, status, assignee, points"
    - "Backlog view extracts items with sprint assignment and ranking"
    - "Issue detail page extracts full metadata including epic link"
    - "Extracted data syncs to backend within 60 seconds of page load"
    - "Empty extractions are handled gracefully without errors"
  artifacts:
    - path: "extension/content/extractors/board.js"
      provides: "Board view issue extraction"
      exports: ["extractBoardIssues"]
      min_lines: 60
    - path: "extension/content/extractors/backlog.js"
      provides: "Backlog view issue extraction"
      exports: ["extractBacklogIssues"]
      min_lines: 60
    - path: "extension/content/extractors/detail.js"
      provides: "Detail page issue extraction"
      exports: ["extractDetailIssue"]
      min_lines: 50
    - path: "extension/content/content.js"
      provides: "Updated entry point with extractors wired"
      contains: "extractBoardIssues"
      min_lines: 120
  key_links:
    - from: "extension/content/content.js"
      to: "extension/content/extractors/board.js"
      via: "extractors.board assignment"
      pattern: "extractBoardIssues"
    - from: "extension/content/content.js"
      to: "extension/service-worker.js"
      via: "chrome.runtime.sendMessage SYNC_ISSUES"
      pattern: "type:\\s*['\"]SYNC_ISSUES['\"]"
    - from: "extension/content/extractors/*.js"
      to: "backend API"
      via: "issue schema matching /api/jira-issues/sync"
      pattern: "issue_key.*summary.*status"
---

<objective>
Implement DOM extractors for Jira board, backlog, and detail pages that capture issue data and sync to backend.

Purpose: Enable automatic extraction of Jira issue data while users browse, fulfilling the core value proposition.
Output: Issues extracted from all three page types and synced to P&E Manager backend.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-content-script/03-RESEARCH.md
@.planning/phases/03-content-script/03-01-SUMMARY.md

# Phase 3 files from Plan 01
@extension/manifest.json
@extension/service-worker.js
@extension/content/content.js
@extension/content/utils.js
@extension/content/observer.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Inspect Jira DOM and create board extractor</name>
  <files>extension/content/extractors/board.js</files>
  <action>
CRITICAL: Jira DOM selectors are UNKNOWN. First step is live inspection.

1. Open jira.tools.sap board view in Chrome
2. Open DevTools (F12) -> Elements tab
3. Inspect the board structure and document:
   - Container element for entire board
   - Column containers (To Do, In Progress, Done, etc.)
   - Individual issue cards within columns
   - Where issue key appears (usually a link)
   - Where summary/title appears
   - Where assignee avatar/name appears
   - Where story points badge appears

4. Look for stable selectors (prefer in order):
   - data-testid or data-test-id attributes
   - role attributes (e.g., role="listitem")
   - aria-label attributes
   - Semantic elements (article, section)
   - Class names (less stable, use as fallback)

5. Create extension/content/extractors/board.js:

```javascript
// Board View Extractor
// Extracts issues from Jira sprint board columns

// SELECTORS - Update based on live DOM inspection
// These are placeholders - MUST be verified against actual Jira DOM
const BOARD_SELECTORS = {
  // Container that holds all columns
  boardContainer: '[data-test-id="software-board.board"]',
  // Individual issue cards
  issueCard: '[data-test-id="software-board.board-container.board.card-container"]',
  // Issue key link within card
  issueKey: '[data-test-id="software-board.board-container.board.card-container.card.key"]',
  // Issue summary text
  summary: '[data-test-id="software-board.board-container.board.card-container.card.summary"]',
  // Assignee element
  assignee: '[data-test-id="software-board.board-container.board.card-container.card.assignee"]',
  // Story points badge
  storyPoints: '[data-test-id="software-board.board-container.board.card-container.card.estimate"]',
  // Column header (for status)
  columnHeader: '[data-test-id="software-board.board-container.board.column-header"]'
};

// Fallback selectors if data-test-id not available
const FALLBACK_SELECTORS = {
  boardContainer: '#ghx-pool, .ghx-pool',
  issueCard: '.ghx-issue',
  issueKey: '.ghx-key',
  summary: '.ghx-summary',
  assignee: '.ghx-avatar',
  storyPoints: '.ghx-statistic-badge'
};

/**
 * Extract issues from sprint board view
 * @returns {Array} Array of issue objects
 */
function extractBoardIssues() {
  console.log('[PE-Jira] Extracting board issues');
  const issues = [];

  // Try primary selectors first, fall back if needed
  const cardSelector = document.querySelector(BOARD_SELECTORS.issueCard)
    ? BOARD_SELECTORS.issueCard
    : FALLBACK_SELECTORS.issueCard;

  const cards = document.querySelectorAll(cardSelector);
  console.log(`[PE-Jira] Found ${cards.length} issue cards`);

  cards.forEach((card, index) => {
    try {
      const issue = extractIssueFromCard(card);
      if (issue && issue.issue_key) {
        issues.push(issue);
      }
    } catch (error) {
      console.warn(`[PE-Jira] Failed to extract card ${index}:`, error.message);
    }
  });

  console.log(`[PE-Jira] Extracted ${issues.length} issues from board`);
  return issues;
}

/**
 * Extract issue data from a single card element
 */
function extractIssueFromCard(card) {
  // Issue key - usually in a link
  const keyEl = card.querySelector(BOARD_SELECTORS.issueKey) ||
                card.querySelector(FALLBACK_SELECTORS.issueKey) ||
                card.querySelector('a[href*="/browse/"]');
  const issueKey = extractText(keyEl) || extractKeyFromHref(keyEl);

  if (!issueKey) {
    return null; // Can't identify issue without key
  }

  // Summary
  const summaryEl = card.querySelector(BOARD_SELECTORS.summary) ||
                    card.querySelector(FALLBACK_SELECTORS.summary);
  const summary = extractText(summaryEl) || 'Untitled';

  // Status - from parent column or card data attribute
  const status = extractStatusFromCard(card);

  // Assignee
  const assigneeEl = card.querySelector(BOARD_SELECTORS.assignee) ||
                     card.querySelector(FALLBACK_SELECTORS.assignee);
  const assigneeName = extractAssigneeName(assigneeEl);

  // Story points
  const pointsEl = card.querySelector(BOARD_SELECTORS.storyPoints) ||
                   card.querySelector(FALLBACK_SELECTORS.storyPoints);
  const storyPoints = extractStoryPoints(pointsEl);

  return {
    issue_key: issueKey,
    summary: summary,
    status: status,
    assignee_name: assigneeName,
    story_points: storyPoints,
    jira_url: `https://jira.tools.sap/browse/${issueKey}`
  };
}

/**
 * Extract status from card's parent column
 */
function extractStatusFromCard(card) {
  // Try data attribute first
  const dataStatus = card.dataset?.status || card.getAttribute('data-issue-status');
  if (dataStatus) return dataStatus;

  // Try to find parent column header
  const column = card.closest('[data-test-id*="column"]') ||
                 card.closest('.ghx-column');
  if (column) {
    const header = column.querySelector(BOARD_SELECTORS.columnHeader) ||
                   column.querySelector('.ghx-column-header-name');
    if (header) return extractText(header);
  }

  return 'Unknown';
}

/**
 * Extract assignee name from avatar/assignee element
 */
function extractAssigneeName(el) {
  if (!el) return null;

  // Try aria-label (common for avatars)
  const ariaLabel = el.getAttribute('aria-label');
  if (ariaLabel) return ariaLabel.replace('Assignee:', '').trim();

  // Try title attribute
  const title = el.getAttribute('title');
  if (title) return title;

  // Try alt text on img
  const img = el.querySelector('img');
  if (img?.alt) return img.alt;

  return null;
}

/**
 * Extract story points from badge
 */
function extractStoryPoints(el) {
  if (!el) return null;

  const text = extractText(el);
  if (!text) return null;

  const num = parseFloat(text);
  return isNaN(num) ? null : num;
}

/**
 * Extract text content, trimmed
 */
function extractText(el) {
  return el?.textContent?.trim() || null;
}

/**
 * Extract issue key from href attribute
 */
function extractKeyFromHref(el) {
  if (!el) return null;
  const href = el.getAttribute('href');
  if (!href) return null;

  const match = href.match(/\/browse\/([A-Z]+-\d+)/);
  return match ? match[1] : null;
}

// Export for content.js (will be inlined during build/concatenation)
// For now, attach to window for content script access
window.extractBoardIssues = extractBoardIssues;
```

NOTE: After creating the file, actually inspect jira.tools.sap and UPDATE the selectors based on what you find. The selectors above are educated guesses based on common Jira patterns but WILL likely need adjustment.
  </action>
  <verify>
1. File extension/content/extractors/board.js exists
2. Selectors verified against live jira.tools.sap DOM
3. extractBoardIssues function returns array of issues
4. Test in DevTools console: copy function to console, run extractBoardIssues()
  </verify>
  <done>
Board extractor captures issues from sprint board columns.
Issue key, summary, status, assignee, and story points extracted.
Selectors verified against live Jira DOM.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create backlog and detail extractors</name>
  <files>
    extension/content/extractors/backlog.js
    extension/content/extractors/detail.js
  </files>
  <action>
1. Inspect jira.tools.sap backlog view (view=planning URL param)
2. Document the DOM structure for backlog items
3. Create extension/content/extractors/backlog.js:

```javascript
// Backlog View Extractor
// Extracts issues from Jira backlog planning view

// SELECTORS - Update based on live DOM inspection
const BACKLOG_SELECTORS = {
  // Sprint container
  sprintContainer: '[data-test-id="software-backlog.backlog-content.sprint-container"]',
  // Sprint header (for sprint name)
  sprintHeader: '[data-test-id="software-backlog.backlog-content.sprint-header"]',
  // Issue row in backlog
  issueRow: '[data-test-id="software-backlog.backlog-content.issue-row"]',
  // Issue key
  issueKey: '[data-test-id="software-backlog.backlog-content.issue-row.key"]',
  // Issue summary
  summary: '[data-test-id="software-backlog.backlog-content.issue-row.summary"]',
  // Backlog section (unassigned to sprint)
  backlogSection: '[data-test-id="software-backlog.backlog-content.backlog"]'
};

// Fallback selectors
const FALLBACK_SELECTORS = {
  sprintContainer: '.ghx-sprint-group',
  sprintHeader: '.ghx-sprint-header',
  issueRow: '.ghx-issue-content',
  issueKey: '.ghx-key',
  summary: '.ghx-summary'
};

/**
 * Extract issues from backlog view
 * @returns {Array} Array of issue objects with sprint assignment
 */
function extractBacklogIssues() {
  console.log('[PE-Jira] Extracting backlog issues');
  const issues = [];

  // Extract issues from each sprint section
  const sprintContainers = document.querySelectorAll(
    BACKLOG_SELECTORS.sprintContainer + ', ' + FALLBACK_SELECTORS.sprintContainer
  );

  sprintContainers.forEach(container => {
    const sprintName = extractSprintName(container);
    const sprintIssues = extractIssuesFromContainer(container, sprintName);
    issues.push(...sprintIssues);
  });

  // Extract from unassigned backlog
  const backlogSection = document.querySelector(
    BACKLOG_SELECTORS.backlogSection + ', .ghx-backlog-container'
  );
  if (backlogSection) {
    const backlogIssues = extractIssuesFromContainer(backlogSection, null);
    issues.push(...backlogIssues);
  }

  console.log(`[PE-Jira] Extracted ${issues.length} issues from backlog`);
  return issues;
}

/**
 * Extract sprint name from container header
 */
function extractSprintName(container) {
  const header = container.querySelector(
    BACKLOG_SELECTORS.sprintHeader + ', ' + FALLBACK_SELECTORS.sprintHeader
  );
  return header?.textContent?.trim()?.replace(/\s+/g, ' ') || null;
}

/**
 * Extract issues from a sprint/backlog container
 */
function extractIssuesFromContainer(container, sprintName) {
  const issues = [];
  const rows = container.querySelectorAll(
    BACKLOG_SELECTORS.issueRow + ', ' + FALLBACK_SELECTORS.issueRow
  );

  rows.forEach((row, index) => {
    try {
      const issue = extractIssueFromRow(row, sprintName, index);
      if (issue && issue.issue_key) {
        issues.push(issue);
      }
    } catch (error) {
      console.warn(`[PE-Jira] Failed to extract row:`, error.message);
    }
  });

  return issues;
}

/**
 * Extract issue data from backlog row
 */
function extractIssueFromRow(row, sprintName, rank) {
  // Issue key
  const keyEl = row.querySelector(BACKLOG_SELECTORS.issueKey) ||
                row.querySelector(FALLBACK_SELECTORS.issueKey) ||
                row.querySelector('a[href*="/browse/"]');
  const issueKey = keyEl?.textContent?.trim() || extractKeyFromHref(keyEl);

  if (!issueKey) return null;

  // Summary
  const summaryEl = row.querySelector(BACKLOG_SELECTORS.summary) ||
                    row.querySelector(FALLBACK_SELECTORS.summary);
  const summary = summaryEl?.textContent?.trim() || 'Untitled';

  // Status (if visible in backlog)
  const statusEl = row.querySelector('[data-test-id*="status"], .ghx-status');
  const status = statusEl?.textContent?.trim() || 'To Do';

  // Story points
  const pointsEl = row.querySelector('[data-test-id*="estimate"], .ghx-estimate');
  const storyPoints = pointsEl ? parseFloat(pointsEl.textContent) : null;

  // Assignee
  const assigneeEl = row.querySelector('[data-test-id*="assignee"], .ghx-avatar');
  const assigneeName = extractAssigneeName(assigneeEl);

  return {
    issue_key: issueKey,
    summary: summary,
    status: status,
    assignee_name: assigneeName,
    story_points: isNaN(storyPoints) ? null : storyPoints,
    sprint_name: sprintName,
    backlog_rank: rank,
    jira_url: `https://jira.tools.sap/browse/${issueKey}`
  };
}

function extractAssigneeName(el) {
  if (!el) return null;
  return el.getAttribute('aria-label')?.replace('Assignee:', '').trim() ||
         el.getAttribute('title') ||
         el.querySelector('img')?.alt ||
         null;
}

function extractKeyFromHref(el) {
  const href = el?.getAttribute('href');
  const match = href?.match(/\/browse\/([A-Z]+-\d+)/);
  return match ? match[1] : null;
}

window.extractBacklogIssues = extractBacklogIssues;
```

4. Inspect jira.tools.sap issue detail page (/browse/PROJ-123)
5. Create extension/content/extractors/detail.js:

```javascript
// Issue Detail Page Extractor
// Extracts full issue data from individual issue view

const DETAIL_SELECTORS = {
  issueKey: '[data-test-id="issue.views.issue-base.foundation.breadcrumbs.current-issue.item"]',
  summary: '[data-test-id="issue.views.issue-base.foundation.summary.heading"]',
  status: '[data-test-id="issue.views.issue-base.foundation.status.status-field-wrapper"]',
  assignee: '[data-test-id="issue.views.field.user.assignee"]',
  storyPoints: '[data-test-id="issue.views.field.number.story-points"]',
  priority: '[data-test-id="issue.views.field.priority.priority"]',
  issueType: '[data-test-id="issue.views.issue-base.foundation.issue-type.button"]',
  epicLink: '[data-test-id="issue.views.field.epic-link"]',
  sprint: '[data-test-id="issue.views.field.sprint"]'
};

// Fallback selectors for classic Jira view
const FALLBACK_SELECTORS = {
  issueKey: '#key-val',
  summary: '#summary-val',
  status: '#status-val',
  assignee: '#assignee-val',
  storyPoints: '#customfield_10106-val', // Story points field ID varies
  epicLink: '#customfield_10100-val'
};

/**
 * Extract issue data from detail page
 * @returns {Array} Single-element array with full issue data
 */
function extractDetailIssue() {
  console.log('[PE-Jira] Extracting from detail page');

  // Get issue key from URL as primary source
  const urlMatch = window.location.pathname.match(/\/browse\/([A-Z]+-\d+)/);
  const issueKey = urlMatch ? urlMatch[1] : extractFromSelector(DETAIL_SELECTORS.issueKey);

  if (!issueKey) {
    console.warn('[PE-Jira] Could not determine issue key');
    return [];
  }

  const issue = {
    issue_key: issueKey,
    summary: extractFromSelector(DETAIL_SELECTORS.summary, FALLBACK_SELECTORS.summary) || 'Untitled',
    status: extractFromSelector(DETAIL_SELECTORS.status, FALLBACK_SELECTORS.status) || 'Unknown',
    assignee_name: extractAssignee(),
    story_points: extractNumber(DETAIL_SELECTORS.storyPoints, FALLBACK_SELECTORS.storyPoints),
    priority: extractFromSelector(DETAIL_SELECTORS.priority),
    issue_type: extractFromSelector(DETAIL_SELECTORS.issueType),
    epic_key: extractEpicKey(),
    sprint_name: extractFromSelector(DETAIL_SELECTORS.sprint),
    jira_url: window.location.href.split('?')[0] // Clean URL
  };

  console.log('[PE-Jira] Extracted detail:', issue.issue_key);
  return [issue];
}

/**
 * Extract text from selector with fallback
 */
function extractFromSelector(primary, fallback) {
  const el = document.querySelector(primary) ||
             (fallback && document.querySelector(fallback));
  return el?.textContent?.trim() || null;
}

/**
 * Extract numeric value
 */
function extractNumber(primary, fallback) {
  const text = extractFromSelector(primary, fallback);
  if (!text) return null;
  const num = parseFloat(text);
  return isNaN(num) ? null : num;
}

/**
 * Extract assignee name
 */
function extractAssignee() {
  const el = document.querySelector(DETAIL_SELECTORS.assignee) ||
             document.querySelector(FALLBACK_SELECTORS.assignee);
  if (!el) return null;

  // Try various patterns for assignee display
  const name = el.getAttribute('aria-label') ||
               el.querySelector('[data-test-id*="name"]')?.textContent ||
               el.textContent;

  return name?.replace('Assignee:', '').trim() || null;
}

/**
 * Extract epic key from epic link field
 */
function extractEpicKey() {
  const el = document.querySelector(DETAIL_SELECTORS.epicLink) ||
             document.querySelector(FALLBACK_SELECTORS.epicLink);
  if (!el) return null;

  // Look for link to epic
  const link = el.querySelector('a[href*="/browse/"]');
  if (link) {
    const href = link.getAttribute('href');
    const match = href?.match(/\/browse\/([A-Z]+-\d+)/);
    return match ? match[1] : null;
  }

  // Try text content as fallback
  const text = el.textContent?.trim();
  const match = text?.match(/([A-Z]+-\d+)/);
  return match ? match[1] : null;
}

window.extractDetailIssue = extractDetailIssue;
```

IMPORTANT: After creating both files, inspect live Jira pages and update selectors to match actual DOM.
  </action>
  <verify>
1. extension/content/extractors/backlog.js exists and exports extractBacklogIssues
2. extension/content/extractors/detail.js exists and exports extractDetailIssue
3. Test each extractor in DevTools console on respective page types
4. Verify issue objects contain required fields (issue_key, summary, status)
  </verify>
  <done>
Backlog extractor captures issues with sprint assignment.
Detail extractor captures full metadata including epic link.
All extractors verified against live Jira DOM.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire extractors to content script and test full sync</name>
  <files>extension/content/content.js</files>
  <action>
Update extension/content/content.js to:

1. Since content scripts don't support ES modules, we need to concatenate or inline the extractor code. The simplest approach is to use a build-less IIFE pattern where all code is in one file, OR load extractors via script injection.

For simplicity, update content.js to inline extractor loading:

```javascript
// P&E Manager Jira Sync - Content Script
// Extracts issue data from Jira pages and syncs to backend

console.log('[PE-Jira] Content script loaded');

(function() {
  'use strict';

  // ============================================
  // Page Type Detection (from utils.js)
  // ============================================

  const PageType = {
    BOARD: 'board',
    BACKLOG: 'backlog',
    DETAIL: 'detail',
    UNKNOWN: 'unknown'
  };

  function detectPageType(url) {
    const urlObj = new URL(url);
    const path = urlObj.pathname;
    const params = urlObj.searchParams;

    if (path.includes('RapidBoard.jspa') && params.get('rapidView') && !params.get('view')) {
      return PageType.BOARD;
    }
    if (path.includes('RapidBoard.jspa') && params.get('view') === 'planning') {
      return PageType.BACKLOG;
    }
    if (path.includes('/browse/') && /[A-Z]+-\d+/.test(path)) {
      return PageType.DETAIL;
    }
    return PageType.UNKNOWN;
  }

  function debounce(fn, delay) {
    let timer = null;
    return function(...args) {
      clearTimeout(timer);
      timer = setTimeout(() => fn.apply(this, args), delay);
    };
  }

  async function waitForElement(selector, timeout = 10000) {
    const start = Date.now();
    while (Date.now() - start < timeout) {
      const el = document.querySelector(selector);
      if (el) return el;
      await new Promise(r => setTimeout(r, 100));
    }
    return null;
  }

  // ============================================
  // MutationObserver (from observer.js)
  // ============================================

  class ContentObserver {
    constructor(onContentReady) {
      this.onContentReady = onContentReady;
      this.observer = null;
      this.debounceTimer = null;
      this.DEBOUNCE_MS = 500;
    }

    observe(targetSelector) {
      const target = document.querySelector(targetSelector);
      if (!target) {
        console.log('[PE-Jira] Observer target not found:', targetSelector);
        return false;
      }

      this.observer = new MutationObserver(() => {
        clearTimeout(this.debounceTimer);
        this.debounceTimer = setTimeout(() => {
          this.onContentReady();
        }, this.DEBOUNCE_MS);
      });

      this.observer.observe(target, {
        childList: true,
        subtree: true,
        attributes: false
      });

      console.log('[PE-Jira] Observer attached to:', targetSelector);
      return true;
    }

    disconnect() {
      if (this.observer) {
        this.observer.disconnect();
        this.observer = null;
      }
      clearTimeout(this.debounceTimer);
    }
  }

  // ============================================
  // Extractors (inline or load from window)
  // ============================================

  // Load extractor scripts dynamically
  function loadExtractorScript(path) {
    return new Promise((resolve, reject) => {
      const script = document.createElement('script');
      script.src = chrome.runtime.getURL(path);
      script.onload = () => {
        script.remove();
        resolve();
      };
      script.onerror = reject;
      document.head.appendChild(script);
    });
  }

  // Extractor functions (populated after scripts load)
  const extractors = {
    [PageType.BOARD]: null,
    [PageType.BACKLOG]: null,
    [PageType.DETAIL]: null
  };

  // ============================================
  // Sync Logic
  // ============================================

  const SYNC_THROTTLE_MS = 30000; // 30 seconds per EXT-02
  let lastSyncTime = 0;
  let currentPageType = null;
  let observer = null;

  function shouldSync() {
    return (Date.now() - lastSyncTime) >= SYNC_THROTTLE_MS;
  }

  async function sendIssuesToServiceWorker(issues) {
    try {
      const response = await chrome.runtime.sendMessage({
        type: 'SYNC_ISSUES',
        payload: issues
      });

      if (response.success) {
        console.log('[PE-Jira] Sync successful:', response.data);
      } else {
        console.error('[PE-Jira] Sync failed:', response.error);
      }

      return response;
    } catch (error) {
      console.error('[PE-Jira] Message failed:', error);
      return { success: false, error: error.message };
    }
  }

  async function extractAndSync() {
    if (!currentPageType || currentPageType === PageType.UNKNOWN) {
      return;
    }

    const extractor = extractors[currentPageType];
    if (!extractor) {
      console.log('[PE-Jira] No extractor for:', currentPageType);
      return;
    }

    try {
      const issues = extractor();

      if (!issues || issues.length === 0) {
        console.log('[PE-Jira] No issues extracted');
        return;
      }

      console.log(`[PE-Jira] Extracted ${issues.length} issues`);

      if (!shouldSync()) {
        console.log('[PE-Jira] Sync throttled, skipping');
        return;
      }

      const result = await sendIssuesToServiceWorker(issues);
      if (result.success) {
        lastSyncTime = Date.now();
      }
    } catch (error) {
      console.error('[PE-Jira] Extraction error:', error);
    }
  }

  // ============================================
  // Container Selectors by Page Type
  // ============================================

  function getContainerSelector(pageType) {
    // These selectors identify the main content container to observe
    // Update based on actual Jira DOM
    switch (pageType) {
      case PageType.BOARD:
        return '#ghx-pool, [data-test-id="software-board.board"]';
      case PageType.BACKLOG:
        return '#ghx-backlog, [data-test-id="software-backlog.backlog-content"]';
      case PageType.DETAIL:
        return '#jira-issue-header, [data-test-id="issue.views.issue-base.foundation"]';
      default:
        return null;
    }
  }

  // ============================================
  // Initialization
  // ============================================

  async function init() {
    const pageType = detectPageType(window.location.href);
    console.log('[PE-Jira] Page type:', pageType);

    if (pageType === PageType.UNKNOWN) {
      console.log('[PE-Jira] Not a tracked page type');
      return;
    }

    currentPageType = pageType;

    // Load extractor script for this page type
    const extractorPath = {
      [PageType.BOARD]: 'content/extractors/board.js',
      [PageType.BACKLOG]: 'content/extractors/backlog.js',
      [PageType.DETAIL]: 'content/extractors/detail.js'
    }[pageType];

    try {
      await loadExtractorScript(extractorPath);
      console.log('[PE-Jira] Extractor loaded:', extractorPath);

      // Wire up extractor from window globals
      extractors[PageType.BOARD] = window.extractBoardIssues;
      extractors[PageType.BACKLOG] = window.extractBacklogIssues;
      extractors[PageType.DETAIL] = window.extractDetailIssue;
    } catch (error) {
      console.error('[PE-Jira] Failed to load extractor:', error);
      return;
    }

    // Wait for content container
    const containerSelector = getContainerSelector(pageType);
    console.log('[PE-Jira] Waiting for container:', containerSelector);

    const container = await waitForElement(containerSelector, 15000);
    if (!container) {
      console.error('[PE-Jira] Container not found after timeout');
      return;
    }

    console.log('[PE-Jira] Container found, starting extraction');

    // Initial extraction
    await extractAndSync();

    // Set up observer for dynamic content
    observer = new ContentObserver(debounce(() => {
      extractAndSync();
    }, 1000));
    observer.observe(containerSelector);
  }

  // ============================================
  // Message Handlers
  // ============================================

  chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
    if (message.type === 'URL_CHANGED') {
      console.log('[PE-Jira] URL changed:', message.url);

      if (observer) {
        observer.disconnect();
        observer = null;
      }

      init();
      sendResponse({ success: true });
    }

    if (message.type === 'REFRESH_DATA') {
      console.log('[PE-Jira] Manual refresh requested');
      lastSyncTime = 0; // Reset throttle
      extractAndSync();
      sendResponse({ success: true });
    }

    return true;
  });

  // ============================================
  // Start
  // ============================================

  init();

})();
```

2. Update manifest.json to allow loading extractor scripts as web_accessible_resources:

```json
"web_accessible_resources": [
  {
    "resources": ["content/extractors/*.js"],
    "matches": ["https://jira.tools.sap/*"]
  }
]
```

3. Ensure extractor files are loadable by moving them or updating paths.

4. Test the full flow:
   a. Load extension in Chrome
   b. Navigate to jira.tools.sap board
   c. Check DevTools console for extraction logs
   d. Verify issues synced to backend (check service worker console)
   e. Navigate to backlog view - verify re-extraction
   f. Open issue detail - verify extraction
  </action>
  <verify>
1. content.js loads extractors dynamically
2. Board extraction works - issues synced to backend
3. Backlog extraction works - includes sprint assignment
4. Detail extraction works - includes epic link
5. SPA navigation triggers re-extraction
6. Sync throttle prevents duplicate syncs within 30s
  </verify>
  <done>
All extractors wired and functional.
Issues extracted from board, backlog, and detail pages.
Automatic sync to backend within 60 seconds of page load.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Navigate to Jira board - issues extracted and synced
2. Navigate to backlog - issues with sprint info extracted
3. Open issue detail - full metadata extracted
4. Check backend API - synced issues visible via GET /api/jira-issues
5. Rapid navigation doesn't cause duplicate syncs (30s throttle)
6. DOM changes (drag card to new column) trigger re-extraction
</verification>

<success_criteria>
- Sprint board view extracts issues with key, summary, status, assignee, points (REQ EXT-04, EXT-07)
- Backlog view extracts items with sprint assignment (REQ EXT-05)
- Issue detail pages provide fallback data extraction (REQ EXT-06)
- Extracted data automatically syncs to backend within 60 seconds (REQ EXT-02)
- All three page types functioning in live Jira environment
</success_criteria>

<output>
After completion, create `.planning/phases/03-content-script/03-02-SUMMARY.md`
</output>
