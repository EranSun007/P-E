---
phase: 25-frontend-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/api/apiClient.js
  - src/api/entities.js
  - src/contexts/SyncContext.jsx
  - src/main.jsx
autonomous: true
user_setup: []

must_haves:
  truths:
    - "SyncContext provides sync items state via useSync hook"
    - "SyncContext provides itemsByCategory computed grouping"
    - "SyncContext provides currentTeam state for department filtering"
    - "SyncContext provides archivedItems and archivedCount state"
    - "Constants TEAM_DEPARTMENTS, CATEGORIES, SYNC_STATUSES are exported"
    - "SyncItem API client wraps all /api/sync endpoints"
  artifacts:
    - path: "src/contexts/SyncContext.jsx"
      provides: "Sync state management context"
      exports: ["SyncProvider", "useSync", "TEAM_DEPARTMENTS", "CATEGORIES", "SYNC_STATUSES"]
    - path: "src/api/apiClient.js"
      provides: "createSyncItemClient with subtask operations"
      contains: "createSyncItemClient"
    - path: "src/api/entities.js"
      provides: "SyncItem and SyncSettings exports"
      contains: "export const SyncItem"
  key_links:
    - from: "src/contexts/SyncContext.jsx"
      to: "src/api/entities.js"
      via: "import { SyncItem } from"
      pattern: "import.*SyncItem.*from.*entities"
    - from: "src/main.jsx"
      to: "src/contexts/SyncContext.jsx"
      via: "SyncProvider wrapping"
      pattern: "<SyncProvider>"
---

<objective>
Create SyncContext for managing TeamSync state and extend API client for sync endpoints.

Purpose: Provides React state management for sync items with CRUD operations, computed groupings by category, team department filtering, and archived items tracking. This is the data foundation for the TeamSync UI.

Output: SyncContext.jsx with full state management, extended apiClient.js with sync operations, and entities.js exports.
</objective>

<execution_context>
@/Users/i306072/.claude/get-shit-done/workflows/execute-plan.md
@/Users/i306072/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25-frontend-foundation/25-RESEARCH.md

# Existing patterns to follow
@src/contexts/NotificationContext.jsx
@src/api/apiClient.js
@src/api/entities.js
@src/main.jsx

# Backend API contract (Phase 24)
@server/routes/sync.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend apiClient.js with sync operations</name>
  <files>src/api/apiClient.js</files>
  <action>
Add createSyncItemClient() function following createDevOpsDutyClient() pattern. Include:

1. Base CRUD operations from createEntityClient('/sync')
2. Custom list() with filter params (category, teamDepartment, archived)
3. Archive operations: getArchived(filters), getArchivedCount(), restore(id)
4. Subtask operations: listSubtasks(itemId), createSubtask(itemId, data), updateSubtask(itemId, subtaskId, updates), deleteSubtask(itemId, subtaskId), reorderSubtasks(itemId, orderedSubtaskIds)

Add createSyncSettingsClient() with get() and update() methods.

Add to apiClient.entities:
- SyncItem: createSyncItemClient()

Add apiClient.sync namespace:
- settings: createSyncSettingsClient()

Use URLSearchParams for query param building. Map camelCase params to query string.
  </action>
  <verify>
Verify apiClient exports sync clients:
```bash
grep -n "SyncItem" src/api/apiClient.js
grep -n "createSyncItemClient" src/api/apiClient.js
grep -n "sync:" src/api/apiClient.js
```
  </verify>
  <done>
apiClient.entities.SyncItem provides list/get/create/update/delete/getArchived/getArchivedCount/restore and subtask operations.
apiClient.sync.settings provides get/update.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add SyncItem and SyncSettings exports to entities.js</name>
  <files>src/api/entities.js</files>
  <action>
Add exports for sync entities following existing pattern:

```javascript
// TeamSync Integration (v1.6)
export const SyncItem = USE_API ? apiClient.entities.SyncItem : {
  list: async () => { throw new Error('Sync not available in local mode'); },
  get: async () => { throw new Error('Sync not available in local mode'); },
  create: async () => { throw new Error('Sync not available in local mode'); },
  update: async () => { throw new Error('Sync not available in local mode'); },
  delete: async () => { throw new Error('Sync not available in local mode'); },
  getArchived: async () => { throw new Error('Sync not available in local mode'); },
  getArchivedCount: async () => { throw new Error('Sync not available in local mode'); },
  restore: async () => { throw new Error('Sync not available in local mode'); },
  listSubtasks: async () => { throw new Error('Sync not available in local mode'); },
  createSubtask: async () => { throw new Error('Sync not available in local mode'); },
  updateSubtask: async () => { throw new Error('Sync not available in local mode'); },
  deleteSubtask: async () => { throw new Error('Sync not available in local mode'); },
  reorderSubtasks: async () => { throw new Error('Sync not available in local mode'); },
};

export const SyncSettings = USE_API ? apiClient.sync.settings : {
  get: async () => { throw new Error('Sync settings not available in local mode'); },
  update: async () => { throw new Error('Sync settings not available in local mode'); },
};
```

Position after existing entity exports (after User export).
  </action>
  <verify>
Verify exports:
```bash
grep -n "SyncItem" src/api/entities.js
grep -n "SyncSettings" src/api/entities.js
```
  </verify>
  <done>
SyncItem and SyncSettings are exported from entities.js with proper local mode fallbacks.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create SyncContext.jsx with full state management</name>
  <files>src/contexts/SyncContext.jsx</files>
  <action>
Create SyncContext.jsx following NotificationContext.jsx pattern:

1. Export constants at top of file (CTX-05):
```javascript
export const TEAM_DEPARTMENTS = [
  { id: 'all', label: 'All Teams' },
  { id: 'metering', label: 'Metering' },
  { id: 'reporting', label: 'Reporting' },
];

export const CATEGORIES = [
  { id: 'goal', label: 'Goals' },
  { id: 'blocker', label: 'Blockers' },
  { id: 'dependency', label: 'Dependencies' },
  { id: 'emphasis', label: 'Emphasis' },
];

export const SYNC_STATUSES = [
  { id: 'not_started', label: 'Not Started' },
  { id: 'in_progress', label: 'In Progress' },
  { id: 'blocked', label: 'Blocked' },
  { id: 'done', label: 'Done' },
];
```

2. SyncProvider component with state (CTX-01, CTX-03, CTX-04):
- items: array of sync items (non-archived)
- currentTeam: 'all' | 'metering' | 'reporting'
- archivedItems: array (lazy-loaded)
- archivedCount: number
- loading: boolean

3. Computed values with useMemo (CTX-02):
- itemsByCategory: object grouping items by category field

4. CRUD operations with useCallback:
- refresh(): Fetch items with currentTeam filter, parallel fetch archivedCount
- createItem(data): Create new sync item, refresh
- updateItem(id, updates): Update sync item with optimistic update
- deleteItem(id): Delete sync item with optimistic update
- archiveItem(id): Set archived=true via update
- restoreItem(id): Call restore endpoint
- setCurrentTeam(team): Update currentTeam and trigger refresh
- loadArchivedItems(filters): Lazy-load archived items

5. Include currentTeam in refresh useCallback dependencies (avoid stale closure pitfall).

6. Default items to empty array to prevent undefined.map() errors.

7. Export useSync hook with context check.
  </action>
  <verify>
Verify context structure:
```bash
grep -n "export const TEAM_DEPARTMENTS" src/contexts/SyncContext.jsx
grep -n "export const CATEGORIES" src/contexts/SyncContext.jsx
grep -n "itemsByCategory" src/contexts/SyncContext.jsx
grep -n "export function useSync" src/contexts/SyncContext.jsx
```
  </verify>
  <done>
SyncContext.jsx exports SyncProvider, useSync hook, and constants (TEAM_DEPARTMENTS, CATEGORIES, SYNC_STATUSES). Provider manages items, currentTeam, archivedItems, archivedCount state with full CRUD operations.
  </done>
</task>

<task type="auto">
  <name>Task 4: Add SyncProvider to main.jsx</name>
  <files>src/main.jsx</files>
  <action>
Add SyncProvider inside the provider tree. Position AFTER NotificationProvider (it depends on auth) and BEFORE AppModeProvider.

1. Add import:
```javascript
import { SyncProvider } from '@/contexts/SyncContext.jsx'
```

2. Wrap existing tree:
```jsx
<AuthProvider>
  <NotificationProvider>
    <SyncProvider>
      <AppModeProvider>
        ...
      </AppModeProvider>
    </SyncProvider>
  </NotificationProvider>
</AuthProvider>
```

This ensures SyncContext can access useAuth (via AuthProvider parent).
  </action>
  <verify>
Verify provider is added:
```bash
grep -n "SyncProvider" src/main.jsx
grep -A2 "NotificationProvider" src/main.jsx
```
  </verify>
  <done>
SyncProvider is added to main.jsx provider tree, positioned inside NotificationProvider.
  </done>
</task>

</tasks>

<verification>
1. API client exports sync operations:
   ```bash
   grep "SyncItem\|createSyncItemClient" src/api/apiClient.js
   ```

2. Entities export sync types:
   ```bash
   grep "export const Sync" src/api/entities.js
   ```

3. SyncContext exists with exports:
   ```bash
   grep "export" src/contexts/SyncContext.jsx | head -10
   ```

4. Provider added to main.jsx:
   ```bash
   grep "SyncProvider" src/main.jsx
   ```

5. App builds without errors:
   ```bash
   cd /Users/i306072/Documents/GitHub/P-E && npm run build:client 2>&1 | tail -20
   ```
</verification>

<success_criteria>
- CTX-01: SyncContext provides sync items state via useSync hook
- CTX-02: SyncContext provides itemsByCategory computed grouping
- CTX-03: SyncContext provides currentTeam state for department filtering
- CTX-04: SyncContext provides archivedItems and archivedCount state
- CTX-05: Constants TEAM_DEPARTMENTS, CATEGORIES, SYNC_STATUSES exported from SyncContext
- CTX-06: API client wraps all /api/sync endpoints
- Frontend builds successfully with no type errors
</success_criteria>

<output>
After completion, create `.planning/phases/25-frontend-foundation/25-01-SUMMARY.md`
</output>
