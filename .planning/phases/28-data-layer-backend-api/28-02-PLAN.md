---
phase: 28-data-layer-backend-api
plan: 02
type: execute
wave: 2
depends_on: ["28-01"]
files_modified:
  - src/contexts/NavigationContext.jsx
  - src/api/apiClient.js
  - src/App.jsx
autonomous: true

must_haves:
  truths:
    - "NavigationContext provides menu config state to consuming components"
    - "useNavigation hook returns config for current mode"
    - "Config loads from backend on authentication"
    - "Config updates save to backend automatically"
  artifacts:
    - path: "src/contexts/NavigationContext.jsx"
      provides: "Navigation state management"
      exports: ["NavigationProvider", "useNavigation"]
    - path: "src/api/apiClient.js"
      provides: "menuConfig API client methods"
      contains: "menuConfig:"
  key_links:
    - from: "src/contexts/NavigationContext.jsx"
      to: "/api/menu-config"
      via: "apiClient.menuConfig methods"
      pattern: "apiClient\\.menuConfig\\.(get|set)"
    - from: "src/App.jsx"
      to: "src/contexts/NavigationContext.jsx"
      via: "NavigationProvider wrapper"
      pattern: "<NavigationProvider>"
---

<objective>
Create NavigationContext for frontend menu configuration state management.

Purpose: Provide centralized state for menu folder configuration that syncs with backend, enabling Layout.jsx and Settings.jsx to access and modify the menu structure.

Output: NavigationContext.jsx with useNavigation hook, integrated with apiClient and App.jsx
</objective>

<execution_context>
@/Users/i306072/.claude/get-shit-done/workflows/execute-plan.md
@/Users/i306072/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/SUMMARY.md
@.planning/phases/28-data-layer-backend-api/28-01-SUMMARY.md
@src/contexts/AppModeContext.jsx
@src/contexts/SyncContext.jsx
@src/api/apiClient.js
@src/App.jsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add menuConfig to apiClient</name>
  <files>src/api/apiClient.js</files>
  <action>
Add menuConfig API client methods to apiClient.js:

Find the existing userSettings object in the file and add a new menuConfig object nearby (before the final export):

```javascript
// Menu Configuration API
menuConfig: {
  async get(mode) {
    // mode is 'people' or 'product'
    return fetchWithAuth(`${API_BASE_URL}/menu-config/${mode}`);
  },

  async set(mode, config) {
    // mode is 'people' or 'product'
    // config is { folders: [], items: [] }
    return fetchWithAuth(`${API_BASE_URL}/menu-config/${mode}`, {
      method: 'PUT',
      body: JSON.stringify(config),
    });
  },

  async getDefaults(mode) {
    return fetchWithAuth(`${API_BASE_URL}/menu-config/${mode}/defaults`);
  },
},
```

This follows the same pattern as userSettings API methods.
  </action>
  <verify>
1. File compiles without syntax errors
2. apiClient.menuConfig.get, apiClient.menuConfig.set, apiClient.menuConfig.getDefaults methods exist
  </verify>
  <done>
apiClient has menuConfig methods for GET/PUT operations against /api/menu-config endpoints.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create NavigationContext</name>
  <files>src/contexts/NavigationContext.jsx</files>
  <action>
Create NavigationContext.jsx following AppModeContext and SyncContext patterns:

```javascript
/**
 * Navigation Context
 * Manages menu configuration state for folder grouping
 * Supports separate configs for People and Product modes
 */

import { createContext, useContext, useState, useEffect, useCallback } from 'react';
import { useAuth } from '@/contexts/AuthContext';
import { useAppMode } from '@/contexts/AppModeContext';
import apiClient from '@/api/apiClient';

const NavigationContext = createContext(null);

// Default configs (match backend defaults)
const DEFAULT_CONFIG = { folders: [], items: [] };

export function NavigationProvider({ children }) {
  const { isAuthenticated } = useAuth();
  const { isProductMode } = useAppMode();

  // Separate state for each mode
  const [peopleConfig, setPeopleConfig] = useState(DEFAULT_CONFIG);
  const [productConfig, setProductConfig] = useState(DEFAULT_CONFIG);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // Current mode's config
  const currentConfig = isProductMode ? productConfig : peopleConfig;
  const setCurrentConfig = isProductMode ? setProductConfig : setPeopleConfig;
  const currentMode = isProductMode ? 'product' : 'people';

  // Load config from backend
  const loadConfig = useCallback(async (mode) => {
    try {
      const response = await apiClient.menuConfig.get(mode);
      return response.config;
    } catch (err) {
      console.error(`Failed to load ${mode} menu config:`, err);
      return DEFAULT_CONFIG;
    }
  }, []);

  // Load both configs on auth
  useEffect(() => {
    if (!isAuthenticated) {
      setPeopleConfig(DEFAULT_CONFIG);
      setProductConfig(DEFAULT_CONFIG);
      setLoading(false);
      return;
    }

    const loadBothConfigs = async () => {
      setLoading(true);
      setError(null);
      try {
        const [people, product] = await Promise.all([
          loadConfig('people'),
          loadConfig('product'),
        ]);
        setPeopleConfig(people);
        setProductConfig(product);
      } catch (err) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    };

    loadBothConfigs();
  }, [isAuthenticated, loadConfig]);

  // Save config to backend (debounced internally if needed)
  const saveConfig = useCallback(async (config) => {
    try {
      await apiClient.menuConfig.set(currentMode, config);
      setCurrentConfig(config);
      return true;
    } catch (err) {
      console.error(`Failed to save ${currentMode} menu config:`, err);
      setError(err.message);
      return false;
    }
  }, [currentMode, setCurrentConfig]);

  // Reset to defaults
  const resetToDefaults = useCallback(async () => {
    try {
      const response = await apiClient.menuConfig.getDefaults(currentMode);
      await apiClient.menuConfig.set(currentMode, response.config);
      setCurrentConfig(response.config);
      return true;
    } catch (err) {
      console.error(`Failed to reset ${currentMode} menu config:`, err);
      setError(err.message);
      return false;
    }
  }, [currentMode, setCurrentConfig]);

  // Refresh current mode's config from backend
  const refresh = useCallback(async () => {
    const config = await loadConfig(currentMode);
    setCurrentConfig(config);
  }, [currentMode, setCurrentConfig, loadConfig]);

  const value = {
    // Current mode's config
    config: currentConfig,
    folders: currentConfig.folders,
    items: currentConfig.items,

    // State
    loading,
    error,

    // Actions
    saveConfig,
    resetToDefaults,
    refresh,

    // Mode info
    currentMode,
  };

  return (
    <NavigationContext.Provider value={value}>
      {children}
    </NavigationContext.Provider>
  );
}

export function useNavigation() {
  const context = useContext(NavigationContext);
  if (!context) {
    throw new Error('useNavigation must be used within a NavigationProvider');
  }
  return context;
}

export default NavigationContext;
```

Key design decisions:
- Loads BOTH configs on auth (avoids re-fetch on mode switch)
- Uses AppModeContext to determine current mode
- saveConfig updates backend AND local state optimistically
- resetToDefaults fetches and applies default from backend
- Error state exposed for UI feedback
  </action>
  <verify>
File exists with NavigationProvider component and useNavigation hook exported.
  </verify>
  <done>
NavigationContext provides config state, saveConfig, resetToDefaults, and refresh methods.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire NavigationProvider into App</name>
  <files>src/App.jsx</files>
  <action>
Add NavigationProvider to App.jsx provider hierarchy:

1. Import NavigationProvider:
   import { NavigationProvider } from '@/contexts/NavigationContext';

2. Find the provider tree (look for AppModeProvider, AuthProvider, etc.)

3. Add NavigationProvider INSIDE AppModeProvider but wrapping the rest:
   - NavigationProvider depends on useAppMode, so must be inside AppModeProvider
   - NavigationProvider depends on useAuth, so must be inside AuthProvider

   Provider order should be:
   ```jsx
   <AuthProvider>
     <AppModeProvider>
       <NavigationProvider>
         <AppContext.Provider>
           {/* rest of app */}
         </AppContext.Provider>
       </NavigationProvider>
     </AppModeProvider>
   </AuthProvider>
   ```

   Or if using different structure, ensure NavigationProvider is:
   - Inside AuthProvider (needs isAuthenticated)
   - Inside AppModeProvider (needs isProductMode)
   - Outside components that will consume useNavigation

Note: Examine existing App.jsx structure and place accordingly. The key constraint is NavigationProvider must be inside AuthProvider and AppModeProvider.
  </action>
  <verify>
1. npm run dev:client starts without errors
2. No "useNavigation must be used within a NavigationProvider" errors
3. React DevTools shows NavigationProvider in component tree
  </verify>
  <done>
NavigationProvider wraps app components, making useNavigation available throughout.
  </done>
</task>

</tasks>

<verification>
1. Frontend starts without errors: `npm run dev:client`
2. NavigationContext loads config on authentication
3. useNavigation hook returns { config, folders, items, loading, error, saveConfig, resetToDefaults, refresh }
4. Switching People/Product modes changes currentConfig appropriately
5. saveConfig persists to backend (verify via curl or Network tab)
6. Config persists across page reload (loaded from backend)
</verification>

<success_criteria>
- NavigationContext.jsx exists with NavigationProvider and useNavigation exports
- apiClient.menuConfig has get, set, getDefaults methods
- NavigationProvider is wired into App.jsx provider tree
- useNavigation provides config for current mode
- Configs load from backend on auth
- saveConfig updates backend and local state
- Settings.jsx and Layout.jsx can consume useNavigation (verified by hook availability)
</success_criteria>

<output>
After completion, create `.planning/phases/28-data-layer-backend-api/28-02-SUMMARY.md`
</output>
