---
phase: 15-threshold-notifications
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - server/db/020_notification_types.sql
  - server/db/migrate.js
  - server/services/ThresholdService.js
  - server/services/NotificationService.js
  - server/routes/notifications.js
  - server/routes/bugs.js
autonomous: true

must_haves:
  truths:
    - "System detects when KPI crosses into red zone during CSV upload"
    - "System creates notification record when threshold breached"
    - "System deduplicates notifications within 24-hour window"
    - "Unread notification count can be retrieved via API"
  artifacts:
    - path: "server/services/ThresholdService.js"
      provides: "KPI threshold evaluation and notification creation logic"
      exports: ["ThresholdService"]
    - path: "server/db/020_notification_types.sql"
      provides: "Migration adding notification_type and metadata columns"
      contains: "ADD COLUMN"
    - path: "server/routes/notifications.js"
      provides: "Extended with /unread-count endpoint"
      contains: "/unread-count"
  key_links:
    - from: "server/routes/bugs.js"
      to: "server/services/ThresholdService.js"
      via: "fire-and-forget call after upload"
      pattern: "ThresholdService\\.evaluateAndNotify"
    - from: "server/services/ThresholdService.js"
      to: "server/services/NotificationService.js"
      via: "notification creation"
      pattern: "NotificationService\\.create"
---

<objective>
Create ThresholdService with KPI breach detection, 24-hour deduplication, and fire-and-forget integration with the bugs upload route.

Purpose: Enable automated detection of critical KPI breaches during CSV upload so users are proactively alerted when performance degrades into the red zone.

Output: Backend threshold detection system that creates deduplicated notifications on KPI breaches, plus unread count endpoint for frontend consumption.
</objective>

<execution_context>
@/Users/i306072/.claude/get-shit-done/workflows/execute-plan.md
@/Users/i306072/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-threshold-notifications/15-RESEARCH.md

# Existing notification infrastructure
@server/services/NotificationService.js
@server/routes/notifications.js

# KPI threshold definitions (source of truth)
@src/components/bugs/KPICard.jsx

# Upload route for integration point
@server/routes/bugs.js

# Database patterns
@server/db/migrate.js
@server/db/019_bug_dashboard.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create database migration for notification types</name>
  <files>server/db/020_notification_types.sql, server/db/migrate.js</files>
  <action>
Create 020_notification_types.sql migration to extend the notifications table with type classification and metadata fields.

Migration SQL (server/db/020_notification_types.sql):
```sql
-- Add notification type and metadata for KPI alerts
-- notification_type: 'general', 'kpi_alert', etc.
-- metadata: JSONB for kpi_key, week_ending, threshold values

ALTER TABLE notifications
ADD COLUMN IF NOT EXISTS notification_type VARCHAR(50) DEFAULT 'general',
ADD COLUMN IF NOT EXISTS metadata JSONB DEFAULT '{}';

-- Index for efficient type queries
CREATE INDEX IF NOT EXISTS idx_notifications_type ON notifications(notification_type);

-- Index for deduplication queries by KPI key
CREATE INDEX IF NOT EXISTS idx_notifications_metadata_kpi ON notifications((metadata->>'kpi_key'));

-- Composite index for deduplication: user + type + kpi_key + created_date
CREATE INDEX IF NOT EXISTS idx_notifications_dedup ON notifications(user_id, notification_type, created_date);
```

Update migrate.js to include the new migration:
Add to the MIGRATIONS array:
```javascript
{
  version: '020_notification_types',
  name: 'Add notification type and metadata for KPI alerts',
  sql: fs.readFileSync(path.join(__dirname, '020_notification_types.sql'), 'utf8')
}
```
  </action>
  <verify>
- Run `npm run migrate` and verify migration executes without errors
- Check database: `\d notifications` should show notification_type and metadata columns
- Verify indexes exist: `\di` should list idx_notifications_type, idx_notifications_metadata_kpi, idx_notifications_dedup
  </verify>
  <done>Database has notification_type and metadata columns with appropriate indexes</done>
</task>

<task type="auto">
  <name>Task 2: Create ThresholdService with KPI evaluation and deduplication</name>
  <files>server/services/ThresholdService.js</files>
  <action>
Create ThresholdService.js with KPI threshold evaluation and deduplicated notification creation.

Key elements:
1. **KPI_THRESHOLDS constant** - Duplicate from KPICard.jsx (comment points to frontend as source of truth)
2. **getKPIStatus function** - Same logic as frontend
3. **KPI_LABELS constant** - Human-readable labels for notifications
4. **evaluateAndNotify method** - Main entry point, checks each KPI for red zone
5. **createNotificationIfNotDuplicate method** - 24-hour deduplication check

Implementation:
```javascript
import { query } from '../db/connection.js';
import NotificationService from './NotificationService.js';

/**
 * KPI threshold definitions for status determination
 * Source of truth: src/components/bugs/KPICard.jsx
 * Keep in sync - any changes there must be reflected here
 */
const KPI_THRESHOLDS = {
  bug_inflow_rate: {
    type: 'lower_is_better',
    green: 6,
    yellow: 8,
  },
  median_ttfr_hours: {
    type: 'lower_is_better',
    green: 24,
    yellow: 48,
  },
  sla_vh_percent: {
    type: 'higher_is_better',
    green: 80,
    yellow: 60,
  },
  sla_high_percent: {
    type: 'higher_is_better',
    green: 80,
    yellow: 60,
  },
  backlog_health_score: {
    type: 'higher_is_better',
    green: 70,
    yellow: 50,
  },
};

const KPI_LABELS = {
  bug_inflow_rate: 'Bug Inflow Rate',
  median_ttfr_hours: 'Time to First Response',
  sla_vh_percent: 'SLA Compliance (VH)',
  sla_high_percent: 'SLA Compliance (High)',
  backlog_health_score: 'Backlog Health Score',
};

/**
 * Determine KPI status based on value and thresholds
 */
function getKPIStatus(kpiKey, value) {
  const threshold = KPI_THRESHOLDS[kpiKey];
  if (!threshold || value === null || value === undefined || isNaN(value)) {
    return 'neutral';
  }

  if (threshold.type === 'lower_is_better') {
    if (value <= threshold.green) return 'green';
    if (value <= threshold.yellow) return 'yellow';
    return 'red';
  } else {
    if (value >= threshold.green) return 'green';
    if (value >= threshold.yellow) return 'yellow';
    return 'red';
  }
}

class ThresholdService {
  /**
   * Evaluate KPIs and create notifications for red zone breaches
   * Called fire-and-forget after CSV upload completes
   *
   * @param {string} userId - User ID
   * @param {object} kpis - KPI data object from upload result
   * @param {string} weekEnding - Week ending date string
   */
  async evaluateAndNotify(userId, kpis, weekEnding) {
    if (!kpis || typeof kpis !== 'object') {
      console.log('ThresholdService: No KPI data to evaluate');
      return;
    }

    const kpiKeys = Object.keys(KPI_THRESHOLDS);

    for (const kpiKey of kpiKeys) {
      const value = kpis[kpiKey];
      const status = getKPIStatus(kpiKey, value);

      if (status === 'red') {
        console.log(`ThresholdService: ${kpiKey} in red zone (${value})`);
        await this.createNotificationIfNotDuplicate(userId, kpiKey, value, weekEnding);
      }
    }
  }

  /**
   * Create notification if no duplicate exists within 24 hours
   * Deduplication prevents alert spam on re-uploads or multiple week uploads
   */
  async createNotificationIfNotDuplicate(userId, kpiKey, value, weekEnding) {
    try {
      // Check for existing notification within 24-hour window
      const cutoff = new Date(Date.now() - 24 * 60 * 60 * 1000);

      const existingResult = await query(`
        SELECT id FROM notifications
        WHERE user_id = $1
          AND notification_type = 'kpi_alert'
          AND metadata->>'kpi_key' = $2
          AND created_date > $3
        LIMIT 1
      `, [userId, kpiKey, cutoff.toISOString()]);

      if (existingResult.rows.length > 0) {
        console.log(`ThresholdService: Duplicate notification suppressed for ${kpiKey}`);
        return null;
      }

      // Create new notification
      const label = KPI_LABELS[kpiKey] || kpiKey;
      const threshold = KPI_THRESHOLDS[kpiKey];
      const thresholdValue = threshold.type === 'lower_is_better' ? threshold.yellow : threshold.yellow;

      const message = `KPI Alert: ${label} has crossed into the red zone (${value}${kpiKey.includes('percent') ? '%' : ''})`;

      const notification = await NotificationService.createWithType(userId, {
        message,
        notification_type: 'kpi_alert',
        metadata: {
          kpi_key: kpiKey,
          value: value,
          week_ending: weekEnding,
          threshold: thresholdValue,
        },
      });

      console.log(`ThresholdService: Created notification for ${kpiKey}`);
      return notification;
    } catch (error) {
      console.error(`ThresholdService: Failed to create notification for ${kpiKey}:`, error);
      return null;
    }
  }
}

export default new ThresholdService();
```
  </action>
  <verify>
Review ThresholdService.js and confirm:
- KPI_THRESHOLDS matches KPICard.jsx definitions
- getKPIStatus correctly evaluates thresholds
- evaluateAndNotify iterates over all KPI keys
- createNotificationIfNotDuplicate has 24-hour deduplication query
- Error handling prevents upload from failing if notification creation fails
  </verify>
  <done>ThresholdService evaluates KPIs and creates deduplicated notifications for red zone breaches</done>
</task>

<task type="auto">
  <name>Task 3: Extend NotificationService with type-aware create method and update routes</name>
  <files>server/services/NotificationService.js, server/routes/notifications.js</files>
  <action>
Extend NotificationService to handle notification_type and metadata fields.

1. Add createWithType method to NotificationService.js:
```javascript
async createWithType(userId, notificationData) {
  try {
    const {
      message,
      read = false,
      scheduled_date = null,
      notification_type = 'general',
      metadata = {},
    } = notificationData;

    if (!message) {
      throw new Error('Missing required field: message');
    }

    const sql = `
      INSERT INTO notifications (user_id, message, read, scheduled_date, notification_type, metadata)
      VALUES ($1, $2, $3, $4, $5, $6)
      RETURNING *
    `;

    const values = [userId, message, read, scheduled_date, notification_type, JSON.stringify(metadata)];
    const result = await query(sql, values);
    return result.rows[0];
  } catch (error) {
    console.error('NotificationService.createWithType error:', error);
    throw new Error('Failed to create notification');
  }
}

async getUnreadCount(userId) {
  try {
    const result = await query(
      'SELECT COUNT(*) FROM notifications WHERE user_id = $1 AND read = false',
      [userId]
    );
    return parseInt(result.rows[0].count, 10);
  } catch (error) {
    console.error('NotificationService.getUnreadCount error:', error);
    throw new Error('Failed to get unread count');
  }
}
```

2. Add unread-count endpoint to notifications.js:
```javascript
// GET /api/notifications/unread-count
// Returns count of unread notifications for badge display
router.get('/unread-count', async (req, res) => {
  try {
    const count = await NotificationService.getUnreadCount(req.user.id);
    res.json({ count });
  } catch (error) {
    console.error('GET /api/notifications/unread-count error:', error);
    res.status(500).json({ error: error.message });
  }
});
```

Add this route BEFORE the /:id route to prevent route conflicts.

3. Update the update method's allowedFields in NotificationService to include notification_type and metadata:
```javascript
const allowedFields = ['message', 'read', 'scheduled_date', 'notification_type', 'metadata'];
```
  </action>
  <verify>
- Review NotificationService.js for createWithType and getUnreadCount methods
- Review notifications.js for /unread-count endpoint placement (before /:id)
- Test endpoint: `curl http://localhost:3001/api/notifications/unread-count` returns `{"count": N}`
  </verify>
  <done>NotificationService has createWithType and getUnreadCount methods; /unread-count endpoint available</done>
</task>

<task type="auto">
  <name>Task 4: Integrate threshold detection into bugs upload route</name>
  <files>server/routes/bugs.js</files>
  <action>
Add fire-and-forget threshold check after successful CSV upload.

1. Import ThresholdService:
```javascript
import ThresholdService from '../services/ThresholdService.js';
```

2. Modify the POST /upload handler to call ThresholdService after returning response:

In the existing upload handler, after `res.json(result);`, add the fire-and-forget call:
```javascript
router.post('/upload', upload.single('csvFile'), async (req, res) => {
  try {
    const { weekEnding } = req.body;

    // ... existing validation ...

    const result = await BugService.uploadCSV(
      req.user.id,
      req.file.buffer,
      req.file.originalname,
      weekEnding
    );

    // Return response immediately to the client
    res.json(result);

    // Fire-and-forget threshold check (async, no await)
    // Runs after response is sent, doesn't block upload flow
    if (result.kpis) {
      ThresholdService.evaluateAndNotify(req.user.id, result.kpis, weekEnding)
        .catch(err => console.error('Threshold notification failed:', err));
    }

  } catch (error) {
    // ... existing error handling ...
  }
});
```

Important: The threshold check must be AFTER res.json() and must NOT be awaited.
This ensures the upload response is returned immediately while notifications are processed asynchronously.
  </action>
  <verify>
- Review bugs.js upload route has ThresholdService import
- Verify fire-and-forget call is after res.json()
- Verify the call is NOT awaited (uses .catch() for error handling)
- Test: Upload CSV with a KPI in red zone, verify notification created
  </verify>
  <done>CSV upload route triggers fire-and-forget threshold evaluation</done>
</task>

</tasks>

<verification>
After all tasks:
1. `npm run migrate` - Run migration for new columns
2. `npm run dev` - Start development server
3. Test unread count endpoint: `curl http://localhost:3001/api/notifications/unread-count`
4. Upload a CSV with data that will trigger red zone (e.g., high bug inflow)
5. Check notifications table: Should have new entry with notification_type='kpi_alert'
6. Re-upload same CSV within 24 hours - verify no duplicate notification created
7. Check unread count increased
</verification>

<success_criteria>
- [ ] Migration 020_notification_types.sql executes successfully
- [ ] notifications table has notification_type and metadata columns
- [ ] ThresholdService.evaluateAndNotify evaluates all 5 KPIs
- [ ] ThresholdService deduplicates within 24-hour window
- [ ] NotificationService.createWithType creates notifications with type and metadata
- [ ] NotificationService.getUnreadCount returns accurate count
- [ ] GET /api/notifications/unread-count endpoint works
- [ ] CSV upload triggers fire-and-forget threshold check
- [ ] Notifications created for red zone KPIs
</success_criteria>

<output>
After completion, create `.planning/phases/15-threshold-notifications/15-01-SUMMARY.md`
</output>
