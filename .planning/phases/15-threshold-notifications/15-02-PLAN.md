---
phase: 15-threshold-notifications
plan: 02
type: execute
wave: 2
depends_on: ["15-01"]
files_modified:
  - src/contexts/NotificationContext.jsx
  - src/components/notifications/NotificationBell.jsx
  - src/components/notifications/NotificationPanel.jsx
  - src/api/apiClient.js
  - src/pages/Layout.jsx
  - src/main.jsx
autonomous: true

must_haves:
  truths:
    - "Notification bell icon in header shows unread count badge"
    - "User can click bell to view notification panel with alert list"
    - "User can mark individual notifications as read"
    - "Unread count updates when notifications are marked as read"
  artifacts:
    - path: "src/contexts/NotificationContext.jsx"
      provides: "React context for notification state management"
      exports: ["NotificationProvider", "useNotifications"]
    - path: "src/components/notifications/NotificationBell.jsx"
      provides: "Bell icon with unread badge and Popover trigger"
      exports: ["NotificationBell"]
    - path: "src/components/notifications/NotificationPanel.jsx"
      provides: "Scrollable notification list with mark-as-read"
      exports: ["NotificationPanel"]
  key_links:
    - from: "src/contexts/NotificationContext.jsx"
      to: "/api/notifications"
      via: "apiClient.entities.Notification"
      pattern: "Notification\\.(list|update)"
    - from: "src/pages/Layout.jsx"
      to: "src/components/notifications/NotificationBell.jsx"
      via: "component import in header"
      pattern: "<NotificationBell"
---

<objective>
Create NotificationBell component and NotificationPanel UI for viewing and managing in-app notifications.

Purpose: Provide users with a non-intrusive way to see KPI alerts and other notifications without leaving their current workflow.

Output: Working notification bell in the header with badge count, dropdown panel showing notification list, and mark-as-read functionality.
</objective>

<execution_context>
@/Users/i306072/.claude/get-shit-done/workflows/execute-plan.md
@/Users/i306072/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-threshold-notifications/15-RESEARCH.md
@.planning/phases/15-threshold-notifications/15-01-PLAN.md

# Layout for header integration
@src/pages/Layout.jsx

# API client for extending
@src/api/apiClient.js

# UI components to use
@src/components/ui/popover.jsx
@src/components/ui/scroll-area.jsx
@src/components/ui/badge.jsx

# App entry point for context provider
@src/main.jsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend apiClient with notification methods</name>
  <files>src/api/apiClient.js</files>
  <action>
Extend the Notification entity client with getUnreadCount method.

Locate the entities object and modify the Notification entry to use a custom client:

1. Create a custom notification client function (similar to createCaptureInboxClient pattern):
```javascript
// Create Notification client with custom methods
function createNotificationClient() {
  const baseClient = createEntityClient('/notifications');

  return {
    ...baseClient,

    // Get count of unread notifications
    async getUnreadCount() {
      return fetchWithAuth(`${API_BASE_URL}/notifications/unread-count`);
    },

    // Mark notification as read (convenience wrapper)
    async markAsRead(id) {
      return baseClient.update(id, { read: true });
    },

    // Mark all notifications as read
    async markAllAsRead() {
      const notifications = await baseClient.list();
      const unread = notifications.filter(n => !n.read);
      await Promise.all(unread.map(n => baseClient.update(n.id, { read: true })));
      return { updated: unread.length };
    },
  };
}
```

2. Update the entities object:
```javascript
entities: {
  // ... existing entities ...
  Notification: createNotificationClient(),
  // ... rest of entities ...
}
```

Replace the existing `Notification: createEntityClient('/notifications'),` line with the new client.
  </action>
  <verify>
Review apiClient.js and confirm:
- createNotificationClient function exists
- Notification entity uses custom client
- getUnreadCount, markAsRead, markAllAsRead methods available
  </verify>
  <done>apiClient.entities.Notification has getUnreadCount and markAsRead methods</done>
</task>

<task type="auto">
  <name>Task 2: Create NotificationContext for state management</name>
  <files>src/contexts/NotificationContext.jsx</files>
  <action>
Create NotificationContext.jsx for managing notification state across the app.

```jsx
// src/contexts/NotificationContext.jsx
// Context for managing notification state and actions

import { createContext, useContext, useState, useEffect, useCallback } from 'react';
import { Notification } from '@/api/entities';
import { useAuth } from '@/contexts/AuthContext';

const NotificationContext = createContext(null);

export function NotificationProvider({ children }) {
  const [notifications, setNotifications] = useState([]);
  const [unreadCount, setUnreadCount] = useState(0);
  const [loading, setLoading] = useState(true);
  const { isAuthenticated } = useAuth();

  // Fetch notifications and unread count
  const refresh = useCallback(async () => {
    if (!isAuthenticated) {
      setNotifications([]);
      setUnreadCount(0);
      setLoading(false);
      return;
    }

    try {
      setLoading(true);
      const [notificationList, countResult] = await Promise.all([
        Notification.list(),
        Notification.getUnreadCount(),
      ]);
      setNotifications(notificationList);
      setUnreadCount(countResult.count);
    } catch (error) {
      console.error('Failed to fetch notifications:', error);
    } finally {
      setLoading(false);
    }
  }, [isAuthenticated]);

  // Initial fetch on mount and auth change
  useEffect(() => {
    refresh();
  }, [refresh]);

  // Mark a single notification as read (optimistic update)
  const markAsRead = useCallback(async (notificationId) => {
    // Optimistic update
    setNotifications(prev =>
      prev.map(n => n.id === notificationId ? { ...n, read: true } : n)
    );
    setUnreadCount(prev => Math.max(0, prev - 1));

    try {
      await Notification.markAsRead(notificationId);
    } catch (error) {
      console.error('Failed to mark notification as read:', error);
      // Rollback on failure
      setNotifications(prev =>
        prev.map(n => n.id === notificationId ? { ...n, read: false } : n)
      );
      setUnreadCount(prev => prev + 1);
    }
  }, []);

  // Mark all notifications as read
  const markAllAsRead = useCallback(async () => {
    const previousNotifications = notifications;
    const previousCount = unreadCount;

    // Optimistic update
    setNotifications(prev => prev.map(n => ({ ...n, read: true })));
    setUnreadCount(0);

    try {
      await Notification.markAllAsRead();
    } catch (error) {
      console.error('Failed to mark all as read:', error);
      // Rollback on failure
      setNotifications(previousNotifications);
      setUnreadCount(previousCount);
    }
  }, [notifications, unreadCount]);

  const value = {
    notifications,
    unreadCount,
    loading,
    refresh,
    markAsRead,
    markAllAsRead,
  };

  return (
    <NotificationContext.Provider value={value}>
      {children}
    </NotificationContext.Provider>
  );
}

export function useNotifications() {
  const context = useContext(NotificationContext);
  if (!context) {
    throw new Error('useNotifications must be used within a NotificationProvider');
  }
  return context;
}
```
  </action>
  <verify>
Review NotificationContext.jsx and confirm:
- NotificationProvider component exists
- useNotifications hook exported
- refresh function fetches both list and count
- markAsRead has optimistic update with rollback
- markAllAsRead has optimistic update with rollback
- Handles unauthenticated state gracefully
  </verify>
  <done>NotificationContext provides notification state and actions across app</done>
</task>

<task type="auto">
  <name>Task 3: Create NotificationBell and NotificationPanel components</name>
  <files>src/components/notifications/NotificationBell.jsx, src/components/notifications/NotificationPanel.jsx</files>
  <action>
Create the notification UI components directory and files.

First, create src/components/notifications/ directory.

**NotificationPanel.jsx:**
```jsx
// src/components/notifications/NotificationPanel.jsx
// Scrollable list of notifications with mark-as-read

import { formatDistanceToNow } from 'date-fns';
import { Bell, AlertTriangle, Check } from 'lucide-react';
import { ScrollArea } from '@/components/ui/scroll-area';
import { Button } from '@/components/ui/button';
import { cn } from '@/lib/utils';

function NotificationItem({ notification, onMarkRead }) {
  const isKPIAlert = notification.notification_type === 'kpi_alert';

  return (
    <div
      className={cn(
        'px-4 py-3 border-b border-gray-100 hover:bg-gray-50 cursor-pointer transition-colors',
        !notification.read && 'bg-blue-50/50'
      )}
      onClick={() => !notification.read && onMarkRead(notification.id)}
    >
      <div className="flex gap-3">
        {/* Icon */}
        <div className={cn(
          'flex-shrink-0 mt-0.5',
          isKPIAlert ? 'text-red-500' : 'text-gray-400'
        )}>
          {isKPIAlert ? (
            <AlertTriangle className="h-4 w-4" />
          ) : (
            <Bell className="h-4 w-4" />
          )}
        </div>

        {/* Content */}
        <div className="flex-1 min-w-0">
          <p className={cn(
            'text-sm',
            notification.read ? 'text-gray-600' : 'text-gray-900 font-medium'
          )}>
            {notification.message}
          </p>
          <p className="text-xs text-gray-400 mt-1">
            {formatDistanceToNow(new Date(notification.created_date), { addSuffix: true })}
          </p>
        </div>

        {/* Read indicator */}
        {!notification.read && (
          <div className="flex-shrink-0">
            <span className="h-2 w-2 rounded-full bg-blue-500 block" />
          </div>
        )}
      </div>
    </div>
  );
}

export function NotificationPanel({ notifications, onMarkRead, onMarkAllRead }) {
  const unreadNotifications = notifications.filter(n => !n.read);

  return (
    <div className="w-full">
      {/* Header */}
      <div className="p-3 border-b flex items-center justify-between">
        <h3 className="font-semibold text-gray-900">Notifications</h3>
        {unreadNotifications.length > 0 && (
          <Button
            variant="ghost"
            size="sm"
            className="text-xs text-blue-600 hover:text-blue-700 h-auto py-1 px-2"
            onClick={onMarkAllRead}
          >
            <Check className="h-3 w-3 mr-1" />
            Mark all read
          </Button>
        )}
      </div>

      {/* Notification list */}
      <ScrollArea className="h-[300px]">
        {notifications.length === 0 ? (
          <div className="p-8 text-center text-gray-500">
            <Bell className="h-8 w-8 mx-auto mb-2 text-gray-300" />
            <p className="text-sm">No notifications</p>
          </div>
        ) : (
          notifications.map(notification => (
            <NotificationItem
              key={notification.id}
              notification={notification}
              onMarkRead={onMarkRead}
            />
          ))
        )}
      </ScrollArea>
    </div>
  );
}
```

**NotificationBell.jsx:**
```jsx
// src/components/notifications/NotificationBell.jsx
// Bell icon with unread badge and popover trigger

import { Bell } from 'lucide-react';
import { Popover, PopoverTrigger, PopoverContent } from '@/components/ui/popover';
import { useNotifications } from '@/contexts/NotificationContext';
import { NotificationPanel } from './NotificationPanel';
import { cn } from '@/lib/utils';

export function NotificationBell({ className }) {
  const { notifications, unreadCount, markAsRead, markAllAsRead } = useNotifications();

  return (
    <Popover>
      <PopoverTrigger asChild>
        <button
          className={cn(
            'relative p-2 rounded-full hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors',
            className
          )}
          aria-label={`Notifications${unreadCount > 0 ? ` (${unreadCount} unread)` : ''}`}
        >
          <Bell className="h-5 w-5 text-gray-600 dark:text-gray-300" />
          {unreadCount > 0 && (
            <span className="absolute -top-0.5 -right-0.5 h-5 w-5 rounded-full bg-red-500 text-white text-xs font-medium flex items-center justify-center">
              {unreadCount > 9 ? '9+' : unreadCount}
            </span>
          )}
        </button>
      </PopoverTrigger>
      <PopoverContent className="w-80 p-0" align="end" sideOffset={8}>
        <NotificationPanel
          notifications={notifications}
          onMarkRead={markAsRead}
          onMarkAllRead={markAllAsRead}
        />
      </PopoverContent>
    </Popover>
  );
}
```

Create both files in src/components/notifications/.
  </action>
  <verify>
Review components and confirm:
- NotificationBell renders bell icon with badge
- Badge shows count (caps at 9+)
- Popover opens on click
- NotificationPanel renders scrollable list
- NotificationItem shows icon, message, timestamp
- Unread items highlighted with blue background
- Click on unread item marks it as read
- "Mark all read" button works
  </verify>
  <done>NotificationBell and NotificationPanel components created with full functionality</done>
</task>

<task type="auto">
  <name>Task 4: Integrate NotificationBell into Layout header and add provider</name>
  <files>src/pages/Layout.jsx, src/main.jsx</files>
  <action>
Integrate the notification system into the app.

**1. Update main.jsx to add NotificationProvider:**

Import NotificationProvider:
```javascript
import { NotificationProvider } from '@/contexts/NotificationContext';
```

Wrap the app with NotificationProvider (inside AuthProvider, outside other providers):
```jsx
<AuthProvider>
  <NotificationProvider>
    <DisplayModeProvider>
      <AppModeProvider>
        <AppProvider>
          {/* ... router ... */}
        </AppProvider>
      </AppModeProvider>
    </DisplayModeProvider>
  </NotificationProvider>
</AuthProvider>
```

**2. Update Layout.jsx to add NotificationBell:**

Import NotificationBell:
```javascript
import { NotificationBell } from '@/components/notifications/NotificationBell';
```

Add NotificationBell to the header, in the flex container with mode badge and presentation toggle.

Find the header section with mode indicator and presentation toggle (around line 453):
```jsx
{/* Mode indicator and Presentation Mode Toggle */}
<div className="flex items-center gap-2">
  {/* Add NotificationBell here */}
  <NotificationBell
    className={isProductMode ? 'hover:bg-gray-700' : ''}
  />

  {/* Mode indicator badge */}
  <span className={cn(
    "hidden sm:inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium transition-colors",
    // ...
  )}>
```

Position: NotificationBell should appear BEFORE the mode badge, in the header toolbar area.
  </action>
  <verify>
Run development server and verify:
- NotificationBell appears in header (near mode toggle)
- Click bell opens popover with notifications
- Unread count badge visible when notifications exist
- Mark as read updates badge count
- Works in both People and Product modes
  </verify>
  <done>NotificationBell integrated into Layout header with provider in place</done>
</task>

</tasks>

<verification>
After all tasks:
1. `npm run dev` - Start development server
2. Navigate to any page in the app
3. Verify notification bell appears in header
4. Click bell - popover should open with notification list
5. If no notifications, should show empty state
6. Trigger a notification (upload CSV with red zone KPI from 15-01)
7. Refresh page - verify badge shows unread count
8. Click on unread notification - verify it marks as read
9. Verify badge count decreases
10. Test "Mark all read" button
11. Test in both People and Product modes
</verification>

<success_criteria>
- [ ] apiClient.entities.Notification has getUnreadCount and markAsRead methods
- [ ] NotificationContext provides notifications state and actions
- [ ] NotificationBell renders in Layout header
- [ ] Bell shows unread count badge when > 0
- [ ] Clicking bell opens popover with notification list
- [ ] Notifications display message, timestamp, and read status
- [ ] Clicking unread notification marks it as read
- [ ] "Mark all read" marks all notifications as read
- [ ] Badge count updates optimistically
- [ ] Works in both People and Product app modes
</success_criteria>

<output>
After completion, create `.planning/phases/15-threshold-notifications/15-02-SUMMARY.md`
</output>
