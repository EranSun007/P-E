---
phase: 22-team-status-page
plan: 03
type: execute
wave: 1
depends_on: ["22-01", "22-02"]
files_modified:
  - server/db/023_team_summaries.sql
  - server/db/migrate.js
  - server/services/TeamSummaryService.js
  - server/routes/teamSummaries.js
  - server/index.js
  - server/routes/knowledge.js
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "GET /api/knowledge/insights returns { summaries: [...] } from PostgreSQL team_summaries table (replaces MCP semantic search)"
    - "Each summary object contains: memberId, memberName, completedCount, blockerCount, oneLine, items[], weekEndingDate"
    - "After creating a test summary via POST /api/team-summaries, MetricsBanner shows non-zero values (e.g., completedCount=5, blockerCount=1)"
    - "Team summaries persist in PostgreSQL across page refresh and server restart"
  artifacts:
    - path: "server/db/023_team_summaries.sql"
      provides: "team_summaries table schema"
      contains: "CREATE TABLE IF NOT EXISTS team_summaries"
    - path: "server/services/TeamSummaryService.js"
      provides: "CRUD operations for team summaries"
      exports: ["list", "create", "update", "delete"]
    - path: "server/routes/teamSummaries.js"
      provides: "REST endpoints for team summaries"
      contains: "router.get"
  key_links:
    - from: "src/contexts/TeamStatusContext.jsx"
      to: "/api/knowledge/insights"
      via: "apiClient.knowledge.searchInsights()"
      pattern: "apiClient\\.knowledge\\.searchInsights"
    - from: "server/routes/knowledge.js"
      to: "TeamSummaryService"
      via: "import and service call in GET /insights"
      pattern: "TeamSummaryService\\.list"
    - from: "server/services/TeamSummaryService.js"
      to: "team_summaries table"
      via: "SQL query with parameterized values"
      pattern: "FROM team_summaries"
---

<objective>
Fix data structure mismatch between MCP semantic search results and UI component expectations.

Purpose: The verification found that MCPService.getInsights returns generic search results from MCP, but the UI components (MetricsBanner, MemberCard) expect structured summary objects with completedCount, blockerCount, items[], memberName fields. This gap closure plan updates GET /api/knowledge/insights to read from PostgreSQL instead of MCP, providing properly structured data.

Output: Working Team Status dashboard with real data - PostgreSQL team_summaries table, TeamSummaryService, updated GET /api/knowledge/insights endpoint returning structured summaries that the existing frontend can render correctly.

**Important architectural note:** The existing frontend (TeamStatusContext.jsx) already calls `/api/knowledge/insights` via `apiClient.knowledge.searchInsights()`. No frontend code changes are needed - this plan updates the backend endpoint to return properly structured data from PostgreSQL instead of MCP semantic search results.
</objective>

<execution_context>
@/Users/i306072/.claude/get-shit-done/workflows/execute-plan.md
@/Users/i306072/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-team-status-page/22-VERIFICATION.md
@.planning/phases/22-team-status-page/22-01-SUMMARY.md
@.planning/phases/22-team-status-page/22-02-SUMMARY.md

# Key files for reference
@server/services/TaskService.js (service pattern)
@server/db/migrate.js (migration registration)
@server/routes/knowledge.js (existing insights endpoint to update)
@src/contexts/TeamStatusContext.jsx (frontend data consumer - calls apiClient.knowledge.searchInsights)
@src/components/team-status/MetricsBanner.jsx (expected data structure)
@src/components/team-status/MemberCard.jsx (expected data structure)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create team_summaries table and TeamSummaryService</name>
  <files>
    server/db/023_team_summaries.sql
    server/db/migrate.js
    server/services/TeamSummaryService.js
  </files>
  <action>
1. Create migration file `server/db/023_team_summaries.sql`:
```sql
-- Team summaries table for storing structured team status data
CREATE TABLE IF NOT EXISTS team_summaries (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id VARCHAR(255) NOT NULL,
  member_id VARCHAR(255) NOT NULL,
  member_name VARCHAR(255) NOT NULL,
  team_department VARCHAR(100) DEFAULT 'metering',
  week_ending_date DATE NOT NULL,
  completed_count INTEGER DEFAULT 0,
  blocker_count INTEGER DEFAULT 0,
  one_line TEXT,
  items JSONB DEFAULT '[]',
  last_update_days INTEGER DEFAULT 0,
  created_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  UNIQUE(user_id, member_id, week_ending_date)
);

CREATE INDEX IF NOT EXISTS idx_team_summaries_user_id ON team_summaries(user_id);
CREATE INDEX IF NOT EXISTS idx_team_summaries_team ON team_summaries(team_department);
CREATE INDEX IF NOT EXISTS idx_team_summaries_week ON team_summaries(week_ending_date);
CREATE INDEX IF NOT EXISTS idx_team_summaries_member ON team_summaries(member_id);

-- Trigger for updated_date
CREATE OR REPLACE FUNCTION update_team_summaries_updated_date()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_date = CURRENT_TIMESTAMP;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS team_summaries_updated_date ON team_summaries;
CREATE TRIGGER team_summaries_updated_date
  BEFORE UPDATE ON team_summaries
  FOR EACH ROW
  EXECUTE FUNCTION update_team_summaries_updated_date();
```

2. Register migration in `server/db/migrate.js` - add to MIGRATIONS array:
```javascript
{
  version: '023_team_summaries',
  name: 'Create team_summaries table for structured team status data',
  file: '023_team_summaries.sql'
}
```

3. Create `server/services/TeamSummaryService.js` following TaskService pattern:
- Import { query } from '../db/connection.js'
- Implement class with methods:
  - `list(userId, options)` - filter by teamDepartment, startDate, endDate
  - `create(userId, summaryData)` - create new summary (UPSERT on unique constraint)
  - `update(userId, id, updates)` - update existing summary
  - `delete(userId, id)` - delete summary
  - `getByMember(userId, memberId, weekEndingDate)` - get specific summary
- Return camelCase field names to match UI expectations (member_id -> memberId, completed_count -> completedCount)
- Always filter by user_id for multi-tenancy
- Use parameterized queries to prevent SQL injection
  </action>
  <verify>
Run `npm run migrate` to create table, then verify:
```bash
# Check migration succeeded
docker exec -it teamssync-postgres psql -U postgres -d pe_manager -c "\d team_summaries"

# Should show table with columns: id, user_id, member_id, member_name, team_department, week_ending_date, completed_count, blocker_count, one_line, items, last_update_days, created_date, updated_date
```
  </verify>
  <done>
- Migration file exists at server/db/023_team_summaries.sql
- Migration registered in migrate.js
- TeamSummaryService.js exports list, create, update, delete methods
- Table created with proper indexes and trigger
  </done>
</task>

<task type="auto">
  <name>Task 2: Update GET /api/knowledge/insights to read from PostgreSQL and add CRUD routes</name>
  <files>
    server/routes/teamSummaries.js
    server/index.js
    server/routes/knowledge.js
  </files>
  <action>
**Endpoint behavior change:** GET /api/knowledge/insights currently calls MCPService.getInsights() which performs semantic search and returns generic results. This task REPLACES that behavior to read from PostgreSQL team_summaries table instead. The frontend (TeamStatusContext.jsx) already calls this endpoint via apiClient.knowledge.searchInsights() and expects structured data - no frontend changes needed.

1. Create `server/routes/teamSummaries.js` for direct CRUD operations:
```javascript
import express from 'express';
import TeamSummaryService from '../services/TeamSummaryService.js';

const router = express.Router();
const service = new TeamSummaryService();

// GET / - List summaries with filters
router.get('/', async (req, res) => {
  const { teamDepartment, startDate, endDate, limit } = req.query;
  const summaries = await service.list(req.user.id, { teamDepartment, startDate, endDate, limit });
  res.json({ summaries, total: summaries.length });
});

// POST / - Create summary (UPSERT)
router.post('/', async (req, res) => {
  const summary = await service.create(req.user.id, req.body);
  res.status(201).json(summary);
});

// PUT /:id - Update summary
router.put('/:id', async (req, res) => {
  const summary = await service.update(req.user.id, req.params.id, req.body);
  if (!summary) return res.status(404).json({ error: 'Summary not found' });
  res.json(summary);
});

// DELETE /:id - Delete summary
router.delete('/:id', async (req, res) => {
  const deleted = await service.delete(req.user.id, req.params.id);
  if (!deleted) return res.status(404).json({ error: 'Summary not found' });
  res.status(204).send();
});
```

2. Mount routes in `server/index.js`:
- Import teamSummariesRoutes from './routes/teamSummaries.js'
- Add `app.use('/api/team-summaries', teamSummariesRoutes)` after other route registrations

3. **CRITICAL: Update `server/routes/knowledge.js` GET /insights endpoint (lines 106-131):**
This is the key change - replace MCP semantic search with PostgreSQL query.

- Import TeamSummaryService at top of file
- Modify GET /insights handler to use TeamSummaryService instead of MCPService:
```javascript
router.get('/insights', async (req, res) => {
  try {
    const { startDate, endDate, teamDepartment, limit } = req.query;

    // Validate dates if provided
    if (startDate && isNaN(Date.parse(startDate))) {
      return res.status(400).json({ error: 'Invalid startDate format' });
    }
    if (endDate && isNaN(Date.parse(endDate))) {
      return res.status(400).json({ error: 'Invalid endDate format' });
    }

    // Read from PostgreSQL team_summaries table (REPLACES MCPService.getInsights)
    const summaryService = new TeamSummaryService();
    const summaries = await summaryService.list(req.user.id, {
      teamDepartment,
      startDate,
      endDate,
      limit: limit ? parseInt(limit) : undefined
    });

    res.json({ summaries, total: summaries.length });
  } catch (error) {
    console.error('GET /api/knowledge/insights error:', error);
    res.status(500).json({ error: error.message });
  }
});
```

Note: Keep MCPService.getInsights method unchanged for backward compatibility - it may still be useful for other semantic search operations.
  </action>
  <verify>
**API verification (curl):**
```bash
# Start server
npm run dev:server &
sleep 3

# Test list endpoint (should return empty initially)
curl -s http://localhost:3001/api/knowledge/insights | jq .
# Expected: { "summaries": [], "total": 0 }

# Test create endpoint via team-summaries route
curl -s -X POST http://localhost:3001/api/team-summaries \
  -H "Content-Type: application/json" \
  -d '{
    "memberId": "test-member-1",
    "memberName": "Test User",
    "teamDepartment": "metering",
    "weekEndingDate": "2026-01-31",
    "completedCount": 5,
    "blockerCount": 1,
    "oneLine": "Completed feature X, blocked on API",
    "items": [{"id": "1", "text": "Completed feature X"}, {"id": "2", "text": "Blocked on API"}]
  }' | jq .
# Expected: summary object with id, memberId, memberName, completedCount, blockerCount, items

# Verify it appears in insights endpoint
curl -s "http://localhost:3001/api/knowledge/insights?teamDepartment=metering" | jq .
# Expected: { "summaries": [{ memberId, memberName, completedCount: 5, blockerCount: 1, items: [...] }], "total": 1 }
```

**Browser-based UI verification (end-to-end):**
1. Start dev server: `npm run dev`
2. Open browser to http://localhost:5173/teamstatus
3. Observe: Page loads, MetricsBanner likely shows 0/0/0 (no data yet)
4. Add test summary via API (curl POST command above) or via team-summaries CRUD if UI exists
5. Click refresh or reload page at http://localhost:5173/teamstatus
6. Observe: MetricsBanner now shows completedCount=5, blockerCount=1 (or aggregated values if multiple summaries)
7. Observe: MemberCard for "Test User" appears with health indicator (yellow or red due to blocker)

**Data flow verification:**
- TeamStatusContext.jsx calls apiClient.knowledge.searchInsights()
- apiClient fetches GET /api/knowledge/insights?teamDepartment=metering&startDate=...&endDate=...
- knowledge.js routes to TeamSummaryService.list()
- TeamSummaryService queries PostgreSQL team_summaries table
- Response { summaries: [...] } flows back to TeamStatusContext
- Components (MetricsBanner, MemberCard) render with structured data
  </verify>
  <done>
- GET /api/knowledge/insights reads from PostgreSQL team_summaries (not MCP)
- POST /api/team-summaries creates new summaries with UPSERT behavior
- Response data includes: memberId, memberName, completedCount, blockerCount, oneLine, items[], weekEndingDate
- Frontend (TeamStatusContext) receives properly structured data without code changes
- MetricsBanner displays non-zero metrics after test data is added
- MemberCard renders with member name and health indicators
  </done>
</task>

</tasks>

<verification>
After completing both tasks:

1. **Database verification:**
   - `\d team_summaries` shows expected schema
   - Indexes exist for user_id, team_department, week_ending_date

2. **API verification:**
   - GET /api/knowledge/insights returns `{ summaries: [...], total: N }` from PostgreSQL
   - Each summary has: memberId, memberName, completedCount, blockerCount, oneLine, items[]
   - POST /api/team-summaries creates/updates summaries
   - Date filtering works (startDate/endDate query params)
   - Team filtering works (teamDepartment query param)

3. **End-to-end data flow verification:**
   - TeamStatusContext.jsx refresh() -> apiClient.knowledge.searchInsights()
   - -> GET /api/knowledge/insights -> TeamSummaryService.list()
   - -> PostgreSQL team_summaries table -> structured response
   - -> MetricsBanner and MemberCard render correctly

4. **UI verification (browser):**
   - Navigate to http://localhost:5173/teamstatus
   - After adding test data via API, MetricsBanner shows non-zero values
   - MemberCard renders with member name and health indicators
   - Health calculation works (blockerCount drives red/yellow/green)
</verification>

<success_criteria>
- [ ] team_summaries table exists with proper schema
- [ ] TeamSummaryService has list, create, update, delete methods
- [ ] GET /api/knowledge/insights returns PostgreSQL data (replaces MCP semantic search)
- [ ] POST /api/team-summaries creates summaries with proper structure
- [ ] Response data matches UI component expectations (memberId, memberName, completedCount, blockerCount, items[])
- [ ] End-to-end: TeamStatusContext -> /api/knowledge/insights -> TeamSummaryService -> team_summaries
- [ ] MetricsBanner shows actual metrics after test data added (not 0/0/0)
- [ ] MemberCard renders with health indicators
</success_criteria>

<output>
After completion, create `.planning/phases/22-team-status-page/22-03-SUMMARY.md`
</output>
