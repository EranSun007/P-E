---
phase: 30-settings-ui-dnd-enhancement
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/settings/NavigationSettings.jsx
autonomous: true

must_haves:
  truths:
    - "User can drag folders to reorder them in the folders table"
    - "User can drag items between folders and root level"
    - "User can drag items within a folder to reorder them"
    - "Drag operations show visual feedback with highlighted drop targets"
    - "Drag operations persist to backend via saveConfig"
  artifacts:
    - path: "src/components/settings/NavigationSettings.jsx"
      provides: "DnD-enhanced navigation settings with folder and item reordering"
      contains: ["DndContext", "SortableContext", "useSortable", "DragOverlay"]
  key_links:
    - from: "NavigationSettings.jsx"
      to: "NavigationContext saveConfig"
      via: "onDragEnd handlers call saveConfig with reordered arrays"
      pattern: "saveConfig.*folders|items"
---

<objective>
Add drag-and-drop functionality to NavigationSettings for reordering folders and moving items between folders.

Purpose: Complete FOLDER-06, FOLDER-07, FOLDER-08 requirements - enable intuitive drag-based organization instead of relying solely on dropdowns.

Output: NavigationSettings.jsx with @dnd-kit integration for folder reordering and cross-container item dragging.
</objective>

<execution_context>
@/Users/i306072/.claude/get-shit-done/workflows/execute-plan.md
@/Users/i306072/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/30-settings-ui-dnd-enhancement/30-RESEARCH.md

Key research findings:
- @dnd-kit/core, @dnd-kit/sortable, @dnd-kit/utilities already installed
- Use single DndContext wrapping component
- Pattern 1: SortableContext for folder reordering (simple)
- Pattern 3: Cross-container dragging for items between folders (complex)
- Critical: contextToDndState/dndStateToContext transform utilities
- Critical: Empty folder droppable zones with min-height
- Critical: Call saveConfig in onDragEnd, not onDragOver
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add folder reordering with @dnd-kit sortable</name>
  <files>src/components/settings/NavigationSettings.jsx</files>
  <action>
Add drag-and-drop folder reordering to the folders table:

1. Add imports at top of file:
```javascript
import {
  DndContext,
  closestCenter,
  PointerSensor,
  KeyboardSensor,
  useSensor,
  useSensors,
  DragOverlay,
} from '@dnd-kit/core';
import {
  SortableContext,
  useSortable,
  verticalListSortingStrategy,
  arrayMove,
  sortableKeyboardCoordinates,
} from '@dnd-kit/sortable';
import { CSS } from '@dnd-kit/utilities';
import { GripVertical } from 'lucide-react';
```

2. Create SortableFolderRow component inside NavigationSettings (before the return):
```javascript
// Sortable folder row component
function SortableFolderRow({ folder, getItemsCount, openEditDialog, openDeleteDialog }) {
  const {
    attributes,
    listeners,
    setNodeRef,
    transform,
    transition,
    isDragging,
  } = useSortable({ id: folder.id });

  const style = {
    transform: CSS.Transform.toString(transform),
    transition,
    opacity: isDragging ? 0.5 : 1,
  };

  return (
    <TableRow ref={setNodeRef} style={style}>
      <TableCell>
        <div className="flex items-center gap-2">
          <button
            {...attributes}
            {...listeners}
            className="cursor-grab active:cursor-grabbing p-1 rounded hover:bg-gray-100"
          >
            <GripVertical className="h-4 w-4 text-gray-400" />
          </button>
          <FolderOpen className="h-4 w-4 text-gray-500" />
          <span className="font-medium">{folder.name}</span>
        </div>
      </TableCell>
      <TableCell>
        <Badge variant="secondary">
          {getItemsCount(folder.id)}
        </Badge>
      </TableCell>
      <TableCell>
        <DropdownMenu>
          <DropdownMenuTrigger asChild>
            <Button variant="ghost" size="sm" className="h-8 w-8 p-0">
              <span className="sr-only">Open menu</span>
              <MoreVertical className="h-4 w-4" />
            </Button>
          </DropdownMenuTrigger>
          <DropdownMenuContent align="end">
            <DropdownMenuItem onClick={() => openEditDialog(folder)}>
              <Pencil className="h-4 w-4 mr-2" />
              Edit
            </DropdownMenuItem>
            <DropdownMenuItem
              className="text-red-600"
              onClick={() => openDeleteDialog(folder)}
            >
              <Trash2 className="h-4 w-4 mr-2" />
              Delete
            </DropdownMenuItem>
          </DropdownMenuContent>
        </DropdownMenu>
      </TableCell>
    </TableRow>
  );
}
```

3. Add state for active folder drag at component top:
```javascript
const [activeFolderId, setActiveFolderId] = useState(null);
```

4. Add sensors configuration after local state:
```javascript
const sensors = useSensors(
  useSensor(PointerSensor, {
    activationConstraint: {
      distance: 8, // 8px before drag activates
    },
  }),
  useSensor(KeyboardSensor, {
    coordinateGetter: sortableKeyboardCoordinates,
  })
);
```

5. Add folder drag handlers:
```javascript
const handleFolderDragStart = ({ active }) => {
  setActiveFolderId(active.id);
};

const handleFolderDragEnd = async ({ active, over }) => {
  setActiveFolderId(null);

  if (!over || active.id === over.id) return;

  const oldIndex = folders.findIndex(f => f.id === active.id);
  const newIndex = folders.findIndex(f => f.id === over.id);

  if (oldIndex === -1 || newIndex === -1) return;

  // Reorder and recalculate order field
  const reordered = arrayMove(folders, oldIndex, newIndex);
  const foldersWithOrder = reordered.map((folder, index) => ({
    ...folder,
    order: index + 1,
  }));

  setSaving(true);
  setLocalError(null);

  try {
    const success = await saveConfig({
      ...config,
      folders: foldersWithOrder,
    });

    if (!success) {
      setLocalError("Failed to save folder order. Please try again.");
    }
  } catch (err) {
    console.error("Error saving folder order:", err);
    setLocalError("An unexpected error occurred. Please try again.");
  } finally {
    setSaving(false);
  }
};
```

6. Wrap the folders Table with DndContext and SortableContext. Replace the entire Table block (lines ~370-420) with:
```jsx
<DndContext
  sensors={sensors}
  collisionDetection={closestCenter}
  onDragStart={handleFolderDragStart}
  onDragEnd={handleFolderDragEnd}
>
  <SortableContext
    items={folders.sort((a, b) => (a.order || 0) - (b.order || 0)).map(f => f.id)}
    strategy={verticalListSortingStrategy}
  >
    <Table>
      <TableHeader>
        <TableRow>
          <TableHead>Name</TableHead>
          <TableHead>Items</TableHead>
          <TableHead className="w-[100px]">Actions</TableHead>
        </TableRow>
      </TableHeader>
      <TableBody>
        {folders
          .sort((a, b) => (a.order || 0) - (b.order || 0))
          .map((folder) => (
            <SortableFolderRow
              key={folder.id}
              folder={folder}
              getItemsCount={getItemsCount}
              openEditDialog={openEditDialog}
              openDeleteDialog={openDeleteDialog}
            />
          ))}
      </TableBody>
    </Table>
  </SortableContext>

  <DragOverlay>
    {activeFolderId ? (
      <div className="bg-white border rounded shadow-lg p-3 flex items-center gap-2">
        <GripVertical className="h-4 w-4 text-gray-400" />
        <FolderOpen className="h-4 w-4 text-gray-500" />
        <span className="font-medium">
          {folders.find(f => f.id === activeFolderId)?.name}
        </span>
      </div>
    ) : null}
  </DragOverlay>
</DndContext>
```

Note: Keep the empty state check (`folders.length === 0`) BEFORE this DndContext block.
  </action>
  <verify>
1. Run `npm run dev` and navigate to Settings > Navigation tab
2. Create 3+ folders if not already present
3. Verify grip icon appears on left of each folder row
4. Drag a folder to reorder - verify smooth animation
5. Verify folder order persists after page refresh
6. Verify keyboard navigation works (Tab to grip, Space to pick up, arrows to move, Space to drop)
  </verify>
  <done>
Folders can be reordered via drag-and-drop with:
- Grip handle on each folder row
- Visual DragOverlay showing folder being dragged
- Order persisted to backend after drag ends
- Keyboard accessibility via KeyboardSensor
  </done>
</task>

<task type="auto">
  <name>Task 2: Add cross-container item drag-and-drop</name>
  <files>src/components/settings/NavigationSettings.jsx</files>
  <action>
Add drag-and-drop for moving items between folders and root level:

1. Add useDroppable import to the @dnd-kit/core import block:
```javascript
import {
  DndContext,
  closestCenter,
  PointerSensor,
  KeyboardSensor,
  useSensor,
  useSensors,
  DragOverlay,
  useDroppable,
} from '@dnd-kit/core';
```

2. Add state for item DnD (after activeFolderId state):
```javascript
const [activeItemId, setActiveItemId] = useState(null);
const [itemContainers, setItemContainers] = useState({});
```

3. Add utility functions for state transformation (after menuItems assignment):
```javascript
// Transform context config to DnD container state
const buildItemContainers = () => {
  const containers = { root: [] };

  // Initialize folder containers
  folders.forEach(folder => {
    containers[folder.id] = [];
  });

  // Get assigned items per folder
  items.forEach(item => {
    if (item.folderId && containers[item.folderId]) {
      containers[item.folderId].push(item.itemId);
    }
  });

  // Root items are those not assigned to any folder
  const assignedIds = items.filter(i => i.folderId).map(i => i.itemId);
  containers.root = menuItems
    .filter(m => !assignedIds.includes(m.id))
    .map(m => m.id);

  return containers;
};

// Find which container an item belongs to
const findItemContainer = (itemId) => {
  for (const [containerId, itemIds] of Object.entries(itemContainers)) {
    if (itemIds.includes(itemId)) {
      return containerId;
    }
  }
  return null;
};
```

4. Add useEffect to sync itemContainers when context changes:
```javascript
useEffect(() => {
  setItemContainers(buildItemContainers());
}, [folders, items, menuItems]);
```

5. Create SortableMenuItem component (after SortableFolderRow):
```javascript
// Sortable menu item component
function SortableMenuItem({ itemId, menuItems }) {
  const item = menuItems.find(m => m.id === itemId);
  const {
    attributes,
    listeners,
    setNodeRef,
    transform,
    transition,
    isDragging,
  } = useSortable({ id: itemId });

  const style = {
    transform: CSS.Transform.toString(transform),
    transition,
    opacity: isDragging ? 0.5 : 1,
  };

  if (!item) return null;

  return (
    <div
      ref={setNodeRef}
      style={style}
      className="flex items-center gap-2 py-2 px-3 bg-white border rounded mb-1"
    >
      <button
        {...attributes}
        {...listeners}
        className="cursor-grab active:cursor-grabbing p-1 rounded hover:bg-gray-100"
      >
        <GripVertical className="h-4 w-4 text-gray-400" />
      </button>
      <span className="text-sm font-medium">{item.name}</span>
    </div>
  );
}
```

6. Create DroppableContainer component:
```javascript
// Droppable container for items
function DroppableContainer({ id, children, label, isEmpty }) {
  const { isOver, setNodeRef } = useDroppable({ id });

  return (
    <div
      ref={setNodeRef}
      className={`min-h-[80px] p-3 rounded-lg border-2 transition-colors ${
        isOver ? 'border-blue-400 bg-blue-50' : 'border-gray-200 bg-gray-50'
      }`}
    >
      {label && (
        <div className="text-xs font-medium text-gray-500 mb-2">{label}</div>
      )}
      {children}
      {isEmpty && (
        <div className="text-sm text-gray-400 italic text-center py-4">
          Drop items here
        </div>
      )}
    </div>
  );
}
```

7. Add item drag handlers (after folder drag handlers):
```javascript
const handleItemDragStart = ({ active }) => {
  setActiveItemId(active.id);
};

const handleItemDragOver = ({ active, over }) => {
  if (!over) return;

  const activeContainer = findItemContainer(active.id);
  let overContainer = over.id in itemContainers ? over.id : findItemContainer(over.id);

  if (!activeContainer || !overContainer || activeContainer === overContainer) return;

  // Move item to new container in local state (visual feedback only)
  setItemContainers(prev => {
    const activeItems = [...prev[activeContainer]];
    const overItems = [...prev[overContainer]];

    const activeIndex = activeItems.indexOf(active.id);
    activeItems.splice(activeIndex, 1);

    // Determine position in new container
    let overIndex = overItems.length;
    if (over.id !== overContainer) {
      overIndex = overItems.indexOf(over.id);
      if (overIndex === -1) overIndex = overItems.length;
    }

    overItems.splice(overIndex, 0, active.id);

    return {
      ...prev,
      [activeContainer]: activeItems,
      [overContainer]: overItems,
    };
  });
};

const handleItemDragEnd = async ({ active, over }) => {
  setActiveItemId(null);

  if (!over) {
    // Reset to context state if dropped outside
    setItemContainers(buildItemContainers());
    return;
  }

  const activeContainer = findItemContainer(active.id);
  const overContainer = over.id in itemContainers ? over.id : findItemContainer(over.id);

  if (!activeContainer || !overContainer) {
    setItemContainers(buildItemContainers());
    return;
  }

  // Handle reordering within same container
  if (activeContainer === overContainer && active.id !== over.id) {
    const containerItems = [...itemContainers[activeContainer]];
    const oldIndex = containerItems.indexOf(active.id);
    const newIndex = containerItems.indexOf(over.id);

    if (oldIndex !== -1 && newIndex !== -1) {
      const reordered = arrayMove(containerItems, oldIndex, newIndex);
      setItemContainers(prev => ({
        ...prev,
        [activeContainer]: reordered,
      }));
    }
  }

  // Save to backend
  setSaving(true);
  setLocalError(null);

  try {
    // Convert itemContainers back to items array format
    const updatedItems = [];

    for (const [containerId, itemIds] of Object.entries(itemContainers)) {
      if (containerId === 'root') continue; // Root items have no assignment

      itemIds.forEach(itemId => {
        updatedItems.push({ itemId, folderId: containerId });
      });
    }

    const success = await saveConfig({
      ...config,
      items: updatedItems,
    });

    if (!success) {
      setLocalError("Failed to save item assignment. Please try again.");
      setItemContainers(buildItemContainers()); // Rollback
    }
  } catch (err) {
    console.error("Error saving item assignment:", err);
    setLocalError("An unexpected error occurred. Please try again.");
    setItemContainers(buildItemContainers()); // Rollback
  } finally {
    setSaving(false);
  }
};
```

8. Replace the Menu Items Card content (around line 433-472) with a drag-and-drop interface:
```jsx
<Card className="mt-6">
  <CardHeader>
    <CardTitle>Menu Items</CardTitle>
    <CardDescription>
      Drag items between containers to organize your navigation
    </CardDescription>
  </CardHeader>
  <CardContent>
    <DndContext
      sensors={sensors}
      collisionDetection={closestCenter}
      onDragStart={handleItemDragStart}
      onDragOver={handleItemDragOver}
      onDragEnd={handleItemDragEnd}
    >
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        {/* Root level container */}
        <div>
          <h4 className="text-sm font-medium mb-2">Root Level</h4>
          <DroppableContainer
            id="root"
            isEmpty={(itemContainers.root || []).length === 0}
          >
            <SortableContext
              items={itemContainers.root || []}
              strategy={verticalListSortingStrategy}
            >
              {(itemContainers.root || []).map(itemId => (
                <SortableMenuItem
                  key={itemId}
                  itemId={itemId}
                  menuItems={menuItems}
                />
              ))}
            </SortableContext>
          </DroppableContainer>
        </div>

        {/* Folder containers */}
        <div className="space-y-4">
          {folders
            .sort((a, b) => (a.order || 0) - (b.order || 0))
            .map(folder => (
              <div key={folder.id}>
                <h4 className="text-sm font-medium mb-2 flex items-center gap-2">
                  <FolderOpen className="h-4 w-4" />
                  {folder.name}
                </h4>
                <DroppableContainer
                  id={folder.id}
                  isEmpty={(itemContainers[folder.id] || []).length === 0}
                >
                  <SortableContext
                    items={itemContainers[folder.id] || []}
                    strategy={verticalListSortingStrategy}
                  >
                    {(itemContainers[folder.id] || []).map(itemId => (
                      <SortableMenuItem
                        key={itemId}
                        itemId={itemId}
                        menuItems={menuItems}
                      />
                    ))}
                  </SortableContext>
                </DroppableContainer>
              </div>
            ))}
        </div>
      </div>

      <DragOverlay>
        {activeItemId ? (
          <div className="bg-white border-2 border-blue-400 rounded shadow-lg p-2 flex items-center gap-2">
            <GripVertical className="h-4 w-4 text-gray-400" />
            <span className="text-sm font-medium">
              {menuItems.find(m => m.id === activeItemId)?.name}
            </span>
          </div>
        ) : null}
      </DragOverlay>
    </DndContext>
  </CardContent>
</Card>
```

9. Add useEffect import at top of file if not already present:
```javascript
import { useState, useEffect } from "react";
```
  </action>
  <verify>
1. Run `npm run dev` and navigate to Settings > Navigation tab
2. Verify Root Level container shows unassigned items
3. Verify each folder has its own droppable container
4. Drag an item from Root Level to a folder - verify:
   - Drop target highlights blue on hover
   - Item moves to folder after drop
   - Change persists after page refresh
5. Drag an item from one folder to another
6. Drag an item from folder back to Root Level
7. Drag items within same container to reorder
8. Verify visual DragOverlay follows cursor during drag
  </verify>
  <done>
Items can be dragged between containers with:
- Root Level droppable zone for unassigned items
- Per-folder droppable zones
- Cross-container dragging with onDragOver state updates
- Visual feedback (blue highlight on drop target)
- DragOverlay showing item being dragged
- Changes persisted to backend after drag ends
  </done>
</task>

<task type="auto">
  <name>Task 3: Visual polish and edge case handling</name>
  <files>src/components/settings/NavigationSettings.jsx</files>
  <action>
Add visual polish and handle edge cases for robust DnD experience:

1. Add visual indicator when saving is in progress. Update both DndContexts to disable during save:
- For folder DndContext: Add `disabled={saving}` check in handlers
- For item DndContext: Similar check

Update folder drag handlers to check saving state:
```javascript
const handleFolderDragEnd = async ({ active, over }) => {
  setActiveFolderId(null);

  if (saving) return; // Don't process if already saving
  if (!over || active.id === over.id) return;
  // ... rest of handler
};
```

Update item drag handlers similarly:
```javascript
const handleItemDragEnd = async ({ active, over }) => {
  setActiveItemId(null);

  if (saving) {
    setItemContainers(buildItemContainers());
    return;
  }
  // ... rest of handler
};
```

2. Add grab cursor styles when hovering grip handles. Already added via className, but ensure hover state is clear.

3. Update Preview card to show current state from itemContainers (so preview updates during drag). Replace the Preview Card content to use itemContainers for live preview:
```jsx
<Card className="mt-6">
  <CardHeader>
    <div className="flex items-center justify-between">
      <div>
        <CardTitle>Preview</CardTitle>
        <CardDescription>
          See how your navigation will appear
        </CardDescription>
      </div>
      <Button
        variant="outline"
        onClick={handleReset}
        disabled={saving}
      >
        <RotateCcw className="h-4 w-4 mr-2" />
        Reset to Defaults
      </Button>
    </div>
  </CardHeader>
  <CardContent>
    <div className="space-y-2">
      {/* Root level items */}
      {(itemContainers.root || []).map(itemId => {
        const item = menuItems.find(m => m.id === itemId);
        return item ? (
          <div
            key={itemId}
            className="flex items-center gap-2 py-1.5 px-3 rounded bg-gray-50"
          >
            <span className="text-sm">{item.name}</span>
          </div>
        ) : null;
      })}

      {/* Folders with their items */}
      {folders
        .sort((a, b) => (a.order || 0) - (b.order || 0))
        .map(folder => (
          <div key={folder.id} className="border rounded-lg p-3">
            <div className="flex items-center gap-2 font-medium text-sm">
              <FolderOpen className="h-4 w-4" />
              {folder.name}
              <Badge variant="secondary" className="text-xs">
                {(itemContainers[folder.id] || []).length}
              </Badge>
            </div>
            <div className="ml-6 mt-2 space-y-1">
              {(itemContainers[folder.id] || []).map(itemId => {
                const item = menuItems.find(m => m.id === itemId);
                return item ? (
                  <div key={itemId} className="text-sm text-gray-600 py-0.5">
                    {item.name}
                  </div>
                ) : null;
              })}
              {(itemContainers[folder.id] || []).length === 0 && (
                <div className="text-sm text-gray-400 italic">No items</div>
              )}
            </div>
          </div>
        ))}

      {/* Empty state */}
      {(itemContainers.root || []).length === 0 && folders.length === 0 && (
        <div className="text-center text-gray-500 py-4">
          No items to display
        </div>
      )}
    </div>
  </CardContent>
</Card>
```

4. Add touch-action CSS to prevent scroll interference on mobile. Add to SortableMenuItem and SortableFolderRow grip buttons:
```jsx
<button
  {...attributes}
  {...listeners}
  className="cursor-grab active:cursor-grabbing p-1 rounded hover:bg-gray-100 touch-action-none"
  style={{ touchAction: 'none' }}
>
```

5. Handle case when folder is deleted while items are being dragged - rebuild itemContainers:
The existing useEffect with dependency on [folders, items, menuItems] already handles this.

6. Add aria-label to drag handles for accessibility:
```jsx
<button
  {...attributes}
  {...listeners}
  aria-label="Drag to reorder"
  className="cursor-grab active:cursor-grabbing p-1 rounded hover:bg-gray-100"
  style={{ touchAction: 'none' }}
>
```

7. Ensure empty folders are still droppable targets - the DroppableContainer already has min-height and "Drop items here" message.
  </action>
  <verify>
1. Test drag operations while saving is in progress - should be blocked
2. Test Preview card updates during drag operations
3. Test on mobile/touch device or with touch simulation
4. Test accessibility: Tab to grip, Space to pick up, arrows to move, Space to drop
5. Delete a folder with items - verify items return to root and itemContainers updates
6. Run `npm run lint` - no errors
7. Verify all 4 success criteria from phase requirements:
   - User can drag items between folders and root level
   - User can drag folders to reorder them
   - User can drag items within a folder to reorder them
   - Drag operations provide visual feedback (drop targets highlighted)
  </verify>
  <done>
NavigationSettings has polished DnD with:
- Saving state blocks concurrent drag operations
- Preview card shows live state during drag
- Touch support with touch-action: none
- Accessible drag handles with aria-labels
- Empty folder drop targets always visible
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. **Folder Reordering (FOLDER-07):**
   - Create 3 folders, drag to reorder
   - Refresh page - order persists
   - Use keyboard to reorder (Tab, Space, Arrows, Space)

2. **Item Cross-Container Drag (FOLDER-06):**
   - Drag item from Root Level to a folder
   - Drag item from folder to folder
   - Drag item from folder back to Root Level
   - All changes persist after refresh

3. **Item Within-Folder Reorder (FOLDER-08):**
   - Add 3+ items to a folder
   - Drag to reorder within folder
   - Order persists after refresh

4. **Visual Feedback:**
   - Drop targets highlight blue when item hovers
   - DragOverlay shows dragged item following cursor
   - Grip handles show grab cursor on hover

5. **Edge Cases:**
   - Delete folder with items - items return to root
   - Drag while save in progress - blocked
   - Empty folders are droppable
</verification>

<success_criteria>
- FOLDER-06: Items can be dragged between folders and root level
- FOLDER-07: Folders can be reordered via drag-and-drop
- FOLDER-08: Items within a folder can be reordered via drag-and-drop
- Visual feedback: Drop targets highlighted, DragOverlay visible during drag
- Changes persist to backend after all drag operations
- No console errors during drag operations
- Accessible via keyboard navigation
</success_criteria>

<output>
After completion, create `.planning/phases/30-settings-ui-dnd-enhancement/30-01-SUMMARY.md`
</output>
