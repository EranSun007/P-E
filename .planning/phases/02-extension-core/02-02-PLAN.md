# Plan 02-02: Storage Management and Backend API Client

## Objective
Implement chrome.storage wrapper and backend API client in service worker for reliable data persistence and sync operations.

## Requirements Covered
- EXT-08: Extension storage management
- EXT-09: Backend API communication

## Success Criteria
- [ ] Auth token persists across browser restarts
- [ ] Service worker POSTs test data to backend /api/jira-issues/sync
- [ ] Sync status (success/error/timestamp) stored and retrievable
- [ ] Exponential backoff retry on sync failure

## Wave
2 (depends on 02-01 scaffold)

## Tasks

### Task 1: Create Storage Manager
Wrapper around chrome.storage.local with typed getters/setters.

**File:** `extension/lib/storage.js`

```javascript
/**
 * Storage Manager - Typed wrapper for chrome.storage.local
 *
 * All extension state lives here. Service workers are ephemeral,
 * so we never store state in JS variables.
 */

const STORAGE_KEYS = {
  AUTH_TOKEN: 'authToken',
  BACKEND_URL: 'backendUrl',
  LAST_SYNC: 'lastSync',
  PENDING_ISSUES: 'pendingIssues'
};

const DEFAULTS = {
  [STORAGE_KEYS.BACKEND_URL]: 'https://pe-manager-backend.cfapps.eu01-canary.hana.ondemand.com',
  [STORAGE_KEYS.AUTH_TOKEN]: '',
  [STORAGE_KEYS.LAST_SYNC]: {
    timestamp: null,
    status: 'never',
    issueCount: 0,
    error: null
  },
  [STORAGE_KEYS.PENDING_ISSUES]: []
};

export const Storage = {
  /**
   * Get auth token
   */
  async getAuthToken() {
    const data = await chrome.storage.local.get(STORAGE_KEYS.AUTH_TOKEN);
    return data[STORAGE_KEYS.AUTH_TOKEN] || DEFAULTS[STORAGE_KEYS.AUTH_TOKEN];
  },

  /**
   * Set auth token
   */
  async setAuthToken(token) {
    await chrome.storage.local.set({ [STORAGE_KEYS.AUTH_TOKEN]: token });
  },

  /**
   * Get backend URL
   */
  async getBackendUrl() {
    const data = await chrome.storage.local.get(STORAGE_KEYS.BACKEND_URL);
    return data[STORAGE_KEYS.BACKEND_URL] || DEFAULTS[STORAGE_KEYS.BACKEND_URL];
  },

  /**
   * Set backend URL
   */
  async setBackendUrl(url) {
    await chrome.storage.local.set({ [STORAGE_KEYS.BACKEND_URL]: url });
  },

  /**
   * Get last sync status
   */
  async getLastSync() {
    const data = await chrome.storage.local.get(STORAGE_KEYS.LAST_SYNC);
    return data[STORAGE_KEYS.LAST_SYNC] || DEFAULTS[STORAGE_KEYS.LAST_SYNC];
  },

  /**
   * Update sync status
   */
  async updateSyncStatus(status, issueCount = null, error = null) {
    const lastSync = {
      timestamp: new Date().toISOString(),
      status,
      issueCount: issueCount ?? (await this.getLastSync()).issueCount,
      error
    };
    await chrome.storage.local.set({ [STORAGE_KEYS.LAST_SYNC]: lastSync });
    return lastSync;
  },

  /**
   * Get pending issues (for retry)
   */
  async getPendingIssues() {
    const data = await chrome.storage.local.get(STORAGE_KEYS.PENDING_ISSUES);
    return data[STORAGE_KEYS.PENDING_ISSUES] || DEFAULTS[STORAGE_KEYS.PENDING_ISSUES];
  },

  /**
   * Set pending issues
   */
  async setPendingIssues(issues) {
    await chrome.storage.local.set({ [STORAGE_KEYS.PENDING_ISSUES]: issues });
  },

  /**
   * Clear pending issues after successful sync
   */
  async clearPendingIssues() {
    await chrome.storage.local.set({ [STORAGE_KEYS.PENDING_ISSUES]: [] });
  },

  /**
   * Check if extension is configured
   */
  async isConfigured() {
    const [token, url] = await Promise.all([
      this.getAuthToken(),
      this.getBackendUrl()
    ]);
    return Boolean(token && url);
  },

  /**
   * Get all config for debugging
   */
  async getAll() {
    return chrome.storage.local.get(null);
  },

  /**
   * Initialize defaults (called on install)
   */
  async initDefaults() {
    const current = await chrome.storage.local.get(null);
    const toSet = {};

    for (const [key, value] of Object.entries(DEFAULTS)) {
      if (!(key in current)) {
        toSet[key] = value;
      }
    }

    if (Object.keys(toSet).length > 0) {
      await chrome.storage.local.set(toSet);
    }
  }
};

export { STORAGE_KEYS };
```

### Task 2: Create API Client
Backend API client with retry logic.

**File:** `extension/lib/api.js`

```javascript
/**
 * Backend API Client
 *
 * Handles all communication with P&E Manager backend.
 * Includes exponential backoff retry for failed requests.
 */

import { Storage } from './storage.js';

const MAX_RETRIES = 3;
const INITIAL_RETRY_DELAY = 1000; // 1 second

export class ApiError extends Error {
  constructor(message, status, data) {
    super(message);
    this.name = 'ApiError';
    this.status = status;
    this.data = data;
  }
}

export const Api = {
  /**
   * Make authenticated request to backend
   */
  async request(endpoint, options = {}) {
    const backendUrl = await Storage.getBackendUrl();
    const authToken = await Storage.getAuthToken();

    if (!backendUrl) {
      throw new ApiError('Backend URL not configured', 0, null);
    }

    const url = `${backendUrl}${endpoint}`;
    const headers = {
      'Content-Type': 'application/json',
      ...options.headers
    };

    if (authToken) {
      headers['Authorization'] = `Bearer ${authToken}`;
    }

    const response = await fetch(url, {
      ...options,
      headers
    });

    if (!response.ok) {
      const data = await response.json().catch(() => null);
      throw new ApiError(
        data?.message || `Request failed with status ${response.status}`,
        response.status,
        data
      );
    }

    return response.json();
  },

  /**
   * Test backend connection
   */
  async testConnection() {
    return this.request('/api/health');
  },

  /**
   * Get current user info
   */
  async getMe() {
    return this.request('/api/auth/me');
  },

  /**
   * Sync issues to backend with retry
   */
  async syncIssues(issues) {
    return this.requestWithRetry('/api/jira-issues/sync', {
      method: 'POST',
      body: JSON.stringify({ issues })
    });
  },

  /**
   * Get sync status from backend
   */
  async getSyncStatus() {
    return this.request('/api/jira-issues/status');
  },

  /**
   * Make request with exponential backoff retry
   */
  async requestWithRetry(endpoint, options, retryCount = 0) {
    try {
      return await this.request(endpoint, options);
    } catch (error) {
      // Don't retry auth errors or client errors (4xx)
      if (error.status >= 400 && error.status < 500) {
        throw error;
      }

      // Retry on network errors or server errors (5xx)
      if (retryCount < MAX_RETRIES) {
        const delay = INITIAL_RETRY_DELAY * Math.pow(2, retryCount);
        console.log(`[PE-Jira] Retry ${retryCount + 1}/${MAX_RETRIES} in ${delay}ms`);

        await this.sleep(delay);
        return this.requestWithRetry(endpoint, options, retryCount + 1);
      }

      throw error;
    }
  },

  /**
   * Sleep helper for retry delays
   */
  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
};
```

### Task 3: Update Service Worker to Use Modules
Refactor service worker to use the new storage and API modules.

**File:** `extension/service-worker.js` (updated)

```javascript
/**
 * P&E Manager Jira Sync - Service Worker
 *
 * Handles:
 * - Message routing from popup and content scripts
 * - Backend API communication via Api module
 * - Sync state management via Storage module
 */

import { Storage } from './lib/storage.js';
import { Api, ApiError } from './lib/api.js';

// Message types
const MessageType = {
  SYNC_ISSUES: 'SYNC_ISSUES',
  GET_STATUS: 'GET_STATUS',
  MANUAL_SYNC: 'MANUAL_SYNC',
  TEST_CONNECTION: 'TEST_CONNECTION'
};

// Service worker lifecycle
chrome.runtime.onInstalled.addListener(async (details) => {
  console.log('[PE-Jira] Extension installed:', details.reason);

  // Initialize default storage on fresh install
  if (details.reason === 'install') {
    await Storage.initDefaults();
    console.log('[PE-Jira] Default settings initialized');
  }
});

// Service worker startup (runs on wake from termination)
chrome.runtime.onStartup.addListener(() => {
  console.log('[PE-Jira] Service worker started');
});

// Message handler
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  const source = sender.tab ? `tab:${sender.tab.id}` : 'extension';
  console.log('[PE-Jira] Message:', message.type, 'from:', source);

  // Must return true for async response
  handleMessage(message, sender)
    .then(response => sendResponse(response))
    .catch(error => {
      console.error('[PE-Jira] Handler error:', error);
      sendResponse({ success: false, error: error.message });
    });

  return true; // Keep channel open for async response
});

/**
 * Route messages to appropriate handlers
 */
async function handleMessage(message, sender) {
  switch (message.type) {
    case MessageType.GET_STATUS:
      return await handleGetStatus();

    case MessageType.TEST_CONNECTION:
      return await handleTestConnection();

    case MessageType.SYNC_ISSUES:
      return await handleSyncIssues(message.payload);

    case MessageType.MANUAL_SYNC:
      return await handleManualSync();

    default:
      return { success: false, error: `Unknown message type: ${message.type}` };
  }
}

/**
 * Get current sync status
 */
async function handleGetStatus() {
  const [lastSync, isConfigured] = await Promise.all([
    Storage.getLastSync(),
    Storage.isConfigured()
  ]);

  return {
    success: true,
    data: { lastSync, isConfigured }
  };
}

/**
 * Test connection to backend
 */
async function handleTestConnection() {
  const isConfigured = await Storage.isConfigured();

  if (!isConfigured) {
    return { success: false, error: 'Backend URL or auth token not configured' };
  }

  try {
    const health = await Api.testConnection();
    return { success: true, data: health };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

/**
 * Sync issues from content script
 */
async function handleSyncIssues(issues) {
  if (!issues || !Array.isArray(issues) || issues.length === 0) {
    return { success: false, error: 'No issues to sync' };
  }

  const isConfigured = await Storage.isConfigured();
  if (!isConfigured) {
    // Store pending issues for later
    await Storage.setPendingIssues(issues);
    return { success: false, error: 'Extension not configured' };
  }

  try {
    // Update status to syncing
    await Storage.updateSyncStatus('syncing');

    // Send to backend
    const result = await Api.syncIssues(issues);

    // Update status to success
    await Storage.updateSyncStatus('success', result.total);
    await Storage.clearPendingIssues();

    console.log('[PE-Jira] Sync complete:', result);
    return { success: true, data: result };

  } catch (error) {
    console.error('[PE-Jira] Sync failed:', error);

    // Store for retry
    await Storage.setPendingIssues(issues);
    await Storage.updateSyncStatus('error', null, error.message);

    return { success: false, error: error.message };
  }
}

/**
 * Manual sync trigger - retry pending issues
 */
async function handleManualSync() {
  const pending = await Storage.getPendingIssues();

  if (pending.length === 0) {
    return { success: true, message: 'No pending issues to sync' };
  }

  return handleSyncIssues(pending);
}

console.log('[PE-Jira] Service worker loaded');
```

### Task 4: Update Options Page to Use Storage Module
Refactor options page to import storage module (optional - can use chrome.storage directly).

For simplicity, options page will continue using chrome.storage.local directly since it doesn't need the full Storage wrapper.

### Task 5: Verify Backend CORS for Extension
Check that backend CORS allows chrome-extension:// origin.

**Check:** `server/index.js` CORS configuration

Current CORS is origin-based whitelist. Chrome extensions make requests from `chrome-extension://[extension-id]/*` which won't match the whitelist.

**Solution:** Service worker requests don't need CORS - they're not subject to same-origin policy. The `host_permissions` in manifest.json grants access.

No backend changes needed!

### Task 6: Create Test Script
Simple test to verify sync works.

**File:** `extension/test-sync.js` (for manual testing in console)

```javascript
/**
 * Test script - paste into service worker console to test sync
 */

const testIssues = [
  {
    issue_key: 'TEST-1',
    summary: 'Test issue from extension',
    status: 'To Do',
    assignee_name: 'Test User',
    assignee_id: 'test-user-123',
    story_points: 3,
    priority: 'Medium',
    issue_type: 'Story',
    sprint_name: 'Sprint 1',
    epic_key: null,
    jira_url: 'https://jira.tools.sap/browse/TEST-1'
  },
  {
    issue_key: 'TEST-2',
    summary: 'Another test issue',
    status: 'In Progress',
    assignee_name: 'Test User',
    assignee_id: 'test-user-123',
    story_points: 5,
    priority: 'High',
    issue_type: 'Bug',
    sprint_name: 'Sprint 1',
    epic_key: 'TEST-100',
    jira_url: 'https://jira.tools.sap/browse/TEST-2'
  }
];

// Send test sync message
chrome.runtime.sendMessage(
  { type: 'SYNC_ISSUES', payload: testIssues },
  (response) => console.log('Sync response:', response)
);
```

## Verification Steps

1. Reload extension in Chrome (chrome://extensions → refresh icon)

2. Open service worker console (click "service worker" link)
   - Should see "[PE-Jira] Service worker loaded"

3. Configure settings:
   - Open options page
   - Set backend URL: `http://localhost:3001` (for local testing)
   - Set auth token: Get from dev tools Network tab or use mock token

4. Test connection from popup:
   - Click extension icon
   - Click "Test Connection"
   - Should show "Connection successful!" if backend is running

5. Test sync via console:
   - In service worker console, paste the test script
   - Should see sync response with created/updated counts

6. Verify persistence:
   - Close and reopen Chrome
   - Open popup → should still show configured state
   - Settings should persist

## Files Changed

| File | Action |
|------|--------|
| extension/lib/storage.js | Create |
| extension/lib/api.js | Create |
| extension/service-worker.js | Update (refactor to use modules) |
| extension/test-sync.js | Create (testing only) |

## Estimated Duration
3-5 minutes
