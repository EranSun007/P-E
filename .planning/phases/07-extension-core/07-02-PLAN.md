---
phase: 07-extension-core
plan: 02
type: execute
wave: 2
depends_on: [07-01]
files_modified:
  - extension/content/generic-extractor.js
  - extension/service-worker.js
  - extension/manifest.json
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Generic extractor applies rule selectors to page DOM"
    - "Extracted data is sent to service worker"
    - "Service worker sends captured data to backend inbox"
    - "Extraction handles missing elements gracefully"
  artifacts:
    - path: "extension/content/generic-extractor.js"
      provides: "Rule-based DOM extraction"
      min_lines: 80
    - path: "extension/service-worker.js"
      provides: "CAPTURE_DATA handler that sends to API"
      contains: "handleCaptureData"
  key_links:
    - from: "extension/content/generic-extractor.js"
      to: "extension/service-worker.js"
      via: "chrome.runtime.sendMessage CAPTURE_DATA"
      pattern: "type.*CAPTURE_DATA"
    - from: "extension/service-worker.js"
      to: "extension/lib/api.js"
      via: "Api.sendToInbox()"
      pattern: "Api\\.sendToInbox"
---

<objective>
Create the generic extractor content script and complete the capture flow to backend.

Purpose: This enables rule-based data extraction from any website, replacing hardcoded site-specific extractors.

Output:
- New generic-extractor.js content script that extracts data using rule selectors
- Service worker handleCaptureData implementation that sends to backend
- Complete capture flow: page load -> extract by rule -> send to inbox
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-extension-core/07-RESEARCH.md
@.planning/phases/07-extension-core/07-01-SUMMARY.md

# Files to reference
@extension/service-worker.js
@extension/content/content.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create generic extractor content script</name>
  <files>extension/content/generic-extractor.js</files>
  <action>
Create extension/content/generic-extractor.js - a new content script that is dynamically injected for rule-matched URLs.

Structure (use IIFE pattern for isolation like content.js):

```javascript
(function() {
  'use strict';

  console.log('[PE-Capture] Generic extractor loaded for:', window.location.href);

  // Request rule from service worker
  async function getRuleForUrl() {
    const response = await chrome.runtime.sendMessage({
      type: 'GET_RULE_FOR_URL',
      url: window.location.href
    });
    return response.rule;
  }

  // Extract data using rule selectors
  function extractBySelectors(selectors) {
    const data = {};
    const errors = [];

    for (const config of selectors) {
      const { field_name, selector, type = 'text', attribute, required = false } = config;

      try {
        const element = document.querySelector(selector);

        if (!element) {
          if (required) {
            errors.push(`Required field "${field_name}" not found`);
          }
          data[field_name] = null;
          continue;
        }

        // Extract based on type
        switch (type) {
          case 'text':
            data[field_name] = element.textContent?.trim() || null;
            break;
          case 'html':
            data[field_name] = element.innerHTML?.trim() || null;
            break;
          case 'attribute':
            data[field_name] = element.getAttribute(attribute) || null;
            break;
          case 'href':
            data[field_name] = element.href || element.getAttribute('href') || null;
            break;
          case 'src':
            data[field_name] = element.src || element.getAttribute('src') || null;
            break;
          default:
            data[field_name] = element.textContent?.trim() || null;
        }
      } catch (error) {
        console.warn(`[PE-Capture] Selector error for "${field_name}":`, error);
        data[field_name] = null;
        if (required) {
          errors.push(`Error extracting "${field_name}": ${error.message}`);
        }
      }
    }

    return { data, errors };
  }

  // Build source identifier from URL and data
  function buildSourceIdentifier(url, data, rule) {
    // Allow rule to specify which field to use as identifier
    if (rule.metadata?.identifier_field && data[rule.metadata.identifier_field]) {
      return `${rule.name}:${data[rule.metadata.identifier_field]}`;
    }
    // Default to URL
    return url;
  }

  // Main extraction flow
  async function extractAndSend() {
    try {
      const rule = await getRuleForUrl();

      if (!rule) {
        console.log('[PE-Capture] No rule found for URL');
        return { success: false, reason: 'no_rule' };
      }

      if (!rule.selectors || rule.selectors.length === 0) {
        console.log('[PE-Capture] Rule has no selectors');
        return { success: false, reason: 'no_selectors' };
      }

      console.log('[PE-Capture] Applying rule:', rule.name);

      const { data, errors } = extractBySelectors(rule.selectors);

      // Check for required field errors
      if (errors.length > 0) {
        console.warn('[PE-Capture] Required fields missing:', errors);
        return { success: false, reason: 'missing_required', errors };
      }

      // Check if any data was extracted
      const hasData = Object.values(data).some(v => v !== null);
      if (!hasData) {
        console.log('[PE-Capture] No data extracted');
        return { success: false, reason: 'no_data' };
      }

      // Add metadata
      data._extracted_at = new Date().toISOString();
      data._page_title = document.title;
      data._page_url = window.location.href;

      // Build payload
      const payload = {
        rule_id: rule.id,
        rule_name: rule.name,
        source_url: window.location.href,
        source_identifier: buildSourceIdentifier(window.location.href, data, rule),
        captured_data: data
      };

      console.log('[PE-Capture] Sending to inbox:', payload);

      // Send to service worker
      const response = await chrome.runtime.sendMessage({
        type: 'CAPTURE_DATA',
        payload
      });

      if (response.success) {
        console.log('[PE-Capture] Data captured successfully');
        return { success: true };
      } else {
        console.error('[PE-Capture] Capture failed:', response.error);
        return { success: false, reason: 'send_failed', error: response.error };
      }
    } catch (error) {
      console.error('[PE-Capture] Extraction error:', error);
      return { success: false, reason: 'error', error: error.message };
    }
  }

  // Listen for manual capture trigger from popup
  chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
    if (message.type === 'MANUAL_CAPTURE') {
      console.log('[PE-Capture] Manual capture triggered');
      extractAndSend().then(result => sendResponse(result));
      return true; // Keep channel open for async response
    }
  });

  // Note: Auto-extraction on page load is disabled for v1.1
  // Manual capture only (EXT-05) - auto-capture can be added as opt-in later
  // To enable auto-capture, uncomment: setTimeout(extractAndSend, 1000);

  console.log('[PE-Capture] Ready for manual capture');

})();
```

Key points:
- IIFE pattern for isolation (matches existing content.js)
- Requests rule from service worker via GET_RULE_FOR_URL
- Extracts data using rule.selectors array
- Supports extraction types: text, html, attribute, href, src
- Handles required fields and logs errors
- Sends to service worker via CAPTURE_DATA message
- Listens for MANUAL_CAPTURE message from popup
- NO auto-capture on page load (manual trigger only per research decision)
  </action>
  <verify>
File exists and has correct structure:
`ls -la extension/content/generic-extractor.js`
`grep -c "extractBySelectors\|getRuleForUrl\|CAPTURE_DATA\|MANUAL_CAPTURE" extension/content/generic-extractor.js`
  </verify>
  <done>
- generic-extractor.js exists in extension/content/
- Extracts data using rule selectors
- Sends to service worker via CAPTURE_DATA message
- Listens for MANUAL_CAPTURE message
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement handleCaptureData in service worker</name>
  <files>extension/service-worker.js</files>
  <action>
Complete the handleCaptureData function in service-worker.js (placeholder was added in 07-01):

```javascript
async function handleCaptureData(payload) {
  // Validate payload
  if (!payload || !payload.rule_id || !payload.captured_data) {
    return { success: false, error: 'Invalid capture payload' };
  }

  // Check configuration
  const isConfigured = await Storage.isConfigured();
  if (!isConfigured) {
    console.warn('[PE-Capture] Cannot capture: extension not configured');
    return { success: false, error: 'Extension not configured' };
  }

  try {
    console.log('[PE-Capture] Sending to inbox:', payload.rule_name);

    // Send to backend
    const result = await Api.sendToInbox(payload);

    // Update pending count badge
    await updatePendingBadge();

    console.log('[PE-Capture] Capture successful:', result.id);
    return { success: true, data: result };

  } catch (error) {
    console.error('[PE-Capture] Capture failed:', error);
    return { success: false, error: error.message };
  }
}
```

Also add the updatePendingBadge function:

```javascript
async function updatePendingBadge() {
  try {
    const items = await Api.getInboxItems({ status: 'pending' });
    const count = items.length;

    if (count === 0) {
      await chrome.action.setBadgeText({ text: '' });
    } else {
      await chrome.action.setBadgeText({ text: count > 99 ? '99+' : String(count) });
      await chrome.action.setBadgeBackgroundColor({ color: '#FF9800' }); // Orange for pending
    }

    // Also store count for offline access
    await Storage.setPendingCount(count);
  } catch (error) {
    // Don't fail capture if badge update fails
    console.warn('[PE-Capture] Failed to update badge:', error.message);
  }
}
```

Update the handleMessage switch to call the real handleCaptureData (remove placeholder if any).

Also add MANUAL_CAPTURE forwarding to active tab:

```javascript
case MessageType.MANUAL_CAPTURE:
  return await handleManualCapture();
```

And implement:

```javascript
async function handleManualCapture() {
  try {
    const tabs = await chrome.tabs.query({ active: true, currentWindow: true });
    const activeTab = tabs[0];

    if (!activeTab || !activeTab.id) {
      return { success: false, error: 'No active tab' };
    }

    // Send message to content script
    const response = await chrome.tabs.sendMessage(activeTab.id, { type: 'MANUAL_CAPTURE' });
    return response;

  } catch (error) {
    // Content script may not be loaded on this page
    return { success: false, error: 'No capture script on this page. Check if URL matches a capture rule.' };
  }
}
```
  </action>
  <verify>
Verify implementation:
`grep -E "handleCaptureData|updatePendingBadge|handleManualCapture" extension/service-worker.js`
`grep "Api.sendToInbox" extension/service-worker.js`
  </verify>
  <done>
- handleCaptureData sends payload to Api.sendToInbox()
- handleCaptureData updates badge via updatePendingBadge()
- updatePendingBadge fetches pending count and sets badge
- handleManualCapture forwards to active tab's content script
  </done>
</task>

<task type="auto">
  <name>Task 3: Add generic-extractor.js to web_accessible_resources</name>
  <files>extension/manifest.json</files>
  <action>
Update manifest.json web_accessible_resources to include the generic extractor:

The generic-extractor.js needs to be accessible for dynamic injection. Update the existing web_accessible_resources array:

```json
"web_accessible_resources": [
  {
    "resources": [
      "content/extractors/board.js",
      "content/extractors/backlog.js",
      "content/extractors/detail.js"
    ],
    "matches": ["https://jira.tools.sap/*"]
  },
  {
    "resources": [
      "content/generic-extractor.js"
    ],
    "matches": ["<all_urls>"]
  }
]
```

The generic extractor uses "<all_urls>" because it will be dynamically injected on any URL that matches a user rule.
  </action>
  <verify>
`grep -A10 "web_accessible_resources" extension/manifest.json | grep "generic-extractor"`
  </verify>
  <done>
- manifest.json includes generic-extractor.js in web_accessible_resources
- generic-extractor.js can be injected on any URL
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Reload extension in Chrome
2. Check service worker console for any errors
3. Create a test capture rule in backend (via API or direct DB):
   - url_pattern: "https://example.com/*"
   - selectors: [{ field_name: "title", selector: "h1", type: "text", required: true }]
   - enabled: true
4. Navigate to https://example.com
5. Check service worker console - should see "[PE-Capture] Generic extractor loaded"
6. Open popup and click "Capture" (to be added in 07-03) or trigger via devtools:
   - In content script console: `chrome.runtime.sendMessage({ type: 'MANUAL_CAPTURE' })`
7. Check backend capture_inbox table for new entry
</verification>

<success_criteria>
- [ ] generic-extractor.js exists and follows IIFE pattern
- [ ] generic-extractor.js extracts data using rule selectors
- [ ] generic-extractor.js handles text, html, attribute, href, src extraction types
- [ ] generic-extractor.js sends CAPTURE_DATA to service worker
- [ ] generic-extractor.js listens for MANUAL_CAPTURE message
- [ ] service-worker.js handleCaptureData sends to Api.sendToInbox()
- [ ] service-worker.js updatePendingBadge updates badge with pending count
- [ ] manifest.json includes generic-extractor.js in web_accessible_resources
</success_criteria>

<output>
After completion, create `.planning/phases/07-extension-core/07-02-SUMMARY.md`
</output>
