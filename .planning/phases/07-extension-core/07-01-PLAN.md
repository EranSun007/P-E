---
phase: 07-extension-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - extension/manifest.json
  - extension/lib/storage.js
  - extension/lib/api.js
  - extension/service-worker.js
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Extension fetches capture rules from backend on startup"
    - "Extension fetches capture rules when user triggers refresh"
    - "Rules are cached in chrome.storage.local"
    - "Content scripts are registered for enabled rule URL patterns"
  artifacts:
    - path: "extension/manifest.json"
      provides: "scripting, alarms permissions and optional_host_permissions"
      contains: "scripting"
    - path: "extension/lib/storage.js"
      provides: "Capture rules cache storage"
      exports: ["getCaptureRules", "setCaptureRules", "getPendingCount", "setPendingCount"]
    - path: "extension/lib/api.js"
      provides: "Capture API endpoints"
      exports: ["getCaptureRules", "sendToInbox", "getInboxItems"]
    - path: "extension/service-worker.js"
      provides: "Rule fetching and script registration"
      contains: "registerContentScripts"
  key_links:
    - from: "extension/service-worker.js"
      to: "extension/lib/api.js"
      via: "Api.getCaptureRules()"
      pattern: "Api\\.getCaptureRules"
    - from: "extension/service-worker.js"
      to: "chrome.scripting"
      via: "registerContentScripts"
      pattern: "chrome\\.scripting\\.registerContentScripts"
---

<objective>
Add capture rule fetching and dynamic content script registration to the extension.

Purpose: This is the foundation for rule-based web capture - the extension needs to know what URLs to capture and what selectors to apply.

Output:
- Updated manifest.json with scripting and alarms permissions
- Storage module extended with rule cache methods
- API client extended with capture endpoints
- Service worker handles rule fetching on startup/refresh and registers content scripts dynamically
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-extension-core/07-RESEARCH.md

# Existing extension files to modify
@extension/manifest.json
@extension/lib/storage.js
@extension/lib/api.js
@extension/service-worker.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update manifest and storage module</name>
  <files>
    extension/manifest.json
    extension/lib/storage.js
  </files>
  <action>
Update manifest.json:
- Add "scripting" and "alarms" to permissions array
- Add "optional_host_permissions": ["https://*/*", "http://*/*"] for user-defined capture sites
- Update version to "1.1.0"
- Update name to "P&E Manager Web Capture" (since it's now multi-site, not just Jira)
- Keep existing Jira content_scripts entry for backward compatibility

Update storage.js:
- Add STORAGE_KEYS.CAPTURE_RULES = 'captureRules'
- Add STORAGE_KEYS.PENDING_COUNT = 'pendingInboxCount'
- Add DEFAULTS for both (captureRules: { rules: [], lastRefresh: null }, pendingInboxCount: 0)
- Add getCaptureRules() - returns { rules: [], lastRefresh: null } structure
- Add setCaptureRules(rules) - stores with lastRefresh timestamp
- Add getPendingCount() - returns number
- Add setPendingCount(count) - stores number

Follow existing patterns in storage.js for consistency.
  </action>
  <verify>
Verify syntax: `cd /Users/i306072/Documents/GitHub/P-E/extension && node -c manifest.json 2>/dev/null || cat manifest.json | node -e "JSON.parse(require('fs').readFileSync('/dev/stdin', 'utf8'))"`
Verify storage exports: `grep -E "getCaptureRules|setCaptureRules|getPendingCount|setPendingCount" extension/lib/storage.js`
  </verify>
  <done>
- manifest.json has scripting, alarms permissions and optional_host_permissions
- storage.js exports getCaptureRules, setCaptureRules, getPendingCount, setPendingCount
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend API client with capture endpoints</name>
  <files>extension/lib/api.js</files>
  <action>
Add three new methods to the Api object:

1. getCaptureRules():
   - GET /api/capture-rules?enabled=true
   - Returns array of rule objects
   - Use standard this.request() method

2. sendToInbox(captureData):
   - POST /api/capture-inbox
   - Body: captureData object (rule_id, rule_name, source_url, source_identifier, captured_data)
   - Use this.requestWithRetry() for reliability

3. getInboxItems(filters = {}):
   - GET /api/capture-inbox with query params from filters
   - Typical usage: getInboxItems({ status: 'pending' }) for badge count
   - Use standard this.request() method

Follow existing Api object pattern for consistency.
  </action>
  <verify>
Verify methods exist: `grep -E "getCaptureRules|sendToInbox|getInboxItems" extension/lib/api.js`
  </verify>
  <done>
- api.js has getCaptureRules, sendToInbox, getInboxItems methods
- sendToInbox uses requestWithRetry for reliability
  </done>
</task>

<task type="auto">
  <name>Task 3: Add rule fetching and script registration to service worker</name>
  <files>extension/service-worker.js</files>
  <action>
Add rule fetching and dynamic content script registration to service-worker.js:

1. Add new MessageTypes:
   - GET_RULE_FOR_URL: content script asks for matching rule
   - CAPTURE_DATA: content script sends extracted data
   - REFRESH_RULES: popup requests rule refresh

2. Add constants:
   - RULES_REFRESH_ALARM = 'refresh-capture-rules'
   - RULES_REFRESH_INTERVAL_MINUTES = 30

3. Update onInstalled handler:
   - Call loadRulesFromCache() on install AND update

4. Update onStartup handler:
   - Call loadRulesFromCache()
   - Call scheduleRuleRefresh()

5. Add alarm listener:
   - On RULES_REFRESH_ALARM, call refreshRulesFromBackend()

6. Add helper functions:

async function loadRulesFromCache():
  - Get rules from Storage.getCaptureRules()
  - If rules exist, call registerRuleScripts(rules.rules)

async function refreshRulesFromBackend():
  - Check Storage.isConfigured() first
  - If not configured, return { success: false, error: 'Not configured' }
  - Call Api.getCaptureRules()
  - Store via Storage.setCaptureRules(rules)
  - Call registerRuleScripts(rules)
  - Return { success: true, count: rules.length }

async function registerRuleScripts(rules):
  - Get existing: await chrome.scripting.getRegisteredContentScripts()
  - Filter to only rule-* IDs (preserve any non-rule scripts)
  - Unregister existing rule scripts
  - Filter rules to enabled only
  - Map to script objects: { id: `rule-${rule.id}`, matches: [rule.url_pattern], js: ['content/generic-extractor.js'], runAt: 'document_idle', persistAcrossSessions: true }
  - Register new scripts (if any)
  - Log count registered

async function scheduleRuleRefresh():
  - Create alarm: chrome.alarms.create(RULES_REFRESH_ALARM, { periodInMinutes: RULES_REFRESH_INTERVAL_MINUTES })

7. Add URL matching helper:

function urlMatchesPattern(url, pattern):
  - Convert Chrome match pattern to regex
  - Test URL against regex
  - Return boolean

8. Add message handlers to handleMessage():

case MessageType.GET_RULE_FOR_URL:
  return await handleGetRuleForUrl(message.url);

case MessageType.CAPTURE_DATA:
  return await handleCaptureData(message.payload);

case MessageType.REFRESH_RULES:
  return await refreshRulesFromBackend();

9. Implement handleGetRuleForUrl(url):
  - Get rules from Storage.getCaptureRules()
  - Find first enabled rule where urlMatchesPattern(url, rule.url_pattern) is true
  - Return { rule } or { rule: null }

NOTE: handleCaptureData will be implemented in plan 07-02 (just add placeholder returning { success: false, error: 'Not implemented' })
  </action>
  <verify>
Verify script registration function: `grep -E "registerRuleScripts|getRegisteredContentScripts" extension/service-worker.js`
Verify message types: `grep -E "GET_RULE_FOR_URL|CAPTURE_DATA|REFRESH_RULES" extension/service-worker.js`
Verify alarm: `grep -E "refresh-capture-rules|RULES_REFRESH_ALARM" extension/service-worker.js`
  </verify>
  <done>
- Service worker fetches rules from backend via Api.getCaptureRules()
- Service worker caches rules via Storage.setCaptureRules()
- Service worker registers content scripts dynamically via chrome.scripting.registerContentScripts
- Rules refresh periodically via chrome.alarms
- Message handler for GET_RULE_FOR_URL returns matching rule for URL
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Load extension in Chrome: chrome://extensions -> Load unpacked -> extension/
2. Check for manifest errors (should show no errors)
3. Check service worker console: Right-click extension icon -> Inspect popup -> then click "service worker" link
4. Should see "[PE-Jira] Service worker loaded" and rule loading logs
5. If backend running, rules should be fetched and logged
</verification>

<success_criteria>
- [ ] manifest.json has scripting, alarms permissions
- [ ] manifest.json has optional_host_permissions for https and http
- [ ] storage.js exports rule cache methods (getCaptureRules, setCaptureRules, getPendingCount, setPendingCount)
- [ ] api.js exports capture methods (getCaptureRules, sendToInbox, getInboxItems)
- [ ] service-worker.js loads rules from cache on startup
- [ ] service-worker.js fetches rules from backend via Api.getCaptureRules()
- [ ] service-worker.js registers content scripts via chrome.scripting.registerContentScripts
- [ ] service-worker.js handles GET_RULE_FOR_URL message
- [ ] service-worker.js handles REFRESH_RULES message
</success_criteria>

<output>
After completion, create `.planning/phases/07-extension-core/07-01-SUMMARY.md`
</output>
