---
phase: 08-inbox-mapping-ui
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/api/apiClient.js
  - src/api/entities.js
  - src/pages/CaptureInbox.jsx
  - src/pages/index.jsx
  - src/pages/Layout.jsx
  - src/components/capture/InboxItemDetail.jsx
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can navigate to Capture Inbox page from main navigation"
    - "User sees list of pending captured items with source site, rule name, and timestamp"
    - "User can preview raw captured data for any item"
    - "User can accept or reject individual items (basic flow)"
  artifacts:
    - path: "src/api/apiClient.js"
      provides: "CaptureInbox and EntityMapping API clients"
      contains: "createCaptureInboxClient"
    - path: "src/api/entities.js"
      provides: "CaptureInbox and EntityMapping entity exports"
      contains: "export const CaptureInbox"
    - path: "src/pages/CaptureInbox.jsx"
      provides: "Main inbox page with table and filtering"
      min_lines: 150
    - path: "src/components/capture/InboxItemDetail.jsx"
      provides: "Preview dialog for captured data"
      min_lines: 50
  key_links:
    - from: "src/pages/CaptureInbox.jsx"
      to: "/api/capture-inbox"
      via: "CaptureInbox.list() in useEffect"
      pattern: "CaptureInbox\\.list\\(\\)"
    - from: "src/pages/index.jsx"
      to: "src/pages/CaptureInbox.jsx"
      via: "lazy import and Route"
      pattern: "CaptureInbox.*element.*CaptureInbox"
---

<objective>
Create the Capture Inbox page with API client, table display, filtering, preview dialog, and basic accept/reject functionality.

Purpose: Enable users to view and review captured data from the browser extension before mapping to entities.
Output: Working CaptureInbox page accessible from navigation with table, filters, preview, and basic accept/reject actions.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-inbox-mapping-ui/08-RESEARCH.md

# Key pattern files
@src/api/apiClient.js
@src/api/entities.js
@src/pages/JiraIssues.jsx
@src/pages/index.jsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add CaptureInbox and EntityMapping API clients</name>
  <files>src/api/apiClient.js, src/api/entities.js</files>
  <action>
Extend apiClient.js to add capture inbox and entity mapping clients. Follow the existing pattern from JiraIssue client.

Add to apiClient.js (before the `export const apiClient = {` line):

```javascript
// Create CaptureInbox client with custom methods for inbox workflow
function createCaptureInboxClient() {
  const baseClient = createEntityClient('/capture-inbox');

  return {
    ...baseClient,

    // Accept item with optional entity mapping
    async accept(id, data = {}) {
      return fetchWithAuth(`${API_BASE_URL}/capture-inbox/${id}/accept`, {
        method: 'POST',
        body: JSON.stringify(data),
      });
    },

    // Reject item with optional reason
    async reject(id, data = {}) {
      return fetchWithAuth(`${API_BASE_URL}/capture-inbox/${id}/reject`, {
        method: 'POST',
        body: JSON.stringify(data),
      });
    },

    // Bulk accept multiple items
    async bulkAccept(itemIds, options = {}) {
      return fetchWithAuth(`${API_BASE_URL}/capture-inbox/bulk-accept`, {
        method: 'POST',
        body: JSON.stringify({ item_ids: itemIds, ...options }),
      });
    },

    // Bulk reject multiple items
    async bulkReject(itemIds) {
      return fetchWithAuth(`${API_BASE_URL}/capture-inbox/bulk-reject`, {
        method: 'POST',
        body: JSON.stringify({ item_ids: itemIds }),
      });
    },
  };
}

// Create EntityMapping client with lookup method
function createEntityMappingClient() {
  const baseClient = createEntityClient('/entity-mappings');

  return {
    ...baseClient,

    // Lookup existing mapping by source identifier
    async lookup(sourceIdentifier) {
      return fetchWithAuth(
        `${API_BASE_URL}/entity-mappings/lookup/${encodeURIComponent(sourceIdentifier)}`
      );
    },
  };
}
```

Add to apiClient.entities object:

```javascript
CaptureInbox: createCaptureInboxClient(),
EntityMapping: createEntityMappingClient(),
```

Update src/api/entities.js to export the new clients:

```javascript
// Capture Framework (only available with API mode)
export const CaptureInbox = USE_API ? apiClient.entities.CaptureInbox : {
  list: async () => { throw new Error('Capture inbox not available in local mode'); },
  get: async () => { throw new Error('Capture inbox not available in local mode'); },
  create: async () => { throw new Error('Capture inbox not available in local mode'); },
  accept: async () => { throw new Error('Capture inbox not available in local mode'); },
  reject: async () => { throw new Error('Capture inbox not available in local mode'); },
  bulkAccept: async () => { throw new Error('Capture inbox not available in local mode'); },
  bulkReject: async () => { throw new Error('Capture inbox not available in local mode'); },
};

export const EntityMapping = USE_API ? apiClient.entities.EntityMapping : {
  list: async () => { throw new Error('Entity mapping not available in local mode'); },
  get: async () => { throw new Error('Entity mapping not available in local mode'); },
  create: async () => { throw new Error('Entity mapping not available in local mode'); },
  update: async () => { throw new Error('Entity mapping not available in local mode'); },
  delete: async () => { throw new Error('Entity mapping not available in local mode'); },
  lookup: async (sourceIdentifier) => { throw new Error('Entity mapping not available in local mode'); },
};
```
  </action>
  <verify>
Verify syntax by checking file compiles:
```bash
cd /Users/i306072/Documents/GitHub/P-E && npm run build:client 2>&1 | head -20
```
  </verify>
  <done>
CaptureInbox and EntityMapping clients exported from entities.js with all required methods (list, accept, reject, bulkAccept, bulkReject, lookup).
  </done>
</task>

<task type="auto">
  <name>Task 2: Create InboxItemDetail preview component</name>
  <files>src/components/capture/InboxItemDetail.jsx</files>
  <action>
Create the preview dialog component for viewing captured data details. Follow the JiraIssueDetailDialog pattern.

Create directory and file:

```jsx
// src/components/capture/InboxItemDetail.jsx
import { format } from "date-fns";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Badge } from "@/components/ui/badge";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Globe, Clock, Tag, FileJson } from "lucide-react";

export default function InboxItemDetail({ item, open, onOpenChange }) {
  if (!item) return null;

  // Parse captured_data if it's a string
  const capturedData = typeof item.captured_data === 'string'
    ? JSON.parse(item.captured_data)
    : item.captured_data;

  const formatDate = (dateStr) => {
    if (!dateStr) return "Unknown";
    try {
      return format(new Date(dateStr), "MMM d, yyyy 'at' h:mm a");
    } catch {
      return dateStr;
    }
  };

  const getStatusBadge = (status) => {
    const variants = {
      pending: "bg-yellow-100 text-yellow-800",
      accepted: "bg-green-100 text-green-800",
      rejected: "bg-red-100 text-red-800",
    };
    return variants[status] || "bg-gray-100 text-gray-800";
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-2xl max-h-[80vh]">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            <FileJson className="h-5 w-5" />
            Captured Item Details
          </DialogTitle>
          <DialogDescription>
            Review the captured data before accepting or rejecting.
          </DialogDescription>
        </DialogHeader>

        <ScrollArea className="max-h-[60vh] pr-4">
          <div className="space-y-6">
            {/* Status and metadata */}
            <div className="flex flex-wrap gap-4 text-sm">
              <Badge className={getStatusBadge(item.status)}>
                {item.status}
              </Badge>
              <div className="flex items-center gap-1 text-gray-500">
                <Globe className="h-4 w-4" />
                <span>{item.source_url ? new URL(item.source_url).hostname : "Unknown source"}</span>
              </div>
              <div className="flex items-center gap-1 text-gray-500">
                <Clock className="h-4 w-4" />
                <span>{formatDate(item.captured_at)}</span>
              </div>
            </div>

            {/* Source identifier */}
            {item.source_identifier && (
              <div>
                <h4 className="text-sm font-medium text-gray-500 mb-1">Source Identifier</h4>
                <p className="text-sm">{item.source_identifier}</p>
              </div>
            )}

            {/* Rule name if available */}
            {item.rule_name && (
              <div>
                <h4 className="text-sm font-medium text-gray-500 mb-1">Capture Rule</h4>
                <div className="flex items-center gap-1">
                  <Tag className="h-4 w-4 text-gray-400" />
                  <span className="text-sm">{item.rule_name}</span>
                </div>
              </div>
            )}

            {/* Source URL */}
            {item.source_url && (
              <div>
                <h4 className="text-sm font-medium text-gray-500 mb-1">Source URL</h4>
                <a
                  href={item.source_url}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="text-sm text-blue-600 hover:underline break-all"
                >
                  {item.source_url}
                </a>
              </div>
            )}

            {/* Raw captured data */}
            <div>
              <h4 className="text-sm font-medium text-gray-500 mb-2">Captured Data</h4>
              <div className="bg-gray-50 rounded-lg p-4 border">
                {Object.entries(capturedData || {}).length > 0 ? (
                  <dl className="space-y-3">
                    {Object.entries(capturedData).map(([key, value]) => (
                      <div key={key}>
                        <dt className="text-xs font-medium text-gray-500 uppercase tracking-wide">
                          {key.replace(/_/g, ' ')}
                        </dt>
                        <dd className="mt-1 text-sm text-gray-900 break-words">
                          {typeof value === 'object'
                            ? JSON.stringify(value, null, 2)
                            : String(value)}
                        </dd>
                      </div>
                    ))}
                  </dl>
                ) : (
                  <p className="text-sm text-gray-500 italic">No data captured</p>
                )}
              </div>
            </div>

            {/* Processing timestamps if processed */}
            {item.processed_at && (
              <div className="text-xs text-gray-400 border-t pt-4">
                Processed: {formatDate(item.processed_at)}
              </div>
            )}
          </div>
        </ScrollArea>
      </DialogContent>
    </Dialog>
  );
}
```
  </action>
  <verify>
```bash
ls -la /Users/i306072/Documents/GitHub/P-E/src/components/capture/
```
  </verify>
  <done>
InboxItemDetail.jsx exists in src/components/capture/ and displays item metadata, status, source URL, rule name, and raw captured data in a scrollable dialog.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create CaptureInbox page with table, filtering, and basic actions</name>
  <files>src/pages/CaptureInbox.jsx, src/pages/index.jsx, src/pages/Layout.jsx</files>
  <action>
Create the main CaptureInbox page following JiraIssues.jsx patterns. Include table display, client-side filtering, preview dialog integration, and basic accept/reject buttons.

Create src/pages/CaptureInbox.jsx:

```jsx
import { useState, useEffect, useMemo } from "react";
import { CaptureInbox as CaptureInboxApi } from "@/api/entities";
import { format } from "date-fns";
import {
  Inbox,
  RefreshCw,
  Search,
  Filter,
  X,
  Clock,
  Loader2,
  AlertTriangle,
  Eye,
  Check,
  XCircle,
  Globe,
  ExternalLink,
} from "lucide-react";
import { Card, CardContent } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Alert, AlertDescription } from "@/components/ui/alert";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuCheckboxItem,
} from "@/components/ui/dropdown-menu";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { EmptyState } from "@/components/ui/EmptyState";
import InboxItemDetail from "@/components/capture/InboxItemDetail";

export default function CaptureInboxPage() {
  // Loading and error states
  const [loading, setLoading] = useState(true);
  const [actionLoading, setActionLoading] = useState(null); // Track which item is being processed
  const [error, setError] = useState(null);

  // Data state
  const [items, setItems] = useState([]);

  // Filter state
  const [filters, setFilters] = useState({
    status: "pending", // Default to pending items
    search: "",
    source: null,
  });

  // Preview dialog state
  const [selectedItem, setSelectedItem] = useState(null);
  const [showDetailDialog, setShowDetailDialog] = useState(false);

  // Load data on mount
  useEffect(() => {
    loadData();
  }, []);

  const loadData = async () => {
    setLoading(true);
    setError(null);
    try {
      const data = await CaptureInboxApi.list();
      setItems(data || []);
    } catch (err) {
      console.error("Failed to load capture inbox:", err);
      setError(err.message || "Failed to load capture inbox");
    } finally {
      setLoading(false);
    }
  };

  // Extract unique sources for filter dropdown
  const uniqueSources = useMemo(() => {
    const sources = new Set();
    items.forEach(item => {
      if (item.source_url) {
        try {
          sources.add(new URL(item.source_url).hostname);
        } catch {
          // Invalid URL, skip
        }
      }
    });
    return Array.from(sources).sort();
  }, [items]);

  // Client-side filtering
  const filteredItems = useMemo(() => {
    return items.filter(item => {
      // Status filter
      if (filters.status && filters.status !== "all" && item.status !== filters.status) {
        return false;
      }

      // Search filter (source_identifier or captured data)
      if (filters.search) {
        const searchLower = filters.search.toLowerCase();
        const matchesIdentifier = item.source_identifier?.toLowerCase().includes(searchLower);
        const matchesUrl = item.source_url?.toLowerCase().includes(searchLower);
        const matchesRule = item.rule_name?.toLowerCase().includes(searchLower);
        if (!matchesIdentifier && !matchesUrl && !matchesRule) {
          return false;
        }
      }

      // Source filter
      if (filters.source) {
        try {
          const itemHost = new URL(item.source_url).hostname;
          if (itemHost !== filters.source) return false;
        } catch {
          return false;
        }
      }

      return true;
    });
  }, [items, filters]);

  // Calculate summary stats
  const stats = useMemo(() => {
    const total = items.length;
    const pending = items.filter(i => i.status === "pending").length;
    const accepted = items.filter(i => i.status === "accepted").length;
    const rejected = items.filter(i => i.status === "rejected").length;
    return { total, pending, accepted, rejected };
  }, [items]);

  // Format timestamp
  const formatTime = (dateStr) => {
    if (!dateStr) return "Unknown";
    try {
      return format(new Date(dateStr), "MMM d, h:mm a");
    } catch {
      return dateStr;
    }
  };

  // Get hostname from URL
  const getHostname = (url) => {
    if (!url) return "Unknown";
    try {
      return new URL(url).hostname;
    } catch {
      return url;
    }
  };

  // Status badge colors
  const getStatusBadge = (status) => {
    const variants = {
      pending: "bg-yellow-100 text-yellow-800",
      accepted: "bg-green-100 text-green-800",
      rejected: "bg-red-100 text-red-800",
    };
    return variants[status] || "bg-gray-100 text-gray-800";
  };

  // Check if any filters are active
  const hasActiveFilters = filters.status !== "pending" ||
                           filters.search !== "" ||
                           filters.source !== null;

  // Clear all filters
  const clearFilters = () => {
    setFilters({ status: "pending", search: "", source: null });
  };

  // Handle accept (basic - just accept without mapping for now)
  const handleAccept = async (item) => {
    setActionLoading(item.id);
    try {
      await CaptureInboxApi.accept(item.id, {});
      // Update local state
      setItems(prev => prev.map(i =>
        i.id === item.id ? { ...i, status: "accepted" } : i
      ));
    } catch (err) {
      console.error("Failed to accept item:", err);
      setError("Failed to accept item");
    } finally {
      setActionLoading(null);
    }
  };

  // Handle reject
  const handleReject = async (item) => {
    setActionLoading(item.id);
    try {
      await CaptureInboxApi.reject(item.id, {});
      // Update local state
      setItems(prev => prev.map(i =>
        i.id === item.id ? { ...i, status: "rejected" } : i
      ));
    } catch (err) {
      console.error("Failed to reject item:", err);
      setError("Failed to reject item");
    } finally {
      setActionLoading(null);
    }
  };

  // Handle preview click
  const handlePreview = (item) => {
    setSelectedItem(item);
    setShowDetailDialog(true);
  };

  return (
    <div className="p-6">
      <div className="max-w-7xl mx-auto space-y-6">
        {/* Header */}
        <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4">
          <div>
            <h1 className="text-3xl font-bold flex items-center gap-2">
              <Inbox className="h-8 w-8" />
              Capture Inbox
            </h1>
            <p className="text-gray-500 mt-1">
              Review and process captured data from websites
            </p>
          </div>
          <Button variant="outline" onClick={loadData} disabled={loading}>
            {loading ? (
              <Loader2 className="h-4 w-4 mr-2 animate-spin" />
            ) : (
              <RefreshCw className="h-4 w-4 mr-2" />
            )}
            Refresh
          </Button>
        </div>

        {/* Error alert */}
        {error && (
          <Alert variant="destructive">
            <AlertTriangle className="h-4 w-4" />
            <AlertDescription>{error}</AlertDescription>
          </Alert>
        )}

        {loading ? (
          <div className="flex items-center justify-center py-12">
            <Loader2 className="h-8 w-8 animate-spin text-gray-400" />
            <span className="ml-2 text-gray-500">Loading capture inbox...</span>
          </div>
        ) : (
          <div className="space-y-4">
            {/* Summary Cards */}
            <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
              <Card>
                <CardContent className="pt-6">
                  <div className="text-2xl font-bold">{stats.total}</div>
                  <p className="text-sm text-gray-500">Total Items</p>
                </CardContent>
              </Card>
              <Card>
                <CardContent className="pt-6">
                  <div className="text-2xl font-bold text-yellow-600">{stats.pending}</div>
                  <p className="text-sm text-gray-500">Pending</p>
                </CardContent>
              </Card>
              <Card>
                <CardContent className="pt-6">
                  <div className="text-2xl font-bold text-green-600">{stats.accepted}</div>
                  <p className="text-sm text-gray-500">Accepted</p>
                </CardContent>
              </Card>
              <Card>
                <CardContent className="pt-6">
                  <div className="text-2xl font-bold text-red-600">{stats.rejected}</div>
                  <p className="text-sm text-gray-500">Rejected</p>
                </CardContent>
              </Card>
            </div>

            {/* Filter Bar */}
            <Card>
              <CardContent className="py-4">
                <div className="flex flex-wrap items-center gap-3">
                  {/* Search input */}
                  <div className="relative flex-1 min-w-[200px] max-w-sm">
                    <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-gray-400" />
                    <Input
                      placeholder="Search by identifier, URL, or rule..."
                      value={filters.search}
                      onChange={(e) => setFilters(prev => ({ ...prev, search: e.target.value }))}
                      className="pl-9"
                    />
                  </div>

                  {/* Status filter */}
                  <Select
                    value={filters.status || "all"}
                    onValueChange={(value) => setFilters(prev => ({
                      ...prev,
                      status: value === "all" ? null : value
                    }))}
                  >
                    <SelectTrigger className="w-[140px]">
                      <SelectValue placeholder="All Status" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="all">All Status</SelectItem>
                      <SelectItem value="pending">Pending</SelectItem>
                      <SelectItem value="accepted">Accepted</SelectItem>
                      <SelectItem value="rejected">Rejected</SelectItem>
                    </SelectContent>
                  </Select>

                  {/* Source filter */}
                  {uniqueSources.length > 0 && (
                    <Select
                      value={filters.source || "all"}
                      onValueChange={(value) => setFilters(prev => ({
                        ...prev,
                        source: value === "all" ? null : value
                      }))}
                    >
                      <SelectTrigger className="w-[180px]">
                        <SelectValue placeholder="All Sources" />
                      </SelectTrigger>
                      <SelectContent>
                        <SelectItem value="all">All Sources</SelectItem>
                        {uniqueSources.map((source) => (
                          <SelectItem key={source} value={source}>
                            {source}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                  )}

                  {/* Clear filters */}
                  {hasActiveFilters && (
                    <Button variant="ghost" size="sm" onClick={clearFilters}>
                      <X className="h-4 w-4 mr-1" />
                      Clear filters
                    </Button>
                  )}
                </div>
              </CardContent>
            </Card>

            {/* Items Table */}
            <Card>
              <CardContent className="p-0">
                {filteredItems.length === 0 ? (
                  <EmptyState
                    icon={Inbox}
                    title="No Items Found"
                    description={hasActiveFilters
                      ? "No items match your current filters."
                      : "Your capture inbox is empty. Captured data will appear here."}
                    size="md"
                  />
                ) : (
                  <Table>
                    <TableHeader>
                      <TableRow>
                        <TableHead className="w-[180px]">Source</TableHead>
                        <TableHead>Identifier</TableHead>
                        <TableHead>Rule</TableHead>
                        <TableHead>Captured</TableHead>
                        <TableHead>Status</TableHead>
                        <TableHead className="text-right">Actions</TableHead>
                      </TableRow>
                    </TableHeader>
                    <TableBody>
                      {filteredItems.map((item) => (
                        <TableRow key={item.id}>
                          <TableCell>
                            <div className="flex items-center gap-1 text-sm">
                              <Globe className="h-4 w-4 text-gray-400 flex-shrink-0" />
                              <span className="truncate max-w-[140px]" title={item.source_url}>
                                {getHostname(item.source_url)}
                              </span>
                            </div>
                          </TableCell>
                          <TableCell>
                            <span className="text-sm font-medium truncate max-w-[200px] block">
                              {item.source_identifier || "—"}
                            </span>
                          </TableCell>
                          <TableCell>
                            <span className="text-sm text-gray-600">
                              {item.rule_name || "—"}
                            </span>
                          </TableCell>
                          <TableCell>
                            <div className="flex items-center gap-1 text-sm text-gray-500">
                              <Clock className="h-3 w-3" />
                              {formatTime(item.captured_at)}
                            </div>
                          </TableCell>
                          <TableCell>
                            <Badge className={getStatusBadge(item.status)}>
                              {item.status}
                            </Badge>
                          </TableCell>
                          <TableCell>
                            <div className="flex items-center justify-end gap-1">
                              {/* Preview button */}
                              <Button
                                variant="ghost"
                                size="sm"
                                onClick={() => handlePreview(item)}
                                title="Preview"
                              >
                                <Eye className="h-4 w-4" />
                              </Button>

                              {/* Accept/Reject buttons only for pending items */}
                              {item.status === "pending" && (
                                <>
                                  <Button
                                    variant="ghost"
                                    size="sm"
                                    onClick={() => handleAccept(item)}
                                    disabled={actionLoading === item.id}
                                    title="Accept"
                                    className="text-green-600 hover:text-green-700 hover:bg-green-50"
                                  >
                                    {actionLoading === item.id ? (
                                      <Loader2 className="h-4 w-4 animate-spin" />
                                    ) : (
                                      <Check className="h-4 w-4" />
                                    )}
                                  </Button>
                                  <Button
                                    variant="ghost"
                                    size="sm"
                                    onClick={() => handleReject(item)}
                                    disabled={actionLoading === item.id}
                                    title="Reject"
                                    className="text-red-600 hover:text-red-700 hover:bg-red-50"
                                  >
                                    <XCircle className="h-4 w-4" />
                                  </Button>
                                </>
                              )}

                              {/* Link to source */}
                              {item.source_url && (
                                <Button
                                  variant="ghost"
                                  size="sm"
                                  asChild
                                  title="Open source"
                                >
                                  <a href={item.source_url} target="_blank" rel="noopener noreferrer">
                                    <ExternalLink className="h-4 w-4" />
                                  </a>
                                </Button>
                              )}
                            </div>
                          </TableCell>
                        </TableRow>
                      ))}
                    </TableBody>
                  </Table>
                )}
              </CardContent>
            </Card>
          </div>
        )}

        {/* Preview Dialog */}
        <InboxItemDetail
          item={selectedItem}
          open={showDetailDialog}
          onOpenChange={setShowDetailDialog}
        />
      </div>
    </div>
  );
}
```

Update src/pages/index.jsx to add the route:

1. Add lazy import after line ~56 (after Releases):
```javascript
const CaptureInbox = lazy(() => retryImport(() => import(/* webpackChunkName: "pages-capture-inbox" */ "./CaptureInbox"), 3, 1000));
```

2. Add to PAGES object (after Releases entry):
```javascript
CaptureInbox: CaptureInbox,
```

3. Add Route in Routes component (after /releases route):
```jsx
<Route path="/capture-inbox" element={<CaptureInbox />} />
```

Update src/pages/Layout.jsx to add navigation item:

Find the navigation items array and add after the Jira entry (or appropriate location):
```javascript
{ name: "Capture Inbox", href: "/capture-inbox", icon: Inbox }
```

Make sure to import Inbox from lucide-react at the top of Layout.jsx.
  </action>
  <verify>
```bash
cd /Users/i306072/Documents/GitHub/P-E && npm run build:client 2>&1 | tail -30
```
Then verify the route works:
```bash
grep -n "capture-inbox" /Users/i306072/Documents/GitHub/P-E/src/pages/index.jsx
```
  </verify>
  <done>
CaptureInbox.jsx page exists at src/pages/CaptureInbox.jsx with:
- Table displaying source, identifier, rule name, timestamp, status
- Client-side filtering by status, search, and source
- Preview dialog integration via InboxItemDetail
- Basic accept/reject buttons for pending items
- Route registered at /capture-inbox
- Navigation item added to Layout.jsx
  </done>
</task>

</tasks>

<verification>
1. Build succeeds: `npm run build:client` completes without errors
2. API client exports: `CaptureInbox` and `EntityMapping` exported from entities.js
3. Route works: `/capture-inbox` path registered in index.jsx
4. Navigation visible: Capture Inbox item appears in sidebar/navigation
5. Preview works: InboxItemDetail component exists and imports correctly
</verification>

<success_criteria>
- [ ] CaptureInbox API client has list, accept, reject, bulkAccept, bulkReject methods
- [ ] EntityMapping API client has list, create, update, delete, lookup methods
- [ ] CaptureInbox page displays table with source, identifier, rule, timestamp, status
- [ ] Filter bar allows filtering by status, search text, and source hostname
- [ ] Preview button opens InboxItemDetail dialog showing captured data
- [ ] Accept/Reject buttons update item status (basic flow without entity mapping)
- [ ] Route /capture-inbox is registered and navigable
- [ ] Build completes without errors
</success_criteria>

<output>
After completion, create `.planning/phases/08-inbox-mapping-ui/08-01-SUMMARY.md`
</output>
