---
phase: 08-inbox-mapping-ui
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - src/pages/CaptureInbox.jsx
  - src/components/capture/EntityMappingDialog.jsx
  - src/components/capture/InboxBulkActions.jsx
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can select target entity type (project, team_member, service) when accepting"
    - "User can search and select specific entity to map captured item to"
    - "Auto-suggest shows entities with similar names to captured data"
    - "User can optionally save mapping for future auto-application"
    - "User can select multiple items with checkboxes"
    - "User can bulk accept or bulk reject selected items"
    - "Bulk actions show confirmation before executing"
  artifacts:
    - path: "src/components/capture/EntityMappingDialog.jsx"
      provides: "Entity mapping dialog with type selection and auto-suggest"
      min_lines: 120
    - path: "src/components/capture/InboxBulkActions.jsx"
      provides: "Bulk action toolbar with confirmation"
      min_lines: 60
    - path: "src/pages/CaptureInbox.jsx"
      provides: "Updated page with checkbox selection and bulk actions"
      contains: "selectedIds"
  key_links:
    - from: "src/pages/CaptureInbox.jsx"
      to: "src/components/capture/EntityMappingDialog.jsx"
      via: "EntityMappingDialog component"
      pattern: "EntityMappingDialog"
    - from: "src/pages/CaptureInbox.jsx"
      to: "src/components/capture/InboxBulkActions.jsx"
      via: "InboxBulkActions component"
      pattern: "InboxBulkActions"
    - from: "src/components/capture/EntityMappingDialog.jsx"
      to: "/api/capture-inbox/:id/accept"
      via: "CaptureInbox.accept() call"
      pattern: "CaptureInbox\\.accept"
---

<objective>
Add entity mapping dialog with type selection and auto-suggest, integrate with accept flow, and implement bulk selection with bulk accept/reject operations.

Purpose: Enable users to map captured data to P&E Manager entities and efficiently process multiple items at once.
Output: Working entity mapping dialog with auto-suggest, checkbox selection in table, and bulk action toolbar with confirmations.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-inbox-mapping-ui/08-RESEARCH.md
@.planning/phases/08-inbox-mapping-ui/08-01-SUMMARY.md

# Key pattern files
@src/components/jira/AssigneeMappingDialog.jsx
@src/pages/CaptureInbox.jsx
@src/api/entities.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create EntityMappingDialog component</name>
  <files>src/components/capture/EntityMappingDialog.jsx</files>
  <action>
Create the entity mapping dialog following AssigneeMappingDialog pattern. Include entity type selection, searchable entity list with auto-suggest, and option to save mapping.

```jsx
// src/components/capture/EntityMappingDialog.jsx
import { useState, useEffect, useMemo } from "react";
import { Project, TeamMember } from "@/api/entities";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Checkbox } from "@/components/ui/checkbox";
import { Label } from "@/components/ui/label";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Badge } from "@/components/ui/badge";
import {
  Loader2,
  Link2,
  Search,
  Sparkles,
  FolderKanban,
  User,
  Server,
} from "lucide-react";

// Entity type configuration
const ENTITY_TYPES = {
  project: {
    label: "Project",
    icon: FolderKanban,
    nameField: "name",
  },
  team_member: {
    label: "Team Member",
    icon: User,
    nameField: "name",
  },
  service: {
    label: "Service",
    icon: Server,
    nameField: "name",
  },
};

// Simple case-insensitive contains matching for auto-suggest
function findBestMatches(searchName, entities, nameField, limit = 3) {
  if (!searchName || !entities?.length) return [];

  const searchLower = searchName.toLowerCase().trim();
  const words = searchLower.split(/\s+/);

  // Score entities by match quality
  const scored = entities.map(entity => {
    const name = (entity[nameField] || "").toLowerCase();
    let score = 0;

    // Exact match gets highest score
    if (name === searchLower) {
      score = 100;
    }
    // Contains full search term
    else if (name.includes(searchLower)) {
      score = 80;
    }
    // Starts with search term
    else if (name.startsWith(searchLower)) {
      score = 70;
    }
    // Contains all words
    else if (words.every(w => name.includes(w))) {
      score = 50 + (words.length * 5);
    }
    // Contains some words
    else {
      const matchingWords = words.filter(w => name.includes(w));
      score = matchingWords.length * 10;
    }

    return { entity, score };
  });

  // Return top matches with score > 0
  return scored
    .filter(s => s.score > 0)
    .sort((a, b) => b.score - a.score)
    .slice(0, limit)
    .map(s => s.entity);
}

export default function EntityMappingDialog({
  open,
  onOpenChange,
  inboxItem,
  onAccept,
}) {
  const [entityType, setEntityType] = useState("project");
  const [entities, setEntities] = useState([]);
  const [selectedEntity, setSelectedEntity] = useState(null);
  const [createMapping, setCreateMapping] = useState(true);
  const [loading, setLoading] = useState(false);
  const [saving, setSaving] = useState(false);
  const [error, setError] = useState(null);
  const [searchQuery, setSearchQuery] = useState("");

  // Load entities when dialog opens or type changes
  useEffect(() => {
    if (open && entityType) {
      loadEntities(entityType);
    }
  }, [open, entityType]);

  // Reset state when dialog opens
  useEffect(() => {
    if (open) {
      setSelectedEntity(null);
      setSearchQuery("");
      setError(null);
      setCreateMapping(true);
    }
  }, [open]);

  const loadEntities = async (type) => {
    setLoading(true);
    setError(null);
    try {
      let data = [];
      switch (type) {
        case "project":
          data = await Project.list();
          break;
        case "team_member":
          data = await TeamMember.list();
          break;
        case "service":
          // Services might use Project with a filter or separate endpoint
          // For now, treat as projects (can be refined)
          data = await Project.list();
          break;
        default:
          data = [];
      }
      setEntities(data || []);
    } catch (err) {
      console.error("Failed to load entities:", err);
      setError("Failed to load entities");
      setEntities([]);
    } finally {
      setLoading(false);
    }
  };

  // Get the name from captured data for auto-suggest
  const capturedName = useMemo(() => {
    if (!inboxItem?.captured_data) return "";
    const data = typeof inboxItem.captured_data === "string"
      ? JSON.parse(inboxItem.captured_data)
      : inboxItem.captured_data;
    // Try common name fields
    return data.name || data.title || data.summary || inboxItem.source_identifier || "";
  }, [inboxItem]);

  // Auto-suggested entities based on captured name
  const suggestedEntities = useMemo(() => {
    const config = ENTITY_TYPES[entityType];
    if (!config || !capturedName) return [];
    return findBestMatches(capturedName, entities, config.nameField);
  }, [capturedName, entities, entityType]);

  // Filtered entities based on search
  const filteredEntities = useMemo(() => {
    if (!searchQuery.trim()) return entities;
    const config = ENTITY_TYPES[entityType];
    const searchLower = searchQuery.toLowerCase();
    return entities.filter(e =>
      (e[config.nameField] || "").toLowerCase().includes(searchLower)
    );
  }, [entities, searchQuery, entityType]);

  const handleAccept = async () => {
    setSaving(true);
    setError(null);
    try {
      await onAccept({
        inboxItemId: inboxItem.id,
        target_entity_type: entityType,
        target_entity_id: selectedEntity?.id,
        create_mapping: createMapping && selectedEntity?.id,
      });
      onOpenChange(false);
    } catch (err) {
      console.error("Failed to accept item:", err);
      setError(err.message || "Failed to accept item");
    } finally {
      setSaving(false);
    }
  };

  const handleClose = () => {
    if (!saving) {
      onOpenChange(false);
    }
  };

  const TypeIcon = ENTITY_TYPES[entityType]?.icon || FolderKanban;

  return (
    <Dialog open={open} onOpenChange={handleClose}>
      <DialogContent className="sm:max-w-lg">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            <Link2 className="h-5 w-5" />
            Map to Entity
          </DialogTitle>
          <DialogDescription>
            Choose how to map this captured item to a P&E Manager entity.
          </DialogDescription>
        </DialogHeader>

        {error && (
          <Alert variant="destructive">
            <AlertDescription>{error}</AlertDescription>
          </Alert>
        )}

        <div className="space-y-4 py-4">
          {/* Captured item info */}
          {capturedName && (
            <div className="bg-gray-50 rounded-lg p-3 text-sm">
              <span className="text-gray-500">Captured: </span>
              <span className="font-medium">{capturedName}</span>
            </div>
          )}

          {/* Entity type selector */}
          <div className="space-y-2">
            <Label>Entity Type</Label>
            <Select value={entityType} onValueChange={setEntityType}>
              <SelectTrigger>
                <SelectValue placeholder="Select entity type" />
              </SelectTrigger>
              <SelectContent>
                {Object.entries(ENTITY_TYPES).map(([key, config]) => {
                  const Icon = config.icon;
                  return (
                    <SelectItem key={key} value={key}>
                      <div className="flex items-center gap-2">
                        <Icon className="h-4 w-4" />
                        {config.label}
                      </div>
                    </SelectItem>
                  );
                })}
              </SelectContent>
            </Select>
          </div>

          {/* Entity search and selection */}
          <div className="space-y-2">
            <Label>Select Entity</Label>
            <div className="relative">
              <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-gray-400" />
              <Input
                placeholder={`Search ${ENTITY_TYPES[entityType]?.label || "entities"}...`}
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
                className="pl-9"
              />
            </div>

            {loading ? (
              <div className="flex items-center justify-center py-8">
                <Loader2 className="h-6 w-6 animate-spin text-gray-400" />
              </div>
            ) : (
              <ScrollArea className="h-[200px] border rounded-lg">
                <div className="p-2 space-y-1">
                  {/* Auto-suggested entities */}
                  {suggestedEntities.length > 0 && !searchQuery && (
                    <>
                      <div className="flex items-center gap-1 px-2 py-1 text-xs text-gray-500">
                        <Sparkles className="h-3 w-3" />
                        Suggested matches
                      </div>
                      {suggestedEntities.map((entity) => (
                        <button
                          key={`suggested-${entity.id}`}
                          onClick={() => setSelectedEntity(entity)}
                          className={`w-full text-left px-3 py-2 rounded-md text-sm transition-colors flex items-center gap-2 ${
                            selectedEntity?.id === entity.id
                              ? "bg-blue-100 text-blue-900"
                              : "bg-blue-50 hover:bg-blue-100 text-blue-800"
                          }`}
                        >
                          <TypeIcon className="h-4 w-4 flex-shrink-0" />
                          <span className="truncate">{entity[ENTITY_TYPES[entityType].nameField]}</span>
                          <Badge variant="secondary" className="ml-auto text-xs">
                            Suggested
                          </Badge>
                        </button>
                      ))}
                      <div className="border-t my-2" />
                    </>
                  )}

                  {/* All entities (filtered) */}
                  {filteredEntities.length === 0 ? (
                    <p className="text-center text-gray-500 text-sm py-4">
                      No {ENTITY_TYPES[entityType]?.label || "entities"} found
                    </p>
                  ) : (
                    filteredEntities
                      .filter(e => !suggestedEntities.find(s => s.id === e.id) || searchQuery)
                      .map((entity) => (
                        <button
                          key={entity.id}
                          onClick={() => setSelectedEntity(entity)}
                          className={`w-full text-left px-3 py-2 rounded-md text-sm transition-colors flex items-center gap-2 ${
                            selectedEntity?.id === entity.id
                              ? "bg-primary/10 text-primary"
                              : "hover:bg-gray-100"
                          }`}
                        >
                          <TypeIcon className="h-4 w-4 flex-shrink-0 text-gray-400" />
                          <span className="truncate">{entity[ENTITY_TYPES[entityType].nameField]}</span>
                        </button>
                      ))
                  )}
                </div>
              </ScrollArea>
            )}
          </div>

          {/* Selected entity display */}
          {selectedEntity && (
            <div className="flex items-center gap-2 p-2 bg-green-50 rounded-lg text-sm">
              <TypeIcon className="h-4 w-4 text-green-600" />
              <span className="text-green-800">
                Selected: <strong>{selectedEntity[ENTITY_TYPES[entityType].nameField]}</strong>
              </span>
            </div>
          )}

          {/* Create mapping checkbox */}
          <div className="flex items-center gap-2 pt-2">
            <Checkbox
              id="create-mapping"
              checked={createMapping}
              onCheckedChange={setCreateMapping}
              disabled={!selectedEntity}
            />
            <Label
              htmlFor="create-mapping"
              className={`text-sm ${!selectedEntity ? "text-gray-400" : ""}`}
            >
              Remember this mapping for future captures
            </Label>
          </div>
        </div>

        <DialogFooter className="gap-2 sm:gap-0">
          <Button variant="outline" onClick={handleClose} disabled={saving}>
            Cancel
          </Button>
          <Button onClick={handleAccept} disabled={saving}>
            {saving ? (
              <>
                <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                Accepting...
              </>
            ) : (
              "Accept"
            )}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
```
  </action>
  <verify>
```bash
ls -la /Users/i306072/Documents/GitHub/P-E/src/components/capture/EntityMappingDialog.jsx
```
  </verify>
  <done>
EntityMappingDialog.jsx exists in src/components/capture/ with:
- Entity type selection (project, team_member, service)
- Searchable entity list
- Auto-suggest based on name similarity
- Selected entity display
- "Remember mapping" checkbox option
- Accept and Cancel buttons with loading state
  </done>
</task>

<task type="auto">
  <name>Task 2: Create InboxBulkActions component</name>
  <files>src/components/capture/InboxBulkActions.jsx</files>
  <action>
Create the bulk actions toolbar component with selection count, bulk accept, bulk reject buttons, and confirmation dialogs.

```jsx
// src/components/capture/InboxBulkActions.jsx
import { useState } from "react";
import { Button } from "@/components/ui/button";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Badge } from "@/components/ui/badge";
import {
  Check,
  XCircle,
  X,
  Loader2,
  FolderKanban,
  User,
  Server,
} from "lucide-react";

// Entity type options for bulk accept
const ENTITY_TYPES = [
  { value: "project", label: "Project", icon: FolderKanban },
  { value: "team_member", label: "Team Member", icon: User },
  { value: "service", label: "Service", icon: Server },
];

export default function InboxBulkActions({
  selectedCount,
  onBulkAccept,
  onBulkReject,
  onClearSelection,
  loading = false,
}) {
  const [showRejectConfirm, setShowRejectConfirm] = useState(false);
  const [showAcceptConfirm, setShowAcceptConfirm] = useState(false);
  const [bulkEntityType, setBulkEntityType] = useState("project");

  const handleBulkAccept = async () => {
    setShowAcceptConfirm(false);
    await onBulkAccept(bulkEntityType);
  };

  const handleBulkReject = async () => {
    setShowRejectConfirm(false);
    await onBulkReject();
  };

  return (
    <>
      <div className="flex items-center gap-3 p-3 bg-blue-50 border border-blue-200 rounded-lg mb-4">
        {/* Selection count */}
        <Badge variant="secondary" className="bg-blue-100 text-blue-800">
          {selectedCount} selected
        </Badge>

        {/* Entity type for bulk accept */}
        <Select value={bulkEntityType} onValueChange={setBulkEntityType}>
          <SelectTrigger className="w-[150px] h-8 text-sm">
            <SelectValue placeholder="Entity type" />
          </SelectTrigger>
          <SelectContent>
            {ENTITY_TYPES.map((type) => {
              const Icon = type.icon;
              return (
                <SelectItem key={type.value} value={type.value}>
                  <div className="flex items-center gap-2">
                    <Icon className="h-4 w-4" />
                    {type.label}
                  </div>
                </SelectItem>
              );
            })}
          </SelectContent>
        </Select>

        {/* Bulk accept button */}
        <Button
          size="sm"
          variant="default"
          onClick={() => setShowAcceptConfirm(true)}
          disabled={loading}
          className="bg-green-600 hover:bg-green-700"
        >
          {loading ? (
            <Loader2 className="h-4 w-4 mr-1 animate-spin" />
          ) : (
            <Check className="h-4 w-4 mr-1" />
          )}
          Accept All
        </Button>

        {/* Bulk reject button */}
        <Button
          size="sm"
          variant="destructive"
          onClick={() => setShowRejectConfirm(true)}
          disabled={loading}
        >
          {loading ? (
            <Loader2 className="h-4 w-4 mr-1 animate-spin" />
          ) : (
            <XCircle className="h-4 w-4 mr-1" />
          )}
          Reject All
        </Button>

        {/* Clear selection */}
        <Button
          size="sm"
          variant="ghost"
          onClick={onClearSelection}
          disabled={loading}
          className="ml-auto"
        >
          <X className="h-4 w-4 mr-1" />
          Clear
        </Button>
      </div>

      {/* Bulk Accept Confirmation */}
      <AlertDialog open={showAcceptConfirm} onOpenChange={setShowAcceptConfirm}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Accept {selectedCount} items?</AlertDialogTitle>
            <AlertDialogDescription>
              This will accept {selectedCount} selected item{selectedCount !== 1 ? "s" : ""} and mark them as {" "}
              <strong>{ENTITY_TYPES.find(t => t.value === bulkEntityType)?.label}</strong> type.
              <br /><br />
              No entity mappings will be created. Use individual accept for specific mappings.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Cancel</AlertDialogCancel>
            <AlertDialogAction
              onClick={handleBulkAccept}
              className="bg-green-600 hover:bg-green-700"
            >
              Accept {selectedCount} Items
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>

      {/* Bulk Reject Confirmation */}
      <AlertDialog open={showRejectConfirm} onOpenChange={setShowRejectConfirm}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Reject {selectedCount} items?</AlertDialogTitle>
            <AlertDialogDescription>
              This will reject {selectedCount} selected item{selectedCount !== 1 ? "s" : ""}.
              Rejected items will be marked as rejected but not deleted.
              <br /><br />
              This action can be reviewed later but the items will no longer appear in pending.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Cancel</AlertDialogCancel>
            <AlertDialogAction
              onClick={handleBulkReject}
              className="bg-red-600 hover:bg-red-700"
            >
              Reject {selectedCount} Items
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </>
  );
}
```
  </action>
  <verify>
```bash
ls -la /Users/i306072/Documents/GitHub/P-E/src/components/capture/InboxBulkActions.jsx
```
  </verify>
  <done>
InboxBulkActions.jsx exists in src/components/capture/ with:
- Selection count badge
- Entity type selector for bulk accept
- Bulk accept button with confirmation dialog
- Bulk reject button with confirmation dialog
- Clear selection button
- Loading state support
  </done>
</task>

<task type="auto">
  <name>Task 3: Update CaptureInbox page with selection and entity mapping</name>
  <files>src/pages/CaptureInbox.jsx</files>
  <action>
Update the CaptureInbox page to integrate checkbox selection, bulk actions toolbar, and entity mapping dialog. This extends the page created in 08-01.

Replace src/pages/CaptureInbox.jsx with the updated version:

```jsx
import { useState, useEffect, useMemo } from "react";
import { CaptureInbox as CaptureInboxApi } from "@/api/entities";
import { format } from "date-fns";
import {
  Inbox,
  RefreshCw,
  Search,
  X,
  Clock,
  Loader2,
  AlertTriangle,
  Eye,
  Check,
  XCircle,
  Globe,
  ExternalLink,
  Link2,
} from "lucide-react";
import { Card, CardContent } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Checkbox } from "@/components/ui/checkbox";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { EmptyState } from "@/components/ui/EmptyState";
import InboxItemDetail from "@/components/capture/InboxItemDetail";
import EntityMappingDialog from "@/components/capture/EntityMappingDialog";
import InboxBulkActions from "@/components/capture/InboxBulkActions";

export default function CaptureInboxPage() {
  // Loading and error states
  const [loading, setLoading] = useState(true);
  const [actionLoading, setActionLoading] = useState(null);
  const [bulkLoading, setBulkLoading] = useState(false);
  const [error, setError] = useState(null);

  // Data state
  const [items, setItems] = useState([]);

  // Filter state
  const [filters, setFilters] = useState({
    status: "pending",
    search: "",
    source: null,
  });

  // Selection state
  const [selectedIds, setSelectedIds] = useState(new Set());

  // Preview dialog state
  const [selectedItem, setSelectedItem] = useState(null);
  const [showDetailDialog, setShowDetailDialog] = useState(false);

  // Entity mapping dialog state
  const [mappingItem, setMappingItem] = useState(null);
  const [showMappingDialog, setShowMappingDialog] = useState(false);

  // Load data on mount
  useEffect(() => {
    loadData();
  }, []);

  // Clear selection when filters change
  useEffect(() => {
    setSelectedIds(new Set());
  }, [filters]);

  const loadData = async () => {
    setLoading(true);
    setError(null);
    try {
      const data = await CaptureInboxApi.list();
      setItems(data || []);
    } catch (err) {
      console.error("Failed to load capture inbox:", err);
      setError(err.message || "Failed to load capture inbox");
    } finally {
      setLoading(false);
    }
  };

  // Extract unique sources for filter dropdown
  const uniqueSources = useMemo(() => {
    const sources = new Set();
    items.forEach(item => {
      if (item.source_url) {
        try {
          sources.add(new URL(item.source_url).hostname);
        } catch {
          // Invalid URL, skip
        }
      }
    });
    return Array.from(sources).sort();
  }, [items]);

  // Client-side filtering
  const filteredItems = useMemo(() => {
    return items.filter(item => {
      // Status filter
      if (filters.status && filters.status !== "all" && item.status !== filters.status) {
        return false;
      }

      // Search filter
      if (filters.search) {
        const searchLower = filters.search.toLowerCase();
        const matchesIdentifier = item.source_identifier?.toLowerCase().includes(searchLower);
        const matchesUrl = item.source_url?.toLowerCase().includes(searchLower);
        const matchesRule = item.rule_name?.toLowerCase().includes(searchLower);
        if (!matchesIdentifier && !matchesUrl && !matchesRule) {
          return false;
        }
      }

      // Source filter
      if (filters.source) {
        try {
          const itemHost = new URL(item.source_url).hostname;
          if (itemHost !== filters.source) return false;
        } catch {
          return false;
        }
      }

      return true;
    });
  }, [items, filters]);

  // Only pending items can be selected
  const selectableItems = useMemo(() => {
    return filteredItems.filter(item => item.status === "pending");
  }, [filteredItems]);

  // Calculate summary stats
  const stats = useMemo(() => {
    const total = items.length;
    const pending = items.filter(i => i.status === "pending").length;
    const accepted = items.filter(i => i.status === "accepted").length;
    const rejected = items.filter(i => i.status === "rejected").length;
    return { total, pending, accepted, rejected };
  }, [items]);

  // Selection helpers
  const allSelected = selectableItems.length > 0 &&
    selectableItems.every(item => selectedIds.has(item.id));
  const someSelected = selectedIds.size > 0 && !allSelected;

  const handleSelectAll = (checked) => {
    if (checked) {
      setSelectedIds(new Set(selectableItems.map(i => i.id)));
    } else {
      setSelectedIds(new Set());
    }
  };

  const handleSelectItem = (id, checked) => {
    const newSet = new Set(selectedIds);
    if (checked) {
      newSet.add(id);
    } else {
      newSet.delete(id);
    }
    setSelectedIds(newSet);
  };

  // Format timestamp
  const formatTime = (dateStr) => {
    if (!dateStr) return "Unknown";
    try {
      return format(new Date(dateStr), "MMM d, h:mm a");
    } catch {
      return dateStr;
    }
  };

  // Get hostname from URL
  const getHostname = (url) => {
    if (!url) return "Unknown";
    try {
      return new URL(url).hostname;
    } catch {
      return url;
    }
  };

  // Status badge colors
  const getStatusBadge = (status) => {
    const variants = {
      pending: "bg-yellow-100 text-yellow-800",
      accepted: "bg-green-100 text-green-800",
      rejected: "bg-red-100 text-red-800",
    };
    return variants[status] || "bg-gray-100 text-gray-800";
  };

  // Check if any filters are active
  const hasActiveFilters = filters.status !== "pending" ||
                           filters.search !== "" ||
                           filters.source !== null;

  // Clear all filters
  const clearFilters = () => {
    setFilters({ status: "pending", search: "", source: null });
  };

  // Handle accept with mapping dialog
  const handleAcceptWithMapping = (item) => {
    setMappingItem(item);
    setShowMappingDialog(true);
  };

  // Handle accept from mapping dialog
  const handleMappingAccept = async ({ inboxItemId, target_entity_type, target_entity_id, create_mapping }) => {
    setActionLoading(inboxItemId);
    try {
      await CaptureInboxApi.accept(inboxItemId, {
        target_entity_type,
        target_entity_id,
        create_mapping,
      });
      // Update local state
      setItems(prev => prev.map(i =>
        i.id === inboxItemId ? { ...i, status: "accepted" } : i
      ));
      // Remove from selection if selected
      setSelectedIds(prev => {
        const newSet = new Set(prev);
        newSet.delete(inboxItemId);
        return newSet;
      });
    } catch (err) {
      console.error("Failed to accept item:", err);
      throw err; // Re-throw to show error in dialog
    } finally {
      setActionLoading(null);
    }
  };

  // Handle quick reject (no mapping needed)
  const handleReject = async (item) => {
    setActionLoading(item.id);
    try {
      await CaptureInboxApi.reject(item.id, {});
      setItems(prev => prev.map(i =>
        i.id === item.id ? { ...i, status: "rejected" } : i
      ));
      setSelectedIds(prev => {
        const newSet = new Set(prev);
        newSet.delete(item.id);
        return newSet;
      });
    } catch (err) {
      console.error("Failed to reject item:", err);
      setError("Failed to reject item");
    } finally {
      setActionLoading(null);
    }
  };

  // Handle preview click
  const handlePreview = (item) => {
    setSelectedItem(item);
    setShowDetailDialog(true);
  };

  // Handle bulk accept
  const handleBulkAccept = async (entityType) => {
    setBulkLoading(true);
    setError(null);
    try {
      const ids = Array.from(selectedIds);
      await CaptureInboxApi.bulkAccept(ids, { target_entity_type: entityType });
      // Update local state
      setItems(prev => prev.map(i =>
        selectedIds.has(i.id) ? { ...i, status: "accepted" } : i
      ));
      setSelectedIds(new Set());
    } catch (err) {
      console.error("Failed to bulk accept:", err);
      setError("Failed to accept selected items");
    } finally {
      setBulkLoading(false);
    }
  };

  // Handle bulk reject
  const handleBulkReject = async () => {
    setBulkLoading(true);
    setError(null);
    try {
      const ids = Array.from(selectedIds);
      await CaptureInboxApi.bulkReject(ids);
      // Update local state
      setItems(prev => prev.map(i =>
        selectedIds.has(i.id) ? { ...i, status: "rejected" } : i
      ));
      setSelectedIds(new Set());
    } catch (err) {
      console.error("Failed to bulk reject:", err);
      setError("Failed to reject selected items");
    } finally {
      setBulkLoading(false);
    }
  };

  return (
    <div className="p-6">
      <div className="max-w-7xl mx-auto space-y-6">
        {/* Header */}
        <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4">
          <div>
            <h1 className="text-3xl font-bold flex items-center gap-2">
              <Inbox className="h-8 w-8" />
              Capture Inbox
            </h1>
            <p className="text-gray-500 mt-1">
              Review and process captured data from websites
            </p>
          </div>
          <Button variant="outline" onClick={loadData} disabled={loading}>
            {loading ? (
              <Loader2 className="h-4 w-4 mr-2 animate-spin" />
            ) : (
              <RefreshCw className="h-4 w-4 mr-2" />
            )}
            Refresh
          </Button>
        </div>

        {/* Error alert */}
        {error && (
          <Alert variant="destructive">
            <AlertTriangle className="h-4 w-4" />
            <AlertDescription>{error}</AlertDescription>
          </Alert>
        )}

        {loading ? (
          <div className="flex items-center justify-center py-12">
            <Loader2 className="h-8 w-8 animate-spin text-gray-400" />
            <span className="ml-2 text-gray-500">Loading capture inbox...</span>
          </div>
        ) : (
          <div className="space-y-4">
            {/* Summary Cards */}
            <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
              <Card>
                <CardContent className="pt-6">
                  <div className="text-2xl font-bold">{stats.total}</div>
                  <p className="text-sm text-gray-500">Total Items</p>
                </CardContent>
              </Card>
              <Card>
                <CardContent className="pt-6">
                  <div className="text-2xl font-bold text-yellow-600">{stats.pending}</div>
                  <p className="text-sm text-gray-500">Pending</p>
                </CardContent>
              </Card>
              <Card>
                <CardContent className="pt-6">
                  <div className="text-2xl font-bold text-green-600">{stats.accepted}</div>
                  <p className="text-sm text-gray-500">Accepted</p>
                </CardContent>
              </Card>
              <Card>
                <CardContent className="pt-6">
                  <div className="text-2xl font-bold text-red-600">{stats.rejected}</div>
                  <p className="text-sm text-gray-500">Rejected</p>
                </CardContent>
              </Card>
            </div>

            {/* Filter Bar */}
            <Card>
              <CardContent className="py-4">
                <div className="flex flex-wrap items-center gap-3">
                  {/* Search input */}
                  <div className="relative flex-1 min-w-[200px] max-w-sm">
                    <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-gray-400" />
                    <Input
                      placeholder="Search by identifier, URL, or rule..."
                      value={filters.search}
                      onChange={(e) => setFilters(prev => ({ ...prev, search: e.target.value }))}
                      className="pl-9"
                    />
                  </div>

                  {/* Status filter */}
                  <Select
                    value={filters.status || "all"}
                    onValueChange={(value) => setFilters(prev => ({
                      ...prev,
                      status: value === "all" ? null : value
                    }))}
                  >
                    <SelectTrigger className="w-[140px]">
                      <SelectValue placeholder="All Status" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="all">All Status</SelectItem>
                      <SelectItem value="pending">Pending</SelectItem>
                      <SelectItem value="accepted">Accepted</SelectItem>
                      <SelectItem value="rejected">Rejected</SelectItem>
                    </SelectContent>
                  </Select>

                  {/* Source filter */}
                  {uniqueSources.length > 0 && (
                    <Select
                      value={filters.source || "all"}
                      onValueChange={(value) => setFilters(prev => ({
                        ...prev,
                        source: value === "all" ? null : value
                      }))}
                    >
                      <SelectTrigger className="w-[180px]">
                        <SelectValue placeholder="All Sources" />
                      </SelectTrigger>
                      <SelectContent>
                        <SelectItem value="all">All Sources</SelectItem>
                        {uniqueSources.map((source) => (
                          <SelectItem key={source} value={source}>
                            {source}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                  )}

                  {/* Clear filters */}
                  {hasActiveFilters && (
                    <Button variant="ghost" size="sm" onClick={clearFilters}>
                      <X className="h-4 w-4 mr-1" />
                      Clear filters
                    </Button>
                  )}
                </div>
              </CardContent>
            </Card>

            {/* Bulk Actions Bar */}
            {selectedIds.size > 0 && (
              <InboxBulkActions
                selectedCount={selectedIds.size}
                onBulkAccept={handleBulkAccept}
                onBulkReject={handleBulkReject}
                onClearSelection={() => setSelectedIds(new Set())}
                loading={bulkLoading}
              />
            )}

            {/* Items Table */}
            <Card>
              <CardContent className="p-0">
                {filteredItems.length === 0 ? (
                  <EmptyState
                    icon={Inbox}
                    title="No Items Found"
                    description={hasActiveFilters
                      ? "No items match your current filters."
                      : "Your capture inbox is empty. Captured data will appear here."}
                    size="md"
                  />
                ) : (
                  <Table>
                    <TableHeader>
                      <TableRow>
                        <TableHead className="w-12">
                          <Checkbox
                            checked={allSelected}
                            // Note: Radix Checkbox uses data-state, not indeterminate prop
                            // We show partial state via different styling
                            onCheckedChange={handleSelectAll}
                            disabled={selectableItems.length === 0}
                            className={someSelected ? "data-[state=checked]:bg-blue-400" : ""}
                          />
                        </TableHead>
                        <TableHead className="w-[180px]">Source</TableHead>
                        <TableHead>Identifier</TableHead>
                        <TableHead>Rule</TableHead>
                        <TableHead>Captured</TableHead>
                        <TableHead>Status</TableHead>
                        <TableHead className="text-right">Actions</TableHead>
                      </TableRow>
                    </TableHeader>
                    <TableBody>
                      {filteredItems.map((item) => (
                        <TableRow
                          key={item.id}
                          className={selectedIds.has(item.id) ? "bg-blue-50" : ""}
                        >
                          <TableCell>
                            <Checkbox
                              checked={selectedIds.has(item.id)}
                              onCheckedChange={(checked) => handleSelectItem(item.id, checked)}
                              disabled={item.status !== "pending"}
                            />
                          </TableCell>
                          <TableCell>
                            <div className="flex items-center gap-1 text-sm">
                              <Globe className="h-4 w-4 text-gray-400 flex-shrink-0" />
                              <span className="truncate max-w-[140px]" title={item.source_url}>
                                {getHostname(item.source_url)}
                              </span>
                            </div>
                          </TableCell>
                          <TableCell>
                            <span className="text-sm font-medium truncate max-w-[200px] block">
                              {item.source_identifier || "—"}
                            </span>
                          </TableCell>
                          <TableCell>
                            <span className="text-sm text-gray-600">
                              {item.rule_name || "—"}
                            </span>
                          </TableCell>
                          <TableCell>
                            <div className="flex items-center gap-1 text-sm text-gray-500">
                              <Clock className="h-3 w-3" />
                              {formatTime(item.captured_at)}
                            </div>
                          </TableCell>
                          <TableCell>
                            <Badge className={getStatusBadge(item.status)}>
                              {item.status}
                            </Badge>
                          </TableCell>
                          <TableCell>
                            <div className="flex items-center justify-end gap-1">
                              {/* Preview button */}
                              <Button
                                variant="ghost"
                                size="sm"
                                onClick={() => handlePreview(item)}
                                title="Preview"
                              >
                                <Eye className="h-4 w-4" />
                              </Button>

                              {/* Accept/Reject buttons only for pending items */}
                              {item.status === "pending" && (
                                <>
                                  <Button
                                    variant="ghost"
                                    size="sm"
                                    onClick={() => handleAcceptWithMapping(item)}
                                    disabled={actionLoading === item.id}
                                    title="Accept with mapping"
                                    className="text-green-600 hover:text-green-700 hover:bg-green-50"
                                  >
                                    {actionLoading === item.id ? (
                                      <Loader2 className="h-4 w-4 animate-spin" />
                                    ) : (
                                      <Link2 className="h-4 w-4" />
                                    )}
                                  </Button>
                                  <Button
                                    variant="ghost"
                                    size="sm"
                                    onClick={() => handleReject(item)}
                                    disabled={actionLoading === item.id}
                                    title="Reject"
                                    className="text-red-600 hover:text-red-700 hover:bg-red-50"
                                  >
                                    <XCircle className="h-4 w-4" />
                                  </Button>
                                </>
                              )}

                              {/* Link to source */}
                              {item.source_url && (
                                <Button
                                  variant="ghost"
                                  size="sm"
                                  asChild
                                  title="Open source"
                                >
                                  <a href={item.source_url} target="_blank" rel="noopener noreferrer">
                                    <ExternalLink className="h-4 w-4" />
                                  </a>
                                </Button>
                              )}
                            </div>
                          </TableCell>
                        </TableRow>
                      ))}
                    </TableBody>
                  </Table>
                )}
              </CardContent>
            </Card>
          </div>
        )}

        {/* Preview Dialog */}
        <InboxItemDetail
          item={selectedItem}
          open={showDetailDialog}
          onOpenChange={setShowDetailDialog}
        />

        {/* Entity Mapping Dialog */}
        <EntityMappingDialog
          open={showMappingDialog}
          onOpenChange={setShowMappingDialog}
          inboxItem={mappingItem}
          onAccept={handleMappingAccept}
        />
      </div>
    </div>
  );
}
```
  </action>
  <verify>
```bash
cd /Users/i306072/Documents/GitHub/P-E && npm run build:client 2>&1 | tail -30
```
  </verify>
  <done>
CaptureInbox.jsx updated with:
- Checkbox column in table header and rows
- selectedIds state management with Set
- Select all/none functionality (only selectable pending items)
- Selection cleared when filters change
- InboxBulkActions toolbar appears when items selected
- Accept button now opens EntityMappingDialog
- Bulk accept and bulk reject with confirmation dialogs
- Build completes without errors
  </done>
</task>

</tasks>

<verification>
1. Build succeeds: `npm run build:client` completes without errors
2. EntityMappingDialog exists: File at src/components/capture/EntityMappingDialog.jsx
3. InboxBulkActions exists: File at src/components/capture/InboxBulkActions.jsx
4. Selection works: Checkbox column visible in table, select all works
5. Bulk actions visible: Toolbar appears when items are selected
6. Entity mapping: Accept button opens dialog with type selection and entity list
7. Auto-suggest works: Suggested entities appear based on captured name similarity
</verification>

<success_criteria>
- [ ] EntityMappingDialog shows entity type selection (project, team_member, service)
- [ ] EntityMappingDialog shows searchable entity list
- [ ] EntityMappingDialog shows auto-suggested entities based on name similarity
- [ ] EntityMappingDialog has "Remember mapping" checkbox
- [ ] InboxBulkActions shows selection count and entity type selector
- [ ] InboxBulkActions has Accept All and Reject All buttons
- [ ] Bulk reject shows AlertDialog confirmation before executing
- [ ] Bulk accept shows AlertDialog confirmation before executing
- [ ] CaptureInbox table has checkbox column
- [ ] Select all checkbox only selects pending items
- [ ] Selection clears when filters change
- [ ] Bulk actions toolbar appears when items are selected
- [ ] Build completes without errors
</success_criteria>

<output>
After completion, create `.planning/phases/08-inbox-mapping-ui/08-02-SUMMARY.md`
</output>
