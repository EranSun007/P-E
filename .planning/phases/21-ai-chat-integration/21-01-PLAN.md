---
phase: 21-ai-chat-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/ai/ChatInput.jsx
  - src/contexts/AIContext.jsx
  - server/services/AIChatService.js
  - server/routes/ai.js
autonomous: true

must_haves:
  truths:
    - "User can type /search [query] in chat and see knowledge base results"
    - "AI automatically queries knowledge base when user asks code/implementation questions"
    - "AI responses include relevant code context when knowledge base has matches"
  artifacts:
    - path: "src/components/ai/ChatInput.jsx"
      provides: "Command detection for /search"
      contains: "/search"
    - path: "src/contexts/AIContext.jsx"
      provides: "searchKnowledgeBase function"
      exports: ["searchKnowledgeBase"]
    - path: "server/services/AIChatService.js"
      provides: "Automatic knowledge context injection"
      contains: "chatWithKnowledgeContext"
  key_links:
    - from: "src/components/ai/ChatInput.jsx"
      to: "AIContext.searchKnowledgeBase"
      via: "onSearchCommand prop"
      pattern: "onSearchCommand"
    - from: "server/services/AIChatService.js"
      to: "MCPService.searchCode"
      via: "import and call"
      pattern: "MCPService\\.searchCode"
---

<objective>
Add /search command detection and automatic knowledge context injection to AI chat

Purpose: Enable users to explicitly search the knowledge base from chat with /search command, and automatically enrich AI responses with relevant code context when questions suggest code/implementation needs (CHAT-01, CHAT-02, CHAT-04).

Output: ChatInput with command detection, AIContext with searchKnowledgeBase, backend with automatic RAG context injection
</objective>

<execution_context>
@/Users/i306072/.claude/get-shit-done/workflows/execute-plan.md
@/Users/i306072/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-ai-chat-integration/21-RESEARCH.md

# Existing infrastructure
@src/components/ai/ChatInput.jsx
@src/contexts/AIContext.jsx
@server/services/AIChatService.js
@server/services/MCPService.js
@src/api/apiClient.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add command detection to ChatInput</name>
  <files>src/components/ai/ChatInput.jsx</files>
  <action>
Modify ChatInput.jsx to detect /search commands before sending to AI:

1. Add new prop `onSearchCommand` for handling search commands
2. Create KNOWN_COMMANDS object: `{ '/search': true, '/help': true }`
3. Create parseCommand function that:
   - Matches pattern /^(\/\w+)\s+(.*)$/
   - Returns null if no match (normal message)
   - Returns { error } if command not in KNOWN_COMMANDS
   - Returns { command, args } for valid commands

4. Modify handleSubmit to:
   - Parse command from trimmed value
   - If /search command with args, call onSearchCommand(args) and clear input
   - If unknown command, show toast error "Unknown command: /cmd. Try /help"
   - Otherwise proceed with normal onSend flow

5. Add /help command that shows available commands in a toast

Use optional chaining for onSearchCommand to maintain backward compatibility.
  </action>
  <verify>
- ESLint passes: `npm run lint -- --quiet src/components/ai/ChatInput.jsx`
- Type "/search test query" in chat input calls onSearchCommand with "test query"
- Type "/unknown" shows error toast
- Normal messages still work via onSend
  </verify>
  <done>ChatInput detects /search command and passes query to onSearchCommand prop</done>
</task>

<task type="auto">
  <name>Task 2: Add searchKnowledgeBase to AIContext</name>
  <files>src/contexts/AIContext.jsx, src/components/ai/AIChatPanel.jsx</files>
  <action>
Modify AIContext.jsx to add knowledge base search capability:

1. Import apiClient from '@/api/apiClient'

2. Add searchKnowledgeBase callback:
```javascript
const searchKnowledgeBase = useCallback(async (query) => {
  setIsLoading(true);
  setError(null);

  // Add user command message to chat
  const commandMessage = { role: 'user', content: `/search ${query}`, type: 'command' };
  setMessages(prev => [...prev, commandMessage]);

  try {
    // Query both code and docs in parallel
    const [codeResults, docsResults] = await Promise.all([
      apiClient.knowledge.searchCode({ query, limit: 3, threshold: 0.6 }),
      apiClient.knowledge.searchDocs({ query, limit: 3, threshold: 0.6 })
    ]);

    // Add search result message
    const resultMessage = {
      role: 'assistant',
      type: 'search_result',
      query,
      codeResults: codeResults.results || [],
      docsResults: docsResults.results || []
    };
    setMessages(prev => [...prev, resultMessage]);
  } catch (err) {
    console.error('Knowledge base search failed:', err);
    setError('Knowledge search failed: ' + err.message);
  } finally {
    setIsLoading(false);
  }
}, []);
```

3. Add searchKnowledgeBase to context value

4. Update AIChatPanel.jsx:
   - Destructure searchKnowledgeBase from useAI()
   - Pass onSearchCommand={searchKnowledgeBase} to ChatInput
  </action>
  <verify>
- ESLint passes for both files
- /search command in chat triggers parallel API calls to /api/knowledge/search/code and /api/knowledge/search/docs
- Results appear in messages array with type: 'search_result'
  </verify>
  <done>AIContext provides searchKnowledgeBase function, AIChatPanel wires it to ChatInput</done>
</task>

<task type="auto">
  <name>Task 3: Add automatic knowledge context injection to backend</name>
  <files>server/services/AIChatService.js, server/routes/ai.js</files>
  <action>
Modify AIChatService.js to automatically inject knowledge context:

1. Import MCPService at top of file:
   `import MCPService from './MCPService.js';`

2. Add detectCodeQuestion method:
```javascript
/**
 * Detect if message is a code/implementation question
 * @param {string} message - User message
 * @returns {boolean}
 */
detectCodeQuestion(message) {
  const codeKeywords = [
    /how (do|does|to|can) (i|we|you)/i,
    /implement(ing|ation)?/i,
    /\b(write|create|build|make|develop)\b/i,
    /\b(code|function|class|method|component)\b/i,
    /\b(API|endpoint|route|handler)\b/i,
    /\b(error|bug|issue|problem|fix)\b/i,
    /\b(js|jsx|ts|tsx|python|java|go|rust)\b/i
  ];
  return codeKeywords.some(regex => regex.test(message));
}
```

3. Add formatKnowledgeContext method:
```javascript
/**
 * Format knowledge base results for AI context
 * @param {Array} results - Code search results
 * @returns {string}
 */
formatKnowledgeContext(results) {
  return results.map((r, idx) => {
    const filePath = r.filePath || r.file_path || 'unknown';
    const language = r.language || 'plaintext';
    const code = r.code || r.content || '';
    return `[${idx + 1}] ${filePath}:\n\`\`\`${language}\n${code}\n\`\`\``;
  }).join('\n\n');
}
```

4. Add chatWithKnowledgeContext method:
```javascript
/**
 * Chat with automatic knowledge base context injection
 * @param {Array} messages - User messages
 * @param {Object} options - Chat options (tools, messagesHistory, pageContext)
 * @returns {Promise<Object>} Chat response
 */
async chatWithKnowledgeContext(messages, options = {}) {
  const lastUserMessage = messages[messages.length - 1]?.content || '';

  // Check if message needs code context
  if (this.detectCodeQuestion(lastUserMessage)) {
    try {
      const codeResults = await MCPService.searchCode({
        query: lastUserMessage,
        limit: 3,
        threshold: 0.6
      });

      // Only inject if we got good results
      if (codeResults.results && codeResults.results.length > 0) {
        const contextMessage = {
          role: 'system',
          content: `Relevant code from knowledge base (use this to inform your response):\n\n${this.formatKnowledgeContext(codeResults.results)}`
        };

        // Prepend context to messages
        messages = [contextMessage, ...messages];
      }
    } catch (error) {
      console.error('Knowledge context injection failed:', error);
      // Continue without context rather than failing
    }
  }

  return this.chat(messages, options);
}
```

5. Modify server/routes/ai.js POST /ai/chat route:
   - Change from `AIChatService.chatWithTools` to `AIChatService.chatWithKnowledgeContext` for the non-tool path
   - Keep tool path unchanged (tools take precedence)
  </action>
  <verify>
- Server starts without errors: `npm run dev:server`
- Sending "How do I implement authentication?" to /api/ai/chat queries knowledge base
- Backend logs show "MCP searchCode" calls when code questions detected
- AI responses include code context when knowledge base has matches
  </verify>
  <done>Backend automatically detects code questions and injects knowledge base context into AI prompts</done>
</task>

</tasks>

<verification>
1. Start dev server: `npm run dev`
2. Open AI chat panel
3. Test /search command: type "/search authentication" - should show loading then results
4. Test automatic context: ask "How do I implement login?" - AI should reference code
5. Test normal chat: ask "What's the weather?" - no knowledge base query (no code keywords)
6. Test unknown command: type "/foo bar" - should show error toast
</verification>

<success_criteria>
- /search command works in chat input
- Automatic knowledge context injection works for code questions
- Non-code questions bypass knowledge base (performance)
- All existing chat functionality preserved
- No ESLint errors in modified files
</success_criteria>

<output>
After completion, create `.planning/phases/21-ai-chat-integration/21-01-SUMMARY.md`
</output>
