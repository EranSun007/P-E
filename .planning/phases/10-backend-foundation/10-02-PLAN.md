---
phase: 10-backend-foundation
plan: 02
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - server/services/BugService.js
  - server/routes/bugs.js
  - server/index.js
autonomous: true

must_haves:
  truths:
    - "BugService calculates all 10 KPIs matching specification formulas"
    - "GET /api/bugs/uploads returns list of uploaded weeks"
    - "GET /api/bugs/kpis returns pre-calculated KPIs for week + component"
    - "GET /api/bugs/list returns bugs with filtering and pagination"
    - "DELETE /api/bugs/uploads/:id cascades to bugs and KPIs"
  artifacts:
    - path: "server/services/BugService.js"
      provides: "KPI calculation logic"
      exports: ["calculateKPIs", "uploadCSV"]
    - path: "server/routes/bugs.js"
      provides: "REST API routes for bug dashboard"
      exports: ["router"]
    - path: "server/index.js"
      provides: "Route mounting"
      contains: "/api/bugs"
  key_links:
    - from: "server/routes/bugs.js"
      to: "server/services/BugService.js"
      via: "import and method calls"
      pattern: "BugService\\.(upload|list|get|delete)"
    - from: "server/index.js"
      to: "server/routes/bugs.js"
      via: "app.use mount"
      pattern: "app\\.use\\('/api/bugs'"
---

<objective>
Add KPI calculation logic to BugService and create REST API routes for the Bug Dashboard.

Purpose: Complete the backend foundation by implementing all 10 KPI calculations and exposing them via REST API. This enables the frontend dashboard to display bug metrics.

Output:
- BugService.js with calculateKPIs, uploadCSV, listBugs methods
- bugs.js routes file with GET/POST/DELETE endpoints
- Route mounted in server/index.js
</objective>

<execution_context>
@/Users/i306072/.claude/get-shit-done/workflows/execute-plan.md
@/Users/i306072/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-backend-foundation/10-RESEARCH.md
@.planning/phases/10-backend-foundation/10-01-SUMMARY.md

Reference existing patterns:
@server/routes/jira.js
@server/services/JiraService.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add KPI calculation methods to BugService</name>
  <files>server/services/BugService.js</files>
  <action>
Add the following methods to BugService.js:

**1. calculateKPIs method - calculates all 10 KPIs from bug array:**

```javascript
/**
 * Calculate all 10 KPIs from bug array
 * @param {Array} bugs - Array of bug objects
 * @returns {Object} - KPI values object
 */
calculateKPIs(bugs) {
  const totalBugs = bugs.length;
  const openStatuses = ['Open', 'Author Action', 'In Progress', 'Reopened'];
  const openBugs = bugs.filter(b => openStatuses.includes(b.status));
  const resolvedBugs = bugs.filter(b => b.resolution_time_hours !== null);

  // KPI 1: Bug Inflow Rate (simplified - bugs per week, actual needs 4-week rolling)
  const bugInflowRate = totalBugs / 4; // Assume 4-week dataset

  // KPI 2: Time to First Response (using resolution time as proxy - TTFR not in CSV)
  const sortedTimes = resolvedBugs
    .map(b => b.resolution_time_hours)
    .filter(t => t !== null)
    .sort((a, b) => a - b);
  const medianTTFR = this.calculateMedian(sortedTimes);
  const ttfrUnder24h = sortedTimes.length > 0
    ? (sortedTimes.filter(t => t < 24).length / sortedTimes.length) * 100
    : 0;

  // KPI 3: MTTR by Priority
  const mttrByPriority = {};
  for (const priority of ['Very High', 'High', 'Medium', 'Low']) {
    const priorityBugs = resolvedBugs.filter(b => b.priority === priority);
    const times = priorityBugs.map(b => b.resolution_time_hours).filter(t => t !== null).sort((a, b) => a - b);
    mttrByPriority[priority] = {
      median: this.calculateMedian(times),
      count: priorityBugs.length
    };
  }

  // KPI 4: SLA Compliance
  const vhBugs = resolvedBugs.filter(b => b.priority === 'Very High');
  const highBugs = resolvedBugs.filter(b => b.priority === 'High');
  const slaVhPercent = vhBugs.length > 0
    ? (vhBugs.filter(b => b.resolution_time_hours < 24).length / vhBugs.length) * 100
    : 100; // No VH bugs = 100% compliance
  const slaHighPercent = highBugs.length > 0
    ? (highBugs.filter(b => b.resolution_time_hours < 48).length / highBugs.length) * 100
    : 100;

  // KPI 5: Open Bug Age Distribution
  const now = new Date();
  const openBugAge = {};
  for (const priority of ['Very High', 'High', 'Medium', 'Low']) {
    const priorityOpen = openBugs.filter(b => b.priority === priority);
    const ages = priorityOpen.map(b => {
      if (!b.created_date) return null;
      const created = new Date(b.created_date);
      return (now - created) / (1000 * 60 * 60 * 24); // Days
    }).filter(a => a !== null);
    openBugAge[priority] = {
      count: priorityOpen.length,
      avgAgeDays: ages.length > 0 ? ages.reduce((a, b) => a + b, 0) / ages.length : 0
    };
  }

  // KPI 6: Automated vs Actionable Ratio
  const automatedBugs = bugs.filter(b => b.reporter && b.reporter.startsWith('T_'));
  const automatedPercent = totalBugs > 0
    ? (automatedBugs.length / totalBugs) * 100
    : 0;

  // KPI 7: Bug Category Distribution (uses component field)
  const categoryDistribution = {};
  for (const bug of bugs) {
    const cat = bug.component || 'other';
    categoryDistribution[cat] = (categoryDistribution[cat] || 0) + 1;
  }

  // KPI 8: Duty Rotation Workload (avg bugs per week and std dev)
  // Group by week, then calculate stats
  const weeklyGroups = {};
  for (const bug of bugs) {
    if (!bug.created_date) continue;
    const created = new Date(bug.created_date);
    const weekKey = this.getWeekKey(created);
    weeklyGroups[weekKey] = (weeklyGroups[weekKey] || 0) + 1;
  }
  const weeklyCounts = Object.values(weeklyGroups);
  const avgBugsPerWeek = weeklyCounts.length > 0
    ? weeklyCounts.reduce((a, b) => a + b, 0) / weeklyCounts.length
    : 0;
  const stdDev = this.calculateStdDev(weeklyCounts);

  // KPI 9: Backlog Health Score
  // 100 - (VH_open × 10) - (High_open × 5), clamped 0-100
  const vhOpenCount = openBugs.filter(b => b.priority === 'Very High').length;
  const highOpenCount = openBugs.filter(b => b.priority === 'High').length;
  const backlogHealthScore = Math.max(0, Math.min(100,
    100 - (vhOpenCount * 10) - (highOpenCount * 5)
  ));

  return {
    bug_inflow_rate: bugInflowRate,
    median_ttfr_hours: medianTTFR,
    ttfr_under_24h_percent: ttfrUnder24h,
    mttr_by_priority: mttrByPriority,
    sla_vh_percent: slaVhPercent,
    sla_high_percent: slaHighPercent,
    open_bug_age: openBugAge,
    automated_percent: automatedPercent,
    category_distribution: categoryDistribution,
    avg_bugs_per_week: avgBugsPerWeek,
    workload_std_dev: stdDev,
    backlog_health_score: backlogHealthScore,
    total_bugs: totalBugs,
    open_bugs_count: openBugs.length,
    resolved_bugs_count: resolvedBugs.length
  };
}

/**
 * Calculate median from sorted array
 */
calculateMedian(sortedArr) {
  if (sortedArr.length === 0) return null;
  const mid = Math.floor(sortedArr.length / 2);
  return sortedArr.length % 2 === 0
    ? (sortedArr[mid - 1] + sortedArr[mid]) / 2
    : sortedArr[mid];
}

/**
 * Calculate standard deviation
 */
calculateStdDev(arr) {
  if (arr.length < 2) return 0;
  const mean = arr.reduce((a, b) => a + b, 0) / arr.length;
  const squaredDiffs = arr.map(x => Math.pow(x - mean, 2));
  const variance = squaredDiffs.reduce((a, b) => a + b, 0) / arr.length;
  return Math.sqrt(variance);
}

/**
 * Get ISO week key for grouping
 */
getWeekKey(date) {
  const d = new Date(date);
  d.setHours(0, 0, 0, 0);
  d.setDate(d.getDate() + 4 - (d.getDay() || 7));
  const yearStart = new Date(d.getFullYear(), 0, 1);
  const weekNum = Math.ceil(((d - yearStart) / 86400000 + 1) / 7);
  return `${d.getFullYear()}-W${weekNum.toString().padStart(2, '0')}`;
}
```

**2. uploadCSV method - full upload workflow with transaction:**

```javascript
/**
 * Process CSV upload: parse, validate, store bugs, calculate KPIs
 * @param {string} userId - User ID for multi-tenancy
 * @param {Buffer} fileBuffer - CSV file content
 * @param {string} filename - Original filename
 * @param {string} weekEnding - Week-ending date (Saturday)
 * @returns {Object} - { uploadId, bugCount, components, kpis }
 */
async uploadCSV(userId, fileBuffer, filename, weekEnding) {
  // 1. Parse CSV
  const bugs = await this.parseCSV(fileBuffer);

  // 2. Enrich with calculated fields
  const enrichedBugs = this.enrichBugs(bugs);

  // 3. Begin transaction
  const client = await pool.connect();
  try {
    await client.query('BEGIN');

    // 4. Upsert upload metadata (handles duplicate weeks)
    const uploadResult = await client.query(`
      INSERT INTO bug_uploads (user_id, week_ending, filename, bug_count)
      VALUES ($1, $2, $3, $4)
      ON CONFLICT (user_id, week_ending) DO UPDATE SET
        filename = EXCLUDED.filename,
        bug_count = EXCLUDED.bug_count,
        uploaded_at = CURRENT_TIMESTAMP
      RETURNING id
    `, [userId, weekEnding, filename, enrichedBugs.length]);

    const uploadId = uploadResult.rows[0].id;

    // 5. Delete old bugs for this upload (allows re-upload)
    await client.query('DELETE FROM bugs WHERE upload_id = $1', [uploadId]);

    // 6. Batch insert bugs
    for (const bug of enrichedBugs) {
      await client.query(`
        INSERT INTO bugs (
          upload_id, bug_key, summary, priority, status,
          created_date, resolved_date, resolution_time_hours,
          reporter, assignee, labels, component, raw_data
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
      `, [
        uploadId,
        bug.bug_key,
        bug.summary,
        bug.priority,
        bug.status,
        bug.created_date,
        bug.resolved_date,
        bug.resolution_time_hours,
        bug.reporter,
        bug.assignee,
        bug.labels,
        bug.component,
        JSON.stringify(bug.raw_data)
      ]);
    }

    // 7. Delete old KPIs
    await client.query('DELETE FROM weekly_kpis WHERE upload_id = $1', [uploadId]);

    // 8. Calculate and store KPIs for "all" components
    const allKPIs = this.calculateKPIs(enrichedBugs);
    await client.query(`
      INSERT INTO weekly_kpis (upload_id, component, kpi_data)
      VALUES ($1, NULL, $2)
    `, [uploadId, JSON.stringify(allKPIs)]);

    // 9. Calculate and store KPIs per component
    const components = [...new Set(enrichedBugs.map(b => b.component).filter(Boolean))];
    for (const component of components) {
      const componentBugs = enrichedBugs.filter(b => b.component === component);
      const componentKPIs = this.calculateKPIs(componentBugs);
      await client.query(`
        INSERT INTO weekly_kpis (upload_id, component, kpi_data)
        VALUES ($1, $2, $3)
      `, [uploadId, component, JSON.stringify(componentKPIs)]);
    }

    await client.query('COMMIT');

    return {
      uploadId,
      bugCount: enrichedBugs.length,
      components,
      kpis: allKPIs
    };
  } catch (error) {
    await client.query('ROLLBACK');
    throw error;
  } finally {
    client.release();
  }
}
```

**3. listBugs method - with filtering and pagination:**

```javascript
/**
 * List bugs for an upload with filtering and pagination
 */
async listBugs(userId, uploadId, filters = {}) {
  // First verify user owns the upload
  const upload = await this.getUpload(userId, uploadId);
  if (!upload) {
    throw new Error('Upload not found');
  }

  let sql = `
    SELECT id, bug_key, summary, priority, status, created_date,
           resolved_date, resolution_time_hours, reporter, assignee,
           labels, component
    FROM bugs
    WHERE upload_id = $1
  `;
  const params = [uploadId];
  let paramIndex = 2;

  if (filters.priority) {
    sql += ` AND priority = $${paramIndex}`;
    params.push(filters.priority);
    paramIndex++;
  }

  if (filters.status) {
    sql += ` AND status = $${paramIndex}`;
    params.push(filters.status);
    paramIndex++;
  }

  if (filters.component) {
    sql += ` AND component = $${paramIndex}`;
    params.push(filters.component);
    paramIndex++;
  }

  // Order by priority (VH first), then by age
  sql += ` ORDER BY
    CASE priority
      WHEN 'Very High' THEN 1
      WHEN 'High' THEN 2
      WHEN 'Medium' THEN 3
      WHEN 'Low' THEN 4
      ELSE 5
    END,
    created_date ASC
  `;

  // Pagination
  const limit = filters.limit || 100;
  const offset = filters.offset || 0;
  sql += ` LIMIT $${paramIndex} OFFSET $${paramIndex + 1}`;
  params.push(limit, offset);

  const result = await query(sql, params);
  return result.rows;
}

/**
 * Get KPIs for an upload and optional component
 */
async getKPIs(userId, uploadId, component = null) {
  // Verify user owns the upload
  const upload = await this.getUpload(userId, uploadId);
  if (!upload) {
    throw new Error('Upload not found');
  }

  const sql = `
    SELECT kpi_data, calculated_at
    FROM weekly_kpis
    WHERE upload_id = $1 AND component IS NOT DISTINCT FROM $2
  `;
  const result = await query(sql, [uploadId, component]);

  if (result.rows.length === 0) {
    return null;
  }

  return {
    ...result.rows[0].kpi_data,
    calculated_at: result.rows[0].calculated_at,
    component: component
  };
}
```

Make sure to add `import { pool } from '../db/connection.js'` if not already imported.
  </action>
  <verify>
```bash
# Verify KPI methods added
grep -c "calculateKPIs" server/services/BugService.js
grep -c "uploadCSV" server/services/BugService.js
grep -c "listBugs" server/services/BugService.js
grep -c "getKPIs" server/services/BugService.js
# Each should be >= 1

# Verify all 10 KPIs are calculated
grep -E "bug_inflow_rate|mttr_by_priority|sla_vh_percent|backlog_health_score" server/services/BugService.js | wc -l
# Should be >= 4
```
  </verify>
  <done>BugService has calculateKPIs with all 10 KPIs, uploadCSV with transaction, listBugs with filtering, getKPIs methods</done>
</task>

<task type="auto">
  <name>Task 2: Create REST API routes for bug dashboard</name>
  <files>server/routes/bugs.js</files>
  <action>
Create server/routes/bugs.js following jira.js pattern:

```javascript
import express from 'express';
import multer from 'multer';
import BugService from '../services/BugService.js';
import { authMiddleware } from '../middleware/auth.js';

const router = express.Router();

// Configure multer for memory storage (no disk writes)
const upload = multer({
  storage: multer.memoryStorage(),
  limits: {
    fileSize: 10 * 1024 * 1024 // 10MB
  },
  fileFilter: (req, file, cb) => {
    if (!file.originalname.endsWith('.csv')) {
      cb(new Error('Only CSV files are allowed'));
      return;
    }
    cb(null, true);
  }
});

// Apply authentication to all routes
router.use(authMiddleware);

// ============================================
// Upload Operations (API-01 in Phase 11)
// ============================================

/**
 * POST /api/bugs/upload
 * Upload CSV file and process bugs
 * Body (multipart/form-data): csvFile, weekEnding
 */
router.post('/upload', upload.single('csvFile'), async (req, res) => {
  try {
    const { weekEnding } = req.body;

    if (!req.file) {
      return res.status(400).json({
        error: 'Bad Request',
        message: 'CSV file is required'
      });
    }

    if (!weekEnding) {
      return res.status(400).json({
        error: 'Bad Request',
        message: 'weekEnding date is required'
      });
    }

    // Validate weekEnding is a Saturday
    const weekEndingDate = new Date(weekEnding);
    if (weekEndingDate.getDay() !== 6) {
      return res.status(400).json({
        error: 'Bad Request',
        message: 'weekEnding must be a Saturday'
      });
    }

    const result = await BugService.uploadCSV(
      req.user.id,
      req.file.buffer,
      req.file.originalname,
      weekEnding
    );

    res.json(result);
  } catch (error) {
    console.error('POST /api/bugs/upload error:', error);

    // Return user-friendly error for CSV issues
    if (error.message.includes('Missing required columns')) {
      return res.status(400).json({
        error: 'Invalid CSV',
        message: error.message
      });
    }

    res.status(500).json({ error: 'Internal Server Error', message: error.message });
  }
});

// ============================================
// Upload List (API-02)
// ============================================

/**
 * GET /api/bugs/uploads
 * List all uploaded weeks for dropdown
 */
router.get('/uploads', async (req, res) => {
  try {
    const uploads = await BugService.listUploads(req.user.id);
    res.json(uploads);
  } catch (error) {
    console.error('GET /api/bugs/uploads error:', error);
    res.status(500).json({ error: 'Internal Server Error', message: error.message });
  }
});

// ============================================
// KPIs (API-03)
// ============================================

/**
 * GET /api/bugs/kpis
 * Get KPIs for an upload and optional component
 * Query params: uploadId (required), component (optional)
 */
router.get('/kpis', async (req, res) => {
  try {
    const { uploadId, component } = req.query;

    if (!uploadId) {
      return res.status(400).json({
        error: 'Bad Request',
        message: 'uploadId is required'
      });
    }

    const kpis = await BugService.getKPIs(
      req.user.id,
      uploadId,
      component || null
    );

    if (!kpis) {
      return res.status(404).json({
        error: 'Not Found',
        message: 'KPIs not found for specified upload and component'
      });
    }

    res.json(kpis);
  } catch (error) {
    console.error('GET /api/bugs/kpis error:', error);

    if (error.message === 'Upload not found') {
      return res.status(404).json({
        error: 'Not Found',
        message: error.message
      });
    }

    res.status(500).json({ error: 'Internal Server Error', message: error.message });
  }
});

// ============================================
// Bug List (API-04)
// ============================================

/**
 * GET /api/bugs/list
 * Get bugs for an upload with filtering and pagination
 * Query params: uploadId (required), priority, status, component, limit, offset
 */
router.get('/list', async (req, res) => {
  try {
    const { uploadId, priority, status, component, limit, offset } = req.query;

    if (!uploadId) {
      return res.status(400).json({
        error: 'Bad Request',
        message: 'uploadId is required'
      });
    }

    const filters = {};
    if (priority) filters.priority = priority;
    if (status) filters.status = status;
    if (component) filters.component = component;
    if (limit) filters.limit = parseInt(limit, 10);
    if (offset) filters.offset = parseInt(offset, 10);

    const bugs = await BugService.listBugs(req.user.id, uploadId, filters);
    res.json(bugs);
  } catch (error) {
    console.error('GET /api/bugs/list error:', error);

    if (error.message === 'Upload not found') {
      return res.status(404).json({
        error: 'Not Found',
        message: error.message
      });
    }

    res.status(500).json({ error: 'Internal Server Error', message: error.message });
  }
});

// ============================================
// Delete Upload (API-05)
// ============================================

/**
 * DELETE /api/bugs/uploads/:id
 * Delete an upload (cascades to bugs and KPIs)
 */
router.delete('/uploads/:id', async (req, res) => {
  try {
    const { id } = req.params;

    const deleted = await BugService.deleteUpload(req.user.id, id);

    if (!deleted) {
      return res.status(404).json({
        error: 'Not Found',
        message: 'Upload not found'
      });
    }

    res.json({ success: true, message: 'Upload deleted' });
  } catch (error) {
    console.error('DELETE /api/bugs/uploads/:id error:', error);
    res.status(500).json({ error: 'Internal Server Error', message: error.message });
  }
});

// ============================================
// Check Duplicate (for frontend validation)
// ============================================

/**
 * GET /api/bugs/uploads/check
 * Check if upload exists for a week (for duplicate detection)
 * Query params: weekEnding
 */
router.get('/uploads/check', async (req, res) => {
  try {
    const { weekEnding } = req.query;

    if (!weekEnding) {
      return res.status(400).json({
        error: 'Bad Request',
        message: 'weekEnding is required'
      });
    }

    const existing = await BugService.getUploadByWeek(req.user.id, weekEnding);
    res.json({ exists: !!existing, upload: existing });
  } catch (error) {
    console.error('GET /api/bugs/uploads/check error:', error);
    res.status(500).json({ error: 'Internal Server Error', message: error.message });
  }
});

export default router;
```

Key implementation notes:
- Multer configured for memory storage (no temp files)
- 10MB file size limit for reasonable CSV uploads
- Saturday validation for weekEnding
- User-friendly error messages for CSV validation failures
- All routes enforce multi-tenancy via BugService
  </action>
  <verify>
```bash
# Verify routes file exists with all endpoints
grep -E "router\.(get|post|delete)" server/routes/bugs.js | wc -l
# Expected: 6 routes

# Verify multer import
grep -c "import multer" server/routes/bugs.js
# Expected: 1

# Verify authMiddleware applied
grep -c "authMiddleware" server/routes/bugs.js
# Expected: 1
```
  </verify>
  <done>bugs.js has POST /upload, GET /uploads, GET /kpis, GET /list, DELETE /uploads/:id, GET /uploads/check routes</done>
</task>

<task type="auto">
  <name>Task 3: Mount routes in server/index.js</name>
  <files>server/index.js</files>
  <action>
Add the bug routes to server/index.js:

1. Add import at top with other route imports:
```javascript
import bugsRoutes from './routes/bugs.js';
```

2. Mount route with other API routes (after jira routes):
```javascript
app.use('/api/bugs', bugsRoutes);
```

The placement should be:
- After: `app.use('/api/jira-issues', jiraRoutes);`
- Before: Error handling middleware

Verify the import and mount are in correct locations.
  </action>
  <verify>
```bash
# Verify import added
grep -c "import bugsRoutes" server/index.js
# Expected: 1

# Verify route mounted
grep -c "'/api/bugs'" server/index.js
# Expected: 1
```
  </verify>
  <done>Bug routes mounted at /api/bugs in server/index.js</done>
</task>

</tasks>

<verification>
Phase 10-02 verification:

1. **KPI Calculations (KPI-01 through KPI-09):**
   - BugService.calculateKPIs returns all 10 KPIs
   - Formulas match specification (median, stddev, backlog health)

2. **API Endpoints:**
   - GET /api/bugs/uploads returns upload list (API-02)
   - GET /api/bugs/kpis returns KPIs for upload + component (API-03)
   - GET /api/bugs/list returns bugs with filtering (API-04)
   - DELETE /api/bugs/uploads/:id cascades delete (API-05)

3. **Route Integration:**
   - Routes mounted at /api/bugs
   - Auth middleware applied
   - Proper error handling with HTTP status codes

4. **Test commands:**
```bash
# Start server
npm run dev:server

# Test endpoints (will return 401 without auth, but route exists)
curl -I http://localhost:3001/api/bugs/uploads
curl -I http://localhost:3001/api/bugs/kpis?uploadId=test

# Dev mode authentication (if AUTH_MODE=development)
curl http://localhost:3001/api/bugs/uploads
```
</verification>

<success_criteria>
- [ ] BugService.calculateKPIs calculates all 10 KPIs
- [ ] BugService.uploadCSV processes CSV with transaction
- [ ] BugService.listBugs supports filtering and pagination
- [ ] BugService.getKPIs retrieves pre-calculated KPIs
- [ ] server/routes/bugs.js has 6 routes (upload, uploads, kpis, list, delete, check)
- [ ] Routes mounted at /api/bugs in server/index.js
- [ ] npm run dev:server starts without errors
</success_criteria>

<output>
After completion, create `.planning/phases/10-backend-foundation/10-02-SUMMARY.md`
</output>
